# -*- coding: utf-8 -*-
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType
from pyangbind.lib.yangtypes import RestrictedClassType
from pyangbind.lib.yangtypes import TypedListType
from pyangbind.lib.yangtypes import YANGBool
from pyangbind.lib.yangtypes import YANGListType
from pyangbind.lib.yangtypes import YANGDynClass
from pyangbind.lib.yangtypes import ReferenceType
from pyangbind.lib.base import PybindBase
from collections import OrderedDict
from decimal import Decimal
from bitarray import bitarray
import six

# PY3 support of some PY2 keywords (needs improved)
if six.PY3:
  import builtins as __builtin__
  long = int
elif six.PY2:
  import __builtin__

class yc_vrf_root_ietf_network_instance__network_instances_network_instance_vrf_root(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-network-instance - based on the path /network-instances/network-instance/vrf-root. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container for mount point.
  """
  __slots__ = ('_path_helper', '_extmethods', '__interfaces','__interfaces_state','__routing','__routing_state',)

  _yang_name = 'vrf-root'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__interfaces = YANGDynClass(base=yc_interfaces_ietf_interfaces__interfaces, is_container='container', yang_name="interfaces", parent=self, choice=('root-type', 'vrf-root'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='container', is_config=True)
    self.__interfaces_state = YANGDynClass(base=yc_interfaces_state_ietf_interfaces__interfaces_state, is_container='container', yang_name="interfaces-state", parent=self, choice=('root-type', 'vrf-root'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='container', is_config=True)
    self.__routing = YANGDynClass(base=yc_routing_ietf_routing__routing, is_container='container', yang_name="routing", parent=self, choice=('root-type', 'vrf-root'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)
    self.__routing_state = YANGDynClass(base=yc_routing_state_ietf_routing__routing_state, is_container='container', yang_name="routing-state", parent=self, choice=('root-type', 'vrf-root'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instances', 'network-instance', 'vrf-root']

  def _get_interfaces(self):
    """
    Getter method for interfaces, mapped from YANG variable /network_instances/network_instance/vrf_root (container)

    YANG Description: Interface parameters.
    """
    return self.__interfaces
      
  def _set_interfaces(self, v, load=False):
    """
    Setter method for interfaces, mapped from YANG variable /network_instances/network_instance/vrf_root (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interfaces is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interfaces() directly.

    YANG Description: Interface parameters.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_interfaces_ietf_interfaces__interfaces, is_container='container', yang_name="interfaces", parent=self, choice=('root-type', 'vrf-root'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interfaces must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_interfaces_ietf_interfaces__interfaces, is_container='container', yang_name="interfaces", parent=self, choice=('root-type', 'vrf-root'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='container', is_config=True)""",
        })

    self.__interfaces = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interfaces(self):
    self.__interfaces = YANGDynClass(base=yc_interfaces_ietf_interfaces__interfaces, is_container='container', yang_name="interfaces", parent=self, choice=('root-type', 'vrf-root'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='container', is_config=True)


  def _get_interfaces_state(self):
    """
    Getter method for interfaces_state, mapped from YANG variable /network_instances/network_instance/vrf_root (container)

    YANG Description: Data nodes for the operational state of interfaces.
    """
    return self.__interfaces_state
      
  def _set_interfaces_state(self, v, load=False):
    """
    Setter method for interfaces_state, mapped from YANG variable /network_instances/network_instance/vrf_root (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interfaces_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interfaces_state() directly.

    YANG Description: Data nodes for the operational state of interfaces.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_interfaces_state_ietf_interfaces__interfaces_state, is_container='container', yang_name="interfaces-state", parent=self, choice=('root-type', 'vrf-root'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interfaces_state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_interfaces_state_ietf_interfaces__interfaces_state, is_container='container', yang_name="interfaces-state", parent=self, choice=('root-type', 'vrf-root'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='container', is_config=True)""",
        })

    self.__interfaces_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interfaces_state(self):
    self.__interfaces_state = YANGDynClass(base=yc_interfaces_state_ietf_interfaces__interfaces_state, is_container='container', yang_name="interfaces-state", parent=self, choice=('root-type', 'vrf-root'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='container', is_config=True)


  def _get_routing(self):
    """
    Getter method for routing, mapped from YANG variable /network_instances/network_instance/vrf_root (container)

    YANG Description: Configuration parameters for the routing subsystem.
    """
    return self.__routing
      
  def _set_routing(self, v, load=False):
    """
    Setter method for routing, mapped from YANG variable /network_instances/network_instance/vrf_root (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_routing is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_routing() directly.

    YANG Description: Configuration parameters for the routing subsystem.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_routing_ietf_routing__routing, is_container='container', yang_name="routing", parent=self, choice=('root-type', 'vrf-root'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """routing must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_routing_ietf_routing__routing, is_container='container', yang_name="routing", parent=self, choice=('root-type', 'vrf-root'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)""",
        })

    self.__routing = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_routing(self):
    self.__routing = YANGDynClass(base=yc_routing_ietf_routing__routing, is_container='container', yang_name="routing", parent=self, choice=('root-type', 'vrf-root'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)


  def _get_routing_state(self):
    """
    Getter method for routing_state, mapped from YANG variable /network_instances/network_instance/vrf_root (container)

    YANG Description: State data of the routing subsystem.
    """
    return self.__routing_state
      
  def _set_routing_state(self, v, load=False):
    """
    Setter method for routing_state, mapped from YANG variable /network_instances/network_instance/vrf_root (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_routing_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_routing_state() directly.

    YANG Description: State data of the routing subsystem.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_routing_state_ietf_routing__routing_state, is_container='container', yang_name="routing-state", parent=self, choice=('root-type', 'vrf-root'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """routing_state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_routing_state_ietf_routing__routing_state, is_container='container', yang_name="routing-state", parent=self, choice=('root-type', 'vrf-root'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)""",
        })

    self.__routing_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_routing_state(self):
    self.__routing_state = YANGDynClass(base=yc_routing_state_ietf_routing__routing_state, is_container='container', yang_name="routing-state", parent=self, choice=('root-type', 'vrf-root'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)

  interfaces = __builtin__.property(_get_interfaces, _set_interfaces) # type: yc_interfaces_ietf_interfaces__interfaces
  interfaces_state = __builtin__.property(_get_interfaces_state, _set_interfaces_state) # type: yc_interfaces_state_ietf_interfaces__interfaces_state
  routing = __builtin__.property(_get_routing, _set_routing) # type: yc_routing_ietf_routing__routing
  routing_state = __builtin__.property(_get_routing_state, _set_routing_state) # type: yc_routing_state_ietf_routing__routing_state

  __choices__ = {'root-type': {'vrf-root': ['interfaces', 'interfaces_state', 'routing', 'routing_state']}}
  _pyangbind_elements = OrderedDict([('interfaces', interfaces), ('interfaces_state', interfaces_state), ('routing', routing), ('routing_state', routing_state), ])


class yc_vsi_root_ietf_network_instance__network_instances_network_instance_vsi_root(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-network-instance - based on the path /network-instances/network-instance/vsi-root. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container for mount point.
  """
  _pyangbind_elements = {}

  

class yc_vv_root_ietf_network_instance__network_instances_network_instance_vv_root(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-network-instance - based on the path /network-instances/network-instance/vv-root. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container for mount point.
  """
  _pyangbind_elements = {}

  

class yc_network_instance_ietf_network_instance__network_instances_network_instance(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-network-instance - based on the path /network-instances/network-instance. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of network-instances.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__enabled','__description','__vrf_root','__vsi_root','__vv_root',)

  _yang_name = 'network-instance'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network-instance', defining_module='ietf-network-instance', yang_type='string', is_config=True)
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network-instance', defining_module='ietf-network-instance', yang_type='boolean', is_config=True)
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network-instance', defining_module='ietf-network-instance', yang_type='string', is_config=True)
    self.__vrf_root = YANGDynClass(base=yc_vrf_root_ietf_network_instance__network_instances_network_instance_vrf_root, is_container='container', yang_name="vrf-root", parent=self, choice=('root-type', 'vrf-root'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network-instance', defining_module='ietf-network-instance', yang_type='container', is_config=True)
    self.__vsi_root = YANGDynClass(base=yc_vsi_root_ietf_network_instance__network_instances_network_instance_vsi_root, is_container='container', yang_name="vsi-root", parent=self, choice=('root-type', 'vsi-root'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network-instance', defining_module='ietf-network-instance', yang_type='container', is_config=True)
    self.__vv_root = YANGDynClass(base=yc_vv_root_ietf_network_instance__network_instances_network_instance_vv_root, is_container='container', yang_name="vv-root", parent=self, choice=('root-type', 'vv-root'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network-instance', defining_module='ietf-network-instance', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instances', 'network-instance']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /network_instances/network_instance/name (string)

    YANG Description: device scoped identifier for the network
instance.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /network_instances/network_instance/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: device scoped identifier for the network
instance.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network-instance', defining_module='ietf-network-instance', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network-instance', defining_module='ietf-network-instance', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network-instance', defining_module='ietf-network-instance', yang_type='string', is_config=True)


  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /network_instances/network_instance/enabled (boolean)

    YANG Description: Flag indicating whether or not the network
instance is enabled.
    """
    return self.__enabled
      
  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /network_instances/network_instance/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: Flag indicating whether or not the network
instance is enabled.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network-instance', defining_module='ietf-network-instance', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network-instance', defining_module='ietf-network-instance', yang_type='boolean', is_config=True)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network-instance', defining_module='ietf-network-instance', yang_type='boolean', is_config=True)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /network_instances/network_instance/description (string)

    YANG Description: Description of the network instance
and its intended purpose.
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /network_instances/network_instance/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Description of the network instance
and its intended purpose.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network-instance', defining_module='ietf-network-instance', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network-instance', defining_module='ietf-network-instance', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network-instance', defining_module='ietf-network-instance', yang_type='string', is_config=True)


  def _get_vrf_root(self):
    """
    Getter method for vrf_root, mapped from YANG variable /network_instances/network_instance/vrf_root (container)

    YANG Description: Container for mount point.
    """
    return self.__vrf_root
      
  def _set_vrf_root(self, v, load=False):
    """
    Setter method for vrf_root, mapped from YANG variable /network_instances/network_instance/vrf_root (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vrf_root is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vrf_root() directly.

    YANG Description: Container for mount point.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_vrf_root_ietf_network_instance__network_instances_network_instance_vrf_root, is_container='container', yang_name="vrf-root", parent=self, choice=('root-type', 'vrf-root'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network-instance', defining_module='ietf-network-instance', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vrf_root must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_vrf_root_ietf_network_instance__network_instances_network_instance_vrf_root, is_container='container', yang_name="vrf-root", parent=self, choice=('root-type', 'vrf-root'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network-instance', defining_module='ietf-network-instance', yang_type='container', is_config=True)""",
        })

    self.__vrf_root = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vrf_root(self):
    self.__vrf_root = YANGDynClass(base=yc_vrf_root_ietf_network_instance__network_instances_network_instance_vrf_root, is_container='container', yang_name="vrf-root", parent=self, choice=('root-type', 'vrf-root'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network-instance', defining_module='ietf-network-instance', yang_type='container', is_config=True)


  def _get_vsi_root(self):
    """
    Getter method for vsi_root, mapped from YANG variable /network_instances/network_instance/vsi_root (container)

    YANG Description: Container for mount point.
    """
    return self.__vsi_root
      
  def _set_vsi_root(self, v, load=False):
    """
    Setter method for vsi_root, mapped from YANG variable /network_instances/network_instance/vsi_root (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vsi_root is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vsi_root() directly.

    YANG Description: Container for mount point.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_vsi_root_ietf_network_instance__network_instances_network_instance_vsi_root, is_container='container', yang_name="vsi-root", parent=self, choice=('root-type', 'vsi-root'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network-instance', defining_module='ietf-network-instance', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vsi_root must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_vsi_root_ietf_network_instance__network_instances_network_instance_vsi_root, is_container='container', yang_name="vsi-root", parent=self, choice=('root-type', 'vsi-root'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network-instance', defining_module='ietf-network-instance', yang_type='container', is_config=True)""",
        })

    self.__vsi_root = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vsi_root(self):
    self.__vsi_root = YANGDynClass(base=yc_vsi_root_ietf_network_instance__network_instances_network_instance_vsi_root, is_container='container', yang_name="vsi-root", parent=self, choice=('root-type', 'vsi-root'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network-instance', defining_module='ietf-network-instance', yang_type='container', is_config=True)


  def _get_vv_root(self):
    """
    Getter method for vv_root, mapped from YANG variable /network_instances/network_instance/vv_root (container)

    YANG Description: Container for mount point.
    """
    return self.__vv_root
      
  def _set_vv_root(self, v, load=False):
    """
    Setter method for vv_root, mapped from YANG variable /network_instances/network_instance/vv_root (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vv_root is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vv_root() directly.

    YANG Description: Container for mount point.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_vv_root_ietf_network_instance__network_instances_network_instance_vv_root, is_container='container', yang_name="vv-root", parent=self, choice=('root-type', 'vv-root'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network-instance', defining_module='ietf-network-instance', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vv_root must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_vv_root_ietf_network_instance__network_instances_network_instance_vv_root, is_container='container', yang_name="vv-root", parent=self, choice=('root-type', 'vv-root'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network-instance', defining_module='ietf-network-instance', yang_type='container', is_config=True)""",
        })

    self.__vv_root = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vv_root(self):
    self.__vv_root = YANGDynClass(base=yc_vv_root_ietf_network_instance__network_instances_network_instance_vv_root, is_container='container', yang_name="vv-root", parent=self, choice=('root-type', 'vv-root'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network-instance', defining_module='ietf-network-instance', yang_type='container', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  enabled = __builtin__.property(_get_enabled, _set_enabled)
  description = __builtin__.property(_get_description, _set_description)
  vrf_root = __builtin__.property(_get_vrf_root, _set_vrf_root) # type: yc_vrf_root_ietf_network_instance__network_instances_network_instance_vrf_root
  vsi_root = __builtin__.property(_get_vsi_root, _set_vsi_root) # type: yc_vsi_root_ietf_network_instance__network_instances_network_instance_vsi_root
  vv_root = __builtin__.property(_get_vv_root, _set_vv_root) # type: yc_vv_root_ietf_network_instance__network_instances_network_instance_vv_root

  __choices__ = {'root-type': {'vrf-root': ['vrf_root'], 'vsi-root': ['vsi_root'], 'vv-root': ['vv_root']}}
  _pyangbind_elements = OrderedDict([('name', name), ('enabled', enabled), ('description', description), ('vrf_root', vrf_root), ('vsi_root', vsi_root), ('vv_root', vv_root), ])


class yc_network_instances_ietf_network_instance__network_instances(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-network-instance - based on the path /network-instances. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Network instances each of which consists of a
VRFs (virtual routing and forwarding) and/or
VSIs (virtual switching instances).
  """
  __slots__ = ('_path_helper', '_extmethods', '__network_instance',)

  _yang_name = 'network-instances'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__network_instance = YANGDynClass(base=YANGListType("name",yc_network_instance_ietf_network_instance__network_instances_network_instance, yang_name="network-instance", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="network-instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network-instance', defining_module='ietf-network-instance', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instances']

  def _get_network_instance(self):
    """
    Getter method for network_instance, mapped from YANG variable /network_instances/network_instance (list)

    YANG Description: List of network-instances.
    """
    return self.__network_instance
      
  def _set_network_instance(self, v, load=False):
    """
    Setter method for network_instance, mapped from YANG variable /network_instances/network_instance (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_network_instance is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_network_instance() directly.

    YANG Description: List of network-instances.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_network_instance_ietf_network_instance__network_instances_network_instance, yang_name="network-instance", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="network-instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network-instance', defining_module='ietf-network-instance', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """network_instance must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_network_instance_ietf_network_instance__network_instances_network_instance, yang_name="network-instance", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="network-instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network-instance', defining_module='ietf-network-instance', yang_type='list', is_config=True)""",
        })

    self.__network_instance = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_network_instance(self):
    self.__network_instance = YANGDynClass(base=YANGListType("name",yc_network_instance_ietf_network_instance__network_instances_network_instance, yang_name="network-instance", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="network-instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network-instance', defining_module='ietf-network-instance', yang_type='list', is_config=True)

  network_instance = __builtin__.property(_get_network_instance, _set_network_instance) # type: yc_network_instance_ietf_network_instance__network_instances_network_instance


  _pyangbind_elements = OrderedDict([('network_instance', network_instance), ])


class ietf_network_instance(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-network-instance - based on the path /ietf-network-instance. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module is used to support multiple network instances
within a single physical or virtual device.  Network
instances are commonly known as VRFs (virtual routing
and forwarding) and VSIs (virtual switching instances).

Copyright (c) 2017 IETF Trust and the persons
identified as authors of the code.  All rights reserved.

Redistribution and use in source and binary forms, with or
without modification, is permitted pursuant to, and subject
to the license terms contained in, the Simplified BSD License
set forth in Section 4.c of the IETF Trust's Legal Provisions
Relating to IETF Documents
(http://trustee.ietf.org/license-info).

This version of this YANG module is part of RFC XXXX; see
the RFC itself for full legal notices.
  """
  __slots__ = ('_path_helper', '_extmethods', '__network_instances',)

  _yang_name = 'ietf-network-instance'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__network_instances = YANGDynClass(base=yc_network_instances_ietf_network_instance__network_instances, is_container='container', yang_name="network-instances", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network-instance', defining_module='ietf-network-instance', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_network_instances(self):
    """
    Getter method for network_instances, mapped from YANG variable /network_instances (container)

    YANG Description: Network instances each of which consists of a
VRFs (virtual routing and forwarding) and/or
VSIs (virtual switching instances).
    """
    return self.__network_instances
      
  def _set_network_instances(self, v, load=False):
    """
    Setter method for network_instances, mapped from YANG variable /network_instances (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_network_instances is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_network_instances() directly.

    YANG Description: Network instances each of which consists of a
VRFs (virtual routing and forwarding) and/or
VSIs (virtual switching instances).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_network_instances_ietf_network_instance__network_instances, is_container='container', yang_name="network-instances", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network-instance', defining_module='ietf-network-instance', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """network_instances must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_network_instances_ietf_network_instance__network_instances, is_container='container', yang_name="network-instances", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network-instance', defining_module='ietf-network-instance', yang_type='container', is_config=True)""",
        })

    self.__network_instances = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_network_instances(self):
    self.__network_instances = YANGDynClass(base=yc_network_instances_ietf_network_instance__network_instances, is_container='container', yang_name="network-instances", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network-instance', defining_module='ietf-network-instance', yang_type='container', is_config=True)

  network_instances = __builtin__.property(_get_network_instances, _set_network_instances) # type: yc_network_instances_ietf_network_instance__network_instances


  _pyangbind_elements = OrderedDict([('network_instances', network_instances), ])


class yc_namespace_ietf_yang_schema_mount__schema_mounts_namespace(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-yang-schema-mount - based on the path /schema-mounts/namespace. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This list provides a mapping of namespace prefixes that are
used in XPath expressions of 'parent-reference' leafs to the
corresponding namespace URI references.
  """
  __slots__ = ('_path_helper', '_extmethods', '__prefix','__uri',)

  _yang_name = 'namespace'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-yang-schema-mount'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__prefix = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[a-zA-Z_][a-zA-Z0-9\\-_.]*', 'length': ['1..max']}), is_leaf=True, yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-yang-schema-mount', defining_module='ietf-yang-schema-mount', yang_type='yang:yang-identifier', is_config=False)
    self.__uri = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="uri", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-yang-schema-mount', defining_module='ietf-yang-schema-mount', yang_type='inet:uri', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['schema-mounts', 'namespace']

  def _get_prefix(self):
    """
    Getter method for prefix, mapped from YANG variable /schema_mounts/namespace/prefix (yang:yang-identifier)

    YANG Description: Namespace prefix.
    """
    return self.__prefix
      
  def _set_prefix(self, v, load=False):
    """
    Setter method for prefix, mapped from YANG variable /schema_mounts/namespace/prefix (yang:yang-identifier)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prefix is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prefix() directly.

    YANG Description: Namespace prefix.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[a-zA-Z_][a-zA-Z0-9\\-_.]*', 'length': ['1..max']}), is_leaf=True, yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-yang-schema-mount', defining_module='ietf-yang-schema-mount', yang_type='yang:yang-identifier', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prefix must be of a type compatible with yang:yang-identifier""",
          'defined-type': "yang:yang-identifier",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[a-zA-Z_][a-zA-Z0-9\\-_.]*', 'length': ['1..max']}), is_leaf=True, yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-yang-schema-mount', defining_module='ietf-yang-schema-mount', yang_type='yang:yang-identifier', is_config=False)""",
        })

    self.__prefix = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prefix(self):
    self.__prefix = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[a-zA-Z_][a-zA-Z0-9\\-_.]*', 'length': ['1..max']}), is_leaf=True, yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-yang-schema-mount', defining_module='ietf-yang-schema-mount', yang_type='yang:yang-identifier', is_config=False)


  def _get_uri(self):
    """
    Getter method for uri, mapped from YANG variable /schema_mounts/namespace/uri (inet:uri)

    YANG Description: Namespace URI reference.
    """
    return self.__uri
      
  def _set_uri(self, v, load=False):
    """
    Setter method for uri, mapped from YANG variable /schema_mounts/namespace/uri (inet:uri)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_uri is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_uri() directly.

    YANG Description: Namespace URI reference.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="uri", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-yang-schema-mount', defining_module='ietf-yang-schema-mount', yang_type='inet:uri', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """uri must be of a type compatible with inet:uri""",
          'defined-type': "inet:uri",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="uri", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-yang-schema-mount', defining_module='ietf-yang-schema-mount', yang_type='inet:uri', is_config=False)""",
        })

    self.__uri = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_uri(self):
    self.__uri = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="uri", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-yang-schema-mount', defining_module='ietf-yang-schema-mount', yang_type='inet:uri', is_config=False)

  prefix = __builtin__.property(_get_prefix)
  uri = __builtin__.property(_get_uri)


  _pyangbind_elements = OrderedDict([('prefix', prefix), ('uri', uri), ])


class yc_shared_schema_ietf_yang_schema_mount__schema_mounts_mount_point_shared_schema(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-yang-schema-mount - based on the path /schema-mounts/mount-point/shared-schema. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This node indicates that the server has mounted at least
the module 'ietf-yang-library' at the mount point, and
its instantiation provides the information about the
mounted schema.  When XPath expressions in the mounted
schema are evaluated, the 'parent-reference' leaf-list
is taken into account.

Different instances of the mount point MUST have the
same schema mounted.
  """
  __slots__ = ('_path_helper', '_extmethods', '__parent_reference',)

  _yang_name = 'shared-schema'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-yang-schema-mount'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__parent_reference = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="parent-reference", parent=self, choice=('schema-ref', 'shared-schema'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-yang-schema-mount', defining_module='ietf-yang-schema-mount', yang_type='yang:xpath1.0', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['schema-mounts', 'mount-point', 'shared-schema']

  def _get_parent_reference(self):
    """
    Getter method for parent_reference, mapped from YANG variable /schema_mounts/mount_point/shared_schema/parent_reference (yang:xpath1.0)

    YANG Description: Entries of this leaf-list are XPath 1.0 expressions
that are evaluated in the following context:

- The context node is the node in the parent data tree
  where the mount-point is defined.

- The accessible tree is the parent data tree
  *without* any nodes defined in modules that are
  mounted inside the parent schema.

- The context position and context size are both equal
  to 1.

- The set of variable bindings is empty.

- The function library is the core function library
  defined in the W3C XPath 1.0 document
  (http://www.w3.org/TR/1999/REC-xpath-19991116) and
  the functions defined in Section 10 of RFC 7950.

- The set of namespace declarations is defined by the
  'namespace' list under 'schema-mounts'.

Each XPath expression MUST evaluate to a node-set
(possibly empty).  For the purposes of evaluating
XPath expressions whose context nodes are defined in
the mounted schema, the union of all these node-sets
together with ancestor nodes are added to the
accessible data tree.

Note that in the case 'ietf-yang-schema-mount' is
itself mounted, a 'parent-reference' in the mounted
module may refer to nodes that were brought into the
accessible tree through a 'parent-reference' in the
parent schema.
    """
    return self.__parent_reference
      
  def _set_parent_reference(self, v, load=False):
    """
    Setter method for parent_reference, mapped from YANG variable /schema_mounts/mount_point/shared_schema/parent_reference (yang:xpath1.0)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_parent_reference is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_parent_reference() directly.

    YANG Description: Entries of this leaf-list are XPath 1.0 expressions
that are evaluated in the following context:

- The context node is the node in the parent data tree
  where the mount-point is defined.

- The accessible tree is the parent data tree
  *without* any nodes defined in modules that are
  mounted inside the parent schema.

- The context position and context size are both equal
  to 1.

- The set of variable bindings is empty.

- The function library is the core function library
  defined in the W3C XPath 1.0 document
  (http://www.w3.org/TR/1999/REC-xpath-19991116) and
  the functions defined in Section 10 of RFC 7950.

- The set of namespace declarations is defined by the
  'namespace' list under 'schema-mounts'.

Each XPath expression MUST evaluate to a node-set
(possibly empty).  For the purposes of evaluating
XPath expressions whose context nodes are defined in
the mounted schema, the union of all these node-sets
together with ancestor nodes are added to the
accessible data tree.

Note that in the case 'ietf-yang-schema-mount' is
itself mounted, a 'parent-reference' in the mounted
module may refer to nodes that were brought into the
accessible tree through a 'parent-reference' in the
parent schema.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="parent-reference", parent=self, choice=('schema-ref', 'shared-schema'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-yang-schema-mount', defining_module='ietf-yang-schema-mount', yang_type='yang:xpath1.0', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """parent_reference must be of a type compatible with yang:xpath1.0""",
          'defined-type': "yang:xpath1.0",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="parent-reference", parent=self, choice=('schema-ref', 'shared-schema'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-yang-schema-mount', defining_module='ietf-yang-schema-mount', yang_type='yang:xpath1.0', is_config=False)""",
        })

    self.__parent_reference = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_parent_reference(self):
    self.__parent_reference = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="parent-reference", parent=self, choice=('schema-ref', 'shared-schema'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-yang-schema-mount', defining_module='ietf-yang-schema-mount', yang_type='yang:xpath1.0', is_config=False)

  parent_reference = __builtin__.property(_get_parent_reference)

  __choices__ = {'schema-ref': {'shared-schema': ['parent_reference']}}
  _pyangbind_elements = OrderedDict([('parent_reference', parent_reference), ])


class yc_mount_point_ietf_yang_schema_mount__schema_mounts_mount_point(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-yang-schema-mount - based on the path /schema-mounts/mount-point. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Each entry of this list specifies a schema for a particular
mount point.

Each mount point MUST be defined using the 'mount-point'
extension in one of the modules listed in the server's
YANG library instance with conformance type 'implement'.
  """
  __slots__ = ('_path_helper', '_extmethods', '__module','__label','__config','__shared_schema',)

  _yang_name = 'mount-point'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-yang-schema-mount'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__module = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[a-zA-Z_][a-zA-Z0-9\\-_.]*', 'length': ['1..max']}), is_leaf=True, yang_name="module", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-yang-schema-mount', defining_module='ietf-yang-schema-mount', yang_type='yang:yang-identifier', is_config=False)
    self.__label = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[a-zA-Z_][a-zA-Z0-9\\-_.]*', 'length': ['1..max']}), is_leaf=True, yang_name="label", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-yang-schema-mount', defining_module='ietf-yang-schema-mount', yang_type='yang:yang-identifier', is_config=False)
    self.__config = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-yang-schema-mount', defining_module='ietf-yang-schema-mount', yang_type='boolean', is_config=False)
    self.__shared_schema = YANGDynClass(base=yc_shared_schema_ietf_yang_schema_mount__schema_mounts_mount_point_shared_schema, is_container='container', yang_name="shared-schema", parent=self, choice=('schema-ref', 'shared-schema'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-yang-schema-mount', defining_module='ietf-yang-schema-mount', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['schema-mounts', 'mount-point']

  def _get_module(self):
    """
    Getter method for module, mapped from YANG variable /schema_mounts/mount_point/module (yang:yang-identifier)

    YANG Description: Name of a module containing the mount point.
    """
    return self.__module
      
  def _set_module(self, v, load=False):
    """
    Setter method for module, mapped from YANG variable /schema_mounts/mount_point/module (yang:yang-identifier)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_module is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_module() directly.

    YANG Description: Name of a module containing the mount point.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[a-zA-Z_][a-zA-Z0-9\\-_.]*', 'length': ['1..max']}), is_leaf=True, yang_name="module", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-yang-schema-mount', defining_module='ietf-yang-schema-mount', yang_type='yang:yang-identifier', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """module must be of a type compatible with yang:yang-identifier""",
          'defined-type': "yang:yang-identifier",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[a-zA-Z_][a-zA-Z0-9\\-_.]*', 'length': ['1..max']}), is_leaf=True, yang_name="module", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-yang-schema-mount', defining_module='ietf-yang-schema-mount', yang_type='yang:yang-identifier', is_config=False)""",
        })

    self.__module = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_module(self):
    self.__module = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[a-zA-Z_][a-zA-Z0-9\\-_.]*', 'length': ['1..max']}), is_leaf=True, yang_name="module", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-yang-schema-mount', defining_module='ietf-yang-schema-mount', yang_type='yang:yang-identifier', is_config=False)


  def _get_label(self):
    """
    Getter method for label, mapped from YANG variable /schema_mounts/mount_point/label (yang:yang-identifier)

    YANG Description: Label of the mount point defined using the 'mount-point'
extension.
    """
    return self.__label
      
  def _set_label(self, v, load=False):
    """
    Setter method for label, mapped from YANG variable /schema_mounts/mount_point/label (yang:yang-identifier)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_label is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_label() directly.

    YANG Description: Label of the mount point defined using the 'mount-point'
extension.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[a-zA-Z_][a-zA-Z0-9\\-_.]*', 'length': ['1..max']}), is_leaf=True, yang_name="label", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-yang-schema-mount', defining_module='ietf-yang-schema-mount', yang_type='yang:yang-identifier', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """label must be of a type compatible with yang:yang-identifier""",
          'defined-type': "yang:yang-identifier",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[a-zA-Z_][a-zA-Z0-9\\-_.]*', 'length': ['1..max']}), is_leaf=True, yang_name="label", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-yang-schema-mount', defining_module='ietf-yang-schema-mount', yang_type='yang:yang-identifier', is_config=False)""",
        })

    self.__label = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_label(self):
    self.__label = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[a-zA-Z_][a-zA-Z0-9\\-_.]*', 'length': ['1..max']}), is_leaf=True, yang_name="label", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-yang-schema-mount', defining_module='ietf-yang-schema-mount', yang_type='yang:yang-identifier', is_config=False)


  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /schema_mounts/mount_point/config (boolean)

    YANG Description: If this leaf is set to 'false', then all data nodes in the
mounted schema are read-only ('config false'), regardless
of their 'config' property.
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /schema_mounts/mount_point/config (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: If this leaf is set to 'false', then all data nodes in the
mounted schema are read-only ('config false'), regardless
of their 'config' property.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-yang-schema-mount', defining_module='ietf-yang-schema-mount', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-yang-schema-mount', defining_module='ietf-yang-schema-mount', yang_type='boolean', is_config=False)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-yang-schema-mount', defining_module='ietf-yang-schema-mount', yang_type='boolean', is_config=False)


  def _get_shared_schema(self):
    """
    Getter method for shared_schema, mapped from YANG variable /schema_mounts/mount_point/shared_schema (container)

    YANG Description: This node indicates that the server has mounted at least
the module 'ietf-yang-library' at the mount point, and
its instantiation provides the information about the
mounted schema.  When XPath expressions in the mounted
schema are evaluated, the 'parent-reference' leaf-list
is taken into account.

Different instances of the mount point MUST have the
same schema mounted.
    """
    return self.__shared_schema
      
  def _set_shared_schema(self, v, load=False):
    """
    Setter method for shared_schema, mapped from YANG variable /schema_mounts/mount_point/shared_schema (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_shared_schema is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_shared_schema() directly.

    YANG Description: This node indicates that the server has mounted at least
the module 'ietf-yang-library' at the mount point, and
its instantiation provides the information about the
mounted schema.  When XPath expressions in the mounted
schema are evaluated, the 'parent-reference' leaf-list
is taken into account.

Different instances of the mount point MUST have the
same schema mounted.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_shared_schema_ietf_yang_schema_mount__schema_mounts_mount_point_shared_schema, is_container='container', yang_name="shared-schema", parent=self, choice=('schema-ref', 'shared-schema'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-yang-schema-mount', defining_module='ietf-yang-schema-mount', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """shared_schema must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_shared_schema_ietf_yang_schema_mount__schema_mounts_mount_point_shared_schema, is_container='container', yang_name="shared-schema", parent=self, choice=('schema-ref', 'shared-schema'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-yang-schema-mount', defining_module='ietf-yang-schema-mount', yang_type='container', is_config=False)""",
        })

    self.__shared_schema = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_shared_schema(self):
    self.__shared_schema = YANGDynClass(base=yc_shared_schema_ietf_yang_schema_mount__schema_mounts_mount_point_shared_schema, is_container='container', yang_name="shared-schema", parent=self, choice=('schema-ref', 'shared-schema'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-yang-schema-mount', defining_module='ietf-yang-schema-mount', yang_type='container', is_config=False)

  module = __builtin__.property(_get_module)
  label = __builtin__.property(_get_label)
  config = __builtin__.property(_get_config)
  shared_schema = __builtin__.property(_get_shared_schema) # type: yc_shared_schema_ietf_yang_schema_mount__schema_mounts_mount_point_shared_schema

  __choices__ = {'schema-ref': {'shared-schema': ['shared_schema']}}
  _pyangbind_elements = OrderedDict([('module', module), ('label', label), ('config', config), ('shared_schema', shared_schema), ])


class yc_schema_mounts_ietf_yang_schema_mount__schema_mounts(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-yang-schema-mount - based on the path /schema-mounts. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Contains information about the structure of the overall
mounted data model implemented in the server.
  """
  __slots__ = ('_path_helper', '_extmethods', '__namespace','__mount_point',)

  _yang_name = 'schema-mounts'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-yang-schema-mount'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__namespace = YANGDynClass(base=YANGListType("prefix",yc_namespace_ietf_yang_schema_mount__schema_mounts_namespace, yang_name="namespace", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='prefix', extensions=None), is_container='list', yang_name="namespace", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-yang-schema-mount', defining_module='ietf-yang-schema-mount', yang_type='list', is_config=False)
    self.__mount_point = YANGDynClass(base=YANGListType("module label",yc_mount_point_ietf_yang_schema_mount__schema_mounts_mount_point, yang_name="mount-point", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='module label', extensions=None), is_container='list', yang_name="mount-point", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-yang-schema-mount', defining_module='ietf-yang-schema-mount', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['schema-mounts']

  def _get_namespace(self):
    """
    Getter method for namespace, mapped from YANG variable /schema_mounts/namespace (list)

    YANG Description: This list provides a mapping of namespace prefixes that are
used in XPath expressions of 'parent-reference' leafs to the
corresponding namespace URI references.
    """
    return self.__namespace
      
  def _set_namespace(self, v, load=False):
    """
    Setter method for namespace, mapped from YANG variable /schema_mounts/namespace (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_namespace is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_namespace() directly.

    YANG Description: This list provides a mapping of namespace prefixes that are
used in XPath expressions of 'parent-reference' leafs to the
corresponding namespace URI references.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("prefix",yc_namespace_ietf_yang_schema_mount__schema_mounts_namespace, yang_name="namespace", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='prefix', extensions=None), is_container='list', yang_name="namespace", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-yang-schema-mount', defining_module='ietf-yang-schema-mount', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """namespace must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("prefix",yc_namespace_ietf_yang_schema_mount__schema_mounts_namespace, yang_name="namespace", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='prefix', extensions=None), is_container='list', yang_name="namespace", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-yang-schema-mount', defining_module='ietf-yang-schema-mount', yang_type='list', is_config=False)""",
        })

    self.__namespace = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_namespace(self):
    self.__namespace = YANGDynClass(base=YANGListType("prefix",yc_namespace_ietf_yang_schema_mount__schema_mounts_namespace, yang_name="namespace", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='prefix', extensions=None), is_container='list', yang_name="namespace", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-yang-schema-mount', defining_module='ietf-yang-schema-mount', yang_type='list', is_config=False)


  def _get_mount_point(self):
    """
    Getter method for mount_point, mapped from YANG variable /schema_mounts/mount_point (list)

    YANG Description: Each entry of this list specifies a schema for a particular
mount point.

Each mount point MUST be defined using the 'mount-point'
extension in one of the modules listed in the server's
YANG library instance with conformance type 'implement'.
    """
    return self.__mount_point
      
  def _set_mount_point(self, v, load=False):
    """
    Setter method for mount_point, mapped from YANG variable /schema_mounts/mount_point (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mount_point is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mount_point() directly.

    YANG Description: Each entry of this list specifies a schema for a particular
mount point.

Each mount point MUST be defined using the 'mount-point'
extension in one of the modules listed in the server's
YANG library instance with conformance type 'implement'.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("module label",yc_mount_point_ietf_yang_schema_mount__schema_mounts_mount_point, yang_name="mount-point", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='module label', extensions=None), is_container='list', yang_name="mount-point", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-yang-schema-mount', defining_module='ietf-yang-schema-mount', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mount_point must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("module label",yc_mount_point_ietf_yang_schema_mount__schema_mounts_mount_point, yang_name="mount-point", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='module label', extensions=None), is_container='list', yang_name="mount-point", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-yang-schema-mount', defining_module='ietf-yang-schema-mount', yang_type='list', is_config=False)""",
        })

    self.__mount_point = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mount_point(self):
    self.__mount_point = YANGDynClass(base=YANGListType("module label",yc_mount_point_ietf_yang_schema_mount__schema_mounts_mount_point, yang_name="mount-point", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='module label', extensions=None), is_container='list', yang_name="mount-point", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-yang-schema-mount', defining_module='ietf-yang-schema-mount', yang_type='list', is_config=False)

  namespace = __builtin__.property(_get_namespace) # type: yc_namespace_ietf_yang_schema_mount__schema_mounts_namespace
  mount_point = __builtin__.property(_get_mount_point) # type: yc_mount_point_ietf_yang_schema_mount__schema_mounts_mount_point


  _pyangbind_elements = OrderedDict([('namespace', namespace), ('mount_point', mount_point), ])


class ietf_yang_schema_mount(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-yang-schema-mount - based on the path /ietf-yang-schema-mount. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines a YANG extension statement that can be used
to incorporate data models defined in other YANG modules in a
module.  It also defines operational state data that specify the
overall structure of the data model.

The key words 'MUST', 'MUST NOT', 'REQUIRED', 'SHALL', 'SHALL
NOT', 'SHOULD', 'SHOULD NOT', 'RECOMMENDED', 'NOT RECOMMENDED',
'MAY', and 'OPTIONAL' in this document are to be interpreted as
described in BCP 14 (RFC 2119) (RFC 8174) when, and only when,
they appear in all capitals, as shown here.

Copyright (c) 2019 IETF Trust and the persons identified as
authors of the code.  All rights reserved.

Redistribution and use in source and binary forms, with or
without modification, is permitted pursuant to, and subject to
the license terms contained in, the Simplified BSD License set
forth in Section 4.c of the IETF Trust's Legal Provisions
Relating to IETF Documents
(https://trustee.ietf.org/license-info).

This version of this YANG module is part of RFC 8528;
see the RFC itself for full legal notices.
  """
  __slots__ = ('_path_helper', '_extmethods', '__schema_mounts',)

  _yang_name = 'ietf-yang-schema-mount'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-yang-schema-mount'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__schema_mounts = YANGDynClass(base=yc_schema_mounts_ietf_yang_schema_mount__schema_mounts, is_container='container', yang_name="schema-mounts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-yang-schema-mount', defining_module='ietf-yang-schema-mount', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_schema_mounts(self):
    """
    Getter method for schema_mounts, mapped from YANG variable /schema_mounts (container)

    YANG Description: Contains information about the structure of the overall
mounted data model implemented in the server.
    """
    return self.__schema_mounts
      
  def _set_schema_mounts(self, v, load=False):
    """
    Setter method for schema_mounts, mapped from YANG variable /schema_mounts (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_schema_mounts is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_schema_mounts() directly.

    YANG Description: Contains information about the structure of the overall
mounted data model implemented in the server.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_schema_mounts_ietf_yang_schema_mount__schema_mounts, is_container='container', yang_name="schema-mounts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-yang-schema-mount', defining_module='ietf-yang-schema-mount', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """schema_mounts must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_schema_mounts_ietf_yang_schema_mount__schema_mounts, is_container='container', yang_name="schema-mounts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-yang-schema-mount', defining_module='ietf-yang-schema-mount', yang_type='container', is_config=True)""",
        })

    self.__schema_mounts = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_schema_mounts(self):
    self.__schema_mounts = YANGDynClass(base=yc_schema_mounts_ietf_yang_schema_mount__schema_mounts, is_container='container', yang_name="schema-mounts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-yang-schema-mount', defining_module='ietf-yang-schema-mount', yang_type='container', is_config=True)

  schema_mounts = __builtin__.property(_get_schema_mounts, _set_schema_mounts) # type: yc_schema_mounts_ietf_yang_schema_mount__schema_mounts


  _pyangbind_elements = OrderedDict([('schema_mounts', schema_mounts), ])


class yc_statistics_ietf_interfaces__interfaces_interface_statistics(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-interfaces - based on the path /interfaces/interface/statistics. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: A collection of interface-related statistics objects.
  """
  __slots__ = ('_path_helper', '_extmethods', '__discontinuity_time','__in_octets','__in_unicast_pkts','__in_broadcast_pkts','__in_multicast_pkts','__in_discards','__in_errors','__in_unknown_protos','__out_octets','__out_unicast_pkts','__out_broadcast_pkts','__out_multicast_pkts','__out_discards','__out_errors',)

  _yang_name = 'statistics'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__discontinuity_time = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="discontinuity-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:date-and-time', is_config=False)
    self.__in_octets = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)
    self.__in_unicast_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-unicast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)
    self.__in_broadcast_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-broadcast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)
    self.__in_multicast_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-multicast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)
    self.__in_discards = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="in-discards", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter32', is_config=False)
    self.__in_errors = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="in-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter32', is_config=False)
    self.__in_unknown_protos = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="in-unknown-protos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter32', is_config=False)
    self.__out_octets = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)
    self.__out_unicast_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-unicast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)
    self.__out_broadcast_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-broadcast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)
    self.__out_multicast_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-multicast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)
    self.__out_discards = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="out-discards", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter32', is_config=False)
    self.__out_errors = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="out-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter32', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'statistics']

  def _get_discontinuity_time(self):
    """
    Getter method for discontinuity_time, mapped from YANG variable /interfaces/interface/statistics/discontinuity_time (yang:date-and-time)

    YANG Description: The time on the most recent occasion at which any one or
more of this interface's counters suffered a
discontinuity.  If no such discontinuities have occurred
since the last re-initialization of the local management
subsystem, then this node contains the time the local
management subsystem re-initialized itself.
    """
    return self.__discontinuity_time
      
  def _set_discontinuity_time(self, v, load=False):
    """
    Setter method for discontinuity_time, mapped from YANG variable /interfaces/interface/statistics/discontinuity_time (yang:date-and-time)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_discontinuity_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_discontinuity_time() directly.

    YANG Description: The time on the most recent occasion at which any one or
more of this interface's counters suffered a
discontinuity.  If no such discontinuities have occurred
since the last re-initialization of the local management
subsystem, then this node contains the time the local
management subsystem re-initialized itself.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="discontinuity-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:date-and-time', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """discontinuity_time must be of a type compatible with yang:date-and-time""",
          'defined-type': "yang:date-and-time",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="discontinuity-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:date-and-time', is_config=False)""",
        })

    self.__discontinuity_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_discontinuity_time(self):
    self.__discontinuity_time = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="discontinuity-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:date-and-time', is_config=False)


  def _get_in_octets(self):
    """
    Getter method for in_octets, mapped from YANG variable /interfaces/interface/statistics/in_octets (yang:counter64)

    YANG Description: The total number of octets received on the interface,
including framing characters.

Discontinuities in the value of this counter can occur
at re-initialization of the management system, and at
other times as indicated by the value of
'discontinuity-time'.
    """
    return self.__in_octets
      
  def _set_in_octets(self, v, load=False):
    """
    Setter method for in_octets, mapped from YANG variable /interfaces/interface/statistics/in_octets (yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_octets is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_octets() directly.

    YANG Description: The total number of octets received on the interface,
including framing characters.

Discontinuities in the value of this counter can occur
at re-initialization of the management system, and at
other times as indicated by the value of
'discontinuity-time'.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_octets must be of a type compatible with yang:counter64""",
          'defined-type': "yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)""",
        })

    self.__in_octets = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_octets(self):
    self.__in_octets = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)


  def _get_in_unicast_pkts(self):
    """
    Getter method for in_unicast_pkts, mapped from YANG variable /interfaces/interface/statistics/in_unicast_pkts (yang:counter64)

    YANG Description: The number of packets, delivered by this sub-layer to a
higher (sub-)layer, that were not addressed to a
multicast or broadcast address at this sub-layer.

Discontinuities in the value of this counter can occur
at re-initialization of the management system, and at
other times as indicated by the value of
'discontinuity-time'.
    """
    return self.__in_unicast_pkts
      
  def _set_in_unicast_pkts(self, v, load=False):
    """
    Setter method for in_unicast_pkts, mapped from YANG variable /interfaces/interface/statistics/in_unicast_pkts (yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_unicast_pkts is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_unicast_pkts() directly.

    YANG Description: The number of packets, delivered by this sub-layer to a
higher (sub-)layer, that were not addressed to a
multicast or broadcast address at this sub-layer.

Discontinuities in the value of this counter can occur
at re-initialization of the management system, and at
other times as indicated by the value of
'discontinuity-time'.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-unicast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_unicast_pkts must be of a type compatible with yang:counter64""",
          'defined-type': "yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-unicast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)""",
        })

    self.__in_unicast_pkts = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_unicast_pkts(self):
    self.__in_unicast_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-unicast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)


  def _get_in_broadcast_pkts(self):
    """
    Getter method for in_broadcast_pkts, mapped from YANG variable /interfaces/interface/statistics/in_broadcast_pkts (yang:counter64)

    YANG Description: The number of packets, delivered by this sub-layer to a
higher (sub-)layer, that were addressed to a broadcast
address at this sub-layer.

Discontinuities in the value of this counter can occur
at re-initialization of the management system, and at
other times as indicated by the value of
'discontinuity-time'.
    """
    return self.__in_broadcast_pkts
      
  def _set_in_broadcast_pkts(self, v, load=False):
    """
    Setter method for in_broadcast_pkts, mapped from YANG variable /interfaces/interface/statistics/in_broadcast_pkts (yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_broadcast_pkts is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_broadcast_pkts() directly.

    YANG Description: The number of packets, delivered by this sub-layer to a
higher (sub-)layer, that were addressed to a broadcast
address at this sub-layer.

Discontinuities in the value of this counter can occur
at re-initialization of the management system, and at
other times as indicated by the value of
'discontinuity-time'.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-broadcast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_broadcast_pkts must be of a type compatible with yang:counter64""",
          'defined-type': "yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-broadcast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)""",
        })

    self.__in_broadcast_pkts = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_broadcast_pkts(self):
    self.__in_broadcast_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-broadcast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)


  def _get_in_multicast_pkts(self):
    """
    Getter method for in_multicast_pkts, mapped from YANG variable /interfaces/interface/statistics/in_multicast_pkts (yang:counter64)

    YANG Description: The number of packets, delivered by this sub-layer to a
higher (sub-)layer, that were addressed to a multicast
address at this sub-layer.  For a MAC-layer protocol,
this includes both Group and Functional addresses.

Discontinuities in the value of this counter can occur
at re-initialization of the management system, and at
other times as indicated by the value of
'discontinuity-time'.
    """
    return self.__in_multicast_pkts
      
  def _set_in_multicast_pkts(self, v, load=False):
    """
    Setter method for in_multicast_pkts, mapped from YANG variable /interfaces/interface/statistics/in_multicast_pkts (yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_multicast_pkts is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_multicast_pkts() directly.

    YANG Description: The number of packets, delivered by this sub-layer to a
higher (sub-)layer, that were addressed to a multicast
address at this sub-layer.  For a MAC-layer protocol,
this includes both Group and Functional addresses.

Discontinuities in the value of this counter can occur
at re-initialization of the management system, and at
other times as indicated by the value of
'discontinuity-time'.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-multicast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_multicast_pkts must be of a type compatible with yang:counter64""",
          'defined-type': "yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-multicast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)""",
        })

    self.__in_multicast_pkts = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_multicast_pkts(self):
    self.__in_multicast_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-multicast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)


  def _get_in_discards(self):
    """
    Getter method for in_discards, mapped from YANG variable /interfaces/interface/statistics/in_discards (yang:counter32)

    YANG Description: The number of inbound packets that were chosen to be
discarded even though no errors had been detected to
prevent their being deliverable to a higher-layer
protocol.  One possible reason for discarding such a
packet could be to free up buffer space.

Discontinuities in the value of this counter can occur
at re-initialization of the management system, and at
other times as indicated by the value of
'discontinuity-time'.
    """
    return self.__in_discards
      
  def _set_in_discards(self, v, load=False):
    """
    Setter method for in_discards, mapped from YANG variable /interfaces/interface/statistics/in_discards (yang:counter32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_discards is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_discards() directly.

    YANG Description: The number of inbound packets that were chosen to be
discarded even though no errors had been detected to
prevent their being deliverable to a higher-layer
protocol.  One possible reason for discarding such a
packet could be to free up buffer space.

Discontinuities in the value of this counter can occur
at re-initialization of the management system, and at
other times as indicated by the value of
'discontinuity-time'.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="in-discards", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_discards must be of a type compatible with yang:counter32""",
          'defined-type': "yang:counter32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="in-discards", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter32', is_config=False)""",
        })

    self.__in_discards = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_discards(self):
    self.__in_discards = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="in-discards", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter32', is_config=False)


  def _get_in_errors(self):
    """
    Getter method for in_errors, mapped from YANG variable /interfaces/interface/statistics/in_errors (yang:counter32)

    YANG Description: For packet-oriented interfaces, the number of inbound
packets that contained errors preventing them from being
deliverable to a higher-layer protocol.  For character-
oriented or fixed-length interfaces, the number of
inbound transmission units that contained errors
preventing them from being deliverable to a higher-layer
protocol.

Discontinuities in the value of this counter can occur
at re-initialization of the management system, and at
other times as indicated by the value of
'discontinuity-time'.
    """
    return self.__in_errors
      
  def _set_in_errors(self, v, load=False):
    """
    Setter method for in_errors, mapped from YANG variable /interfaces/interface/statistics/in_errors (yang:counter32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_errors is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_errors() directly.

    YANG Description: For packet-oriented interfaces, the number of inbound
packets that contained errors preventing them from being
deliverable to a higher-layer protocol.  For character-
oriented or fixed-length interfaces, the number of
inbound transmission units that contained errors
preventing them from being deliverable to a higher-layer
protocol.

Discontinuities in the value of this counter can occur
at re-initialization of the management system, and at
other times as indicated by the value of
'discontinuity-time'.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="in-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_errors must be of a type compatible with yang:counter32""",
          'defined-type': "yang:counter32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="in-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter32', is_config=False)""",
        })

    self.__in_errors = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_errors(self):
    self.__in_errors = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="in-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter32', is_config=False)


  def _get_in_unknown_protos(self):
    """
    Getter method for in_unknown_protos, mapped from YANG variable /interfaces/interface/statistics/in_unknown_protos (yang:counter32)

    YANG Description: For packet-oriented interfaces, the number of packets
received via the interface that were discarded because
of an unknown or unsupported protocol.  For
character-oriented or fixed-length interfaces that
support protocol multiplexing, the number of
transmission units received via the interface that were
discarded because of an unknown or unsupported protocol.
For any interface that does not support protocol
multiplexing, this counter is not present.

Discontinuities in the value of this counter can occur
at re-initialization of the management system, and at
other times as indicated by the value of
'discontinuity-time'.
    """
    return self.__in_unknown_protos
      
  def _set_in_unknown_protos(self, v, load=False):
    """
    Setter method for in_unknown_protos, mapped from YANG variable /interfaces/interface/statistics/in_unknown_protos (yang:counter32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_unknown_protos is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_unknown_protos() directly.

    YANG Description: For packet-oriented interfaces, the number of packets
received via the interface that were discarded because
of an unknown or unsupported protocol.  For
character-oriented or fixed-length interfaces that
support protocol multiplexing, the number of
transmission units received via the interface that were
discarded because of an unknown or unsupported protocol.
For any interface that does not support protocol
multiplexing, this counter is not present.

Discontinuities in the value of this counter can occur
at re-initialization of the management system, and at
other times as indicated by the value of
'discontinuity-time'.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="in-unknown-protos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_unknown_protos must be of a type compatible with yang:counter32""",
          'defined-type': "yang:counter32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="in-unknown-protos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter32', is_config=False)""",
        })

    self.__in_unknown_protos = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_unknown_protos(self):
    self.__in_unknown_protos = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="in-unknown-protos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter32', is_config=False)


  def _get_out_octets(self):
    """
    Getter method for out_octets, mapped from YANG variable /interfaces/interface/statistics/out_octets (yang:counter64)

    YANG Description: The total number of octets transmitted out of the
interface, including framing characters.

Discontinuities in the value of this counter can occur
at re-initialization of the management system, and at
other times as indicated by the value of
'discontinuity-time'.
    """
    return self.__out_octets
      
  def _set_out_octets(self, v, load=False):
    """
    Setter method for out_octets, mapped from YANG variable /interfaces/interface/statistics/out_octets (yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_octets is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_octets() directly.

    YANG Description: The total number of octets transmitted out of the
interface, including framing characters.

Discontinuities in the value of this counter can occur
at re-initialization of the management system, and at
other times as indicated by the value of
'discontinuity-time'.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_octets must be of a type compatible with yang:counter64""",
          'defined-type': "yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)""",
        })

    self.__out_octets = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_octets(self):
    self.__out_octets = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)


  def _get_out_unicast_pkts(self):
    """
    Getter method for out_unicast_pkts, mapped from YANG variable /interfaces/interface/statistics/out_unicast_pkts (yang:counter64)

    YANG Description: The total number of packets that higher-level protocols
requested be transmitted, and that were not addressed
to a multicast or broadcast address at this sub-layer,
including those that were discarded or not sent.

Discontinuities in the value of this counter can occur
at re-initialization of the management system, and at
other times as indicated by the value of
'discontinuity-time'.
    """
    return self.__out_unicast_pkts
      
  def _set_out_unicast_pkts(self, v, load=False):
    """
    Setter method for out_unicast_pkts, mapped from YANG variable /interfaces/interface/statistics/out_unicast_pkts (yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_unicast_pkts is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_unicast_pkts() directly.

    YANG Description: The total number of packets that higher-level protocols
requested be transmitted, and that were not addressed
to a multicast or broadcast address at this sub-layer,
including those that were discarded or not sent.

Discontinuities in the value of this counter can occur
at re-initialization of the management system, and at
other times as indicated by the value of
'discontinuity-time'.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-unicast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_unicast_pkts must be of a type compatible with yang:counter64""",
          'defined-type': "yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-unicast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)""",
        })

    self.__out_unicast_pkts = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_unicast_pkts(self):
    self.__out_unicast_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-unicast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)


  def _get_out_broadcast_pkts(self):
    """
    Getter method for out_broadcast_pkts, mapped from YANG variable /interfaces/interface/statistics/out_broadcast_pkts (yang:counter64)

    YANG Description: The total number of packets that higher-level protocols
requested be transmitted, and that were addressed to a
broadcast address at this sub-layer, including those
that were discarded or not sent.

Discontinuities in the value of this counter can occur
at re-initialization of the management system, and at
other times as indicated by the value of
'discontinuity-time'.
    """
    return self.__out_broadcast_pkts
      
  def _set_out_broadcast_pkts(self, v, load=False):
    """
    Setter method for out_broadcast_pkts, mapped from YANG variable /interfaces/interface/statistics/out_broadcast_pkts (yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_broadcast_pkts is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_broadcast_pkts() directly.

    YANG Description: The total number of packets that higher-level protocols
requested be transmitted, and that were addressed to a
broadcast address at this sub-layer, including those
that were discarded or not sent.

Discontinuities in the value of this counter can occur
at re-initialization of the management system, and at
other times as indicated by the value of
'discontinuity-time'.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-broadcast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_broadcast_pkts must be of a type compatible with yang:counter64""",
          'defined-type': "yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-broadcast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)""",
        })

    self.__out_broadcast_pkts = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_broadcast_pkts(self):
    self.__out_broadcast_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-broadcast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)


  def _get_out_multicast_pkts(self):
    """
    Getter method for out_multicast_pkts, mapped from YANG variable /interfaces/interface/statistics/out_multicast_pkts (yang:counter64)

    YANG Description: The total number of packets that higher-level protocols
requested be transmitted, and that were addressed to a
multicast address at this sub-layer, including those
that were discarded or not sent.  For a MAC-layer
protocol, this includes both Group and Functional
addresses.

Discontinuities in the value of this counter can occur
at re-initialization of the management system, and at
other times as indicated by the value of
'discontinuity-time'.
    """
    return self.__out_multicast_pkts
      
  def _set_out_multicast_pkts(self, v, load=False):
    """
    Setter method for out_multicast_pkts, mapped from YANG variable /interfaces/interface/statistics/out_multicast_pkts (yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_multicast_pkts is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_multicast_pkts() directly.

    YANG Description: The total number of packets that higher-level protocols
requested be transmitted, and that were addressed to a
multicast address at this sub-layer, including those
that were discarded or not sent.  For a MAC-layer
protocol, this includes both Group and Functional
addresses.

Discontinuities in the value of this counter can occur
at re-initialization of the management system, and at
other times as indicated by the value of
'discontinuity-time'.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-multicast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_multicast_pkts must be of a type compatible with yang:counter64""",
          'defined-type': "yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-multicast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)""",
        })

    self.__out_multicast_pkts = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_multicast_pkts(self):
    self.__out_multicast_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-multicast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)


  def _get_out_discards(self):
    """
    Getter method for out_discards, mapped from YANG variable /interfaces/interface/statistics/out_discards (yang:counter32)

    YANG Description: The number of outbound packets that were chosen to be
discarded even though no errors had been detected to
prevent their being transmitted.  One possible reason
for discarding such a packet could be to free up buffer
space.

Discontinuities in the value of this counter can occur
at re-initialization of the management system, and at
other times as indicated by the value of
'discontinuity-time'.
    """
    return self.__out_discards
      
  def _set_out_discards(self, v, load=False):
    """
    Setter method for out_discards, mapped from YANG variable /interfaces/interface/statistics/out_discards (yang:counter32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_discards is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_discards() directly.

    YANG Description: The number of outbound packets that were chosen to be
discarded even though no errors had been detected to
prevent their being transmitted.  One possible reason
for discarding such a packet could be to free up buffer
space.

Discontinuities in the value of this counter can occur
at re-initialization of the management system, and at
other times as indicated by the value of
'discontinuity-time'.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="out-discards", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_discards must be of a type compatible with yang:counter32""",
          'defined-type': "yang:counter32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="out-discards", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter32', is_config=False)""",
        })

    self.__out_discards = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_discards(self):
    self.__out_discards = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="out-discards", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter32', is_config=False)


  def _get_out_errors(self):
    """
    Getter method for out_errors, mapped from YANG variable /interfaces/interface/statistics/out_errors (yang:counter32)

    YANG Description: For packet-oriented interfaces, the number of outbound
packets that could not be transmitted because of errors.
For character-oriented or fixed-length interfaces, the
number of outbound transmission units that could not be
transmitted because of errors.

Discontinuities in the value of this counter can occur
at re-initialization of the management system, and at
other times as indicated by the value of
'discontinuity-time'.
    """
    return self.__out_errors
      
  def _set_out_errors(self, v, load=False):
    """
    Setter method for out_errors, mapped from YANG variable /interfaces/interface/statistics/out_errors (yang:counter32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_errors is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_errors() directly.

    YANG Description: For packet-oriented interfaces, the number of outbound
packets that could not be transmitted because of errors.
For character-oriented or fixed-length interfaces, the
number of outbound transmission units that could not be
transmitted because of errors.

Discontinuities in the value of this counter can occur
at re-initialization of the management system, and at
other times as indicated by the value of
'discontinuity-time'.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="out-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_errors must be of a type compatible with yang:counter32""",
          'defined-type': "yang:counter32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="out-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter32', is_config=False)""",
        })

    self.__out_errors = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_errors(self):
    self.__out_errors = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="out-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter32', is_config=False)

  discontinuity_time = __builtin__.property(_get_discontinuity_time)
  in_octets = __builtin__.property(_get_in_octets)
  in_unicast_pkts = __builtin__.property(_get_in_unicast_pkts)
  in_broadcast_pkts = __builtin__.property(_get_in_broadcast_pkts)
  in_multicast_pkts = __builtin__.property(_get_in_multicast_pkts)
  in_discards = __builtin__.property(_get_in_discards)
  in_errors = __builtin__.property(_get_in_errors)
  in_unknown_protos = __builtin__.property(_get_in_unknown_protos)
  out_octets = __builtin__.property(_get_out_octets)
  out_unicast_pkts = __builtin__.property(_get_out_unicast_pkts)
  out_broadcast_pkts = __builtin__.property(_get_out_broadcast_pkts)
  out_multicast_pkts = __builtin__.property(_get_out_multicast_pkts)
  out_discards = __builtin__.property(_get_out_discards)
  out_errors = __builtin__.property(_get_out_errors)


  _pyangbind_elements = OrderedDict([('discontinuity_time', discontinuity_time), ('in_octets', in_octets), ('in_unicast_pkts', in_unicast_pkts), ('in_broadcast_pkts', in_broadcast_pkts), ('in_multicast_pkts', in_multicast_pkts), ('in_discards', in_discards), ('in_errors', in_errors), ('in_unknown_protos', in_unknown_protos), ('out_octets', out_octets), ('out_unicast_pkts', out_unicast_pkts), ('out_broadcast_pkts', out_broadcast_pkts), ('out_multicast_pkts', out_multicast_pkts), ('out_discards', out_discards), ('out_errors', out_errors), ])


class yc_address_ietf_interfaces__interfaces_interface_ipv4_address(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-interfaces - based on the path /interfaces/interface/ipv4/address. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The list of IPv4 addresses on the interface.
  """
  __slots__ = ('_path_helper', '_extmethods', '__ip','__prefix_length','__netmask','__origin',)

  _yang_name = 'address'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ip = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='inet:ipv4-address-no-zone', is_config=True)
    self.__prefix_length = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..32']}), is_leaf=True, yang_name="prefix-length", parent=self, choice=('subnet', 'prefix-length'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='uint8', is_config=True)
    self.__netmask = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'}), is_leaf=True, yang_name="netmask", parent=self, choice=('subnet', 'netmask'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='yang:dotted-quad', is_config=True)
    self.__origin = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'other': {}, 'static': {}, 'dhcp': {}, 'link-layer': {}, 'random': {}},), is_leaf=True, yang_name="origin", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='ip-address-origin', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'ipv4', 'address']

  def _get_ip(self):
    """
    Getter method for ip, mapped from YANG variable /interfaces/interface/ipv4/address/ip (inet:ipv4-address-no-zone)

    YANG Description: The IPv4 address on the interface.
    """
    return self.__ip
      
  def _set_ip(self, v, load=False):
    """
    Setter method for ip, mapped from YANG variable /interfaces/interface/ipv4/address/ip (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip() directly.

    YANG Description: The IPv4 address on the interface.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='inet:ipv4-address-no-zone', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='inet:ipv4-address-no-zone', is_config=True)""",
        })

    self.__ip = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip(self):
    self.__ip = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='inet:ipv4-address-no-zone', is_config=True)


  def _get_prefix_length(self):
    """
    Getter method for prefix_length, mapped from YANG variable /interfaces/interface/ipv4/address/prefix_length (uint8)

    YANG Description: The length of the subnet prefix.
    """
    return self.__prefix_length
      
  def _set_prefix_length(self, v, load=False):
    """
    Setter method for prefix_length, mapped from YANG variable /interfaces/interface/ipv4/address/prefix_length (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prefix_length is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prefix_length() directly.

    YANG Description: The length of the subnet prefix.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..32']}), is_leaf=True, yang_name="prefix-length", parent=self, choice=('subnet', 'prefix-length'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prefix_length must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..32']}), is_leaf=True, yang_name="prefix-length", parent=self, choice=('subnet', 'prefix-length'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='uint8', is_config=True)""",
        })

    self.__prefix_length = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prefix_length(self):
    self.__prefix_length = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..32']}), is_leaf=True, yang_name="prefix-length", parent=self, choice=('subnet', 'prefix-length'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='uint8', is_config=True)


  def _get_netmask(self):
    """
    Getter method for netmask, mapped from YANG variable /interfaces/interface/ipv4/address/netmask (yang:dotted-quad)

    YANG Description: The subnet specified as a netmask.
    """
    return self.__netmask
      
  def _set_netmask(self, v, load=False):
    """
    Setter method for netmask, mapped from YANG variable /interfaces/interface/ipv4/address/netmask (yang:dotted-quad)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_netmask is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_netmask() directly.

    YANG Description: The subnet specified as a netmask.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'}), is_leaf=True, yang_name="netmask", parent=self, choice=('subnet', 'netmask'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='yang:dotted-quad', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """netmask must be of a type compatible with yang:dotted-quad""",
          'defined-type': "yang:dotted-quad",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'}), is_leaf=True, yang_name="netmask", parent=self, choice=('subnet', 'netmask'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='yang:dotted-quad', is_config=True)""",
        })

    self.__netmask = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_netmask(self):
    self.__netmask = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'}), is_leaf=True, yang_name="netmask", parent=self, choice=('subnet', 'netmask'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='yang:dotted-quad', is_config=True)


  def _get_origin(self):
    """
    Getter method for origin, mapped from YANG variable /interfaces/interface/ipv4/address/origin (ip-address-origin)

    YANG Description: The origin of this address.
    """
    return self.__origin
      
  def _set_origin(self, v, load=False):
    """
    Setter method for origin, mapped from YANG variable /interfaces/interface/ipv4/address/origin (ip-address-origin)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_origin is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_origin() directly.

    YANG Description: The origin of this address.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'other': {}, 'static': {}, 'dhcp': {}, 'link-layer': {}, 'random': {}},), is_leaf=True, yang_name="origin", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='ip-address-origin', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """origin must be of a type compatible with ip-address-origin""",
          'defined-type': "ietf-ip:ip-address-origin",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'other': {}, 'static': {}, 'dhcp': {}, 'link-layer': {}, 'random': {}},), is_leaf=True, yang_name="origin", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='ip-address-origin', is_config=False)""",
        })

    self.__origin = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_origin(self):
    self.__origin = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'other': {}, 'static': {}, 'dhcp': {}, 'link-layer': {}, 'random': {}},), is_leaf=True, yang_name="origin", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='ip-address-origin', is_config=False)

  ip = __builtin__.property(_get_ip, _set_ip)
  prefix_length = __builtin__.property(_get_prefix_length, _set_prefix_length)
  netmask = __builtin__.property(_get_netmask, _set_netmask)
  origin = __builtin__.property(_get_origin)

  __choices__ = {'subnet': {'prefix-length': ['prefix_length'], 'netmask': ['netmask']}}
  _pyangbind_elements = OrderedDict([('ip', ip), ('prefix_length', prefix_length), ('netmask', netmask), ('origin', origin), ])


class yc_neighbor_ietf_interfaces__interfaces_interface_ipv4_neighbor(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-interfaces - based on the path /interfaces/interface/ipv4/neighbor. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: A list of mappings from IPv4 addresses to
link-layer addresses.

Entries in this list in the intended configuration are
used as static entries in the ARP Cache.

In the operational state, this list represents the ARP
Cache.
  """
  __slots__ = ('_path_helper', '_extmethods', '__ip','__link_layer_address','__origin',)

  _yang_name = 'neighbor'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ip = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='inet:ipv4-address-no-zone', is_config=True)
    self.__link_layer_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9a-fA-F]{2}(:[0-9a-fA-F]{2})*)?'}), is_leaf=True, yang_name="link-layer-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='yang:phys-address', is_config=True)
    self.__origin = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'other': {}, 'static': {}, 'dynamic': {}},), is_leaf=True, yang_name="origin", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='neighbor-origin', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'ipv4', 'neighbor']

  def _get_ip(self):
    """
    Getter method for ip, mapped from YANG variable /interfaces/interface/ipv4/neighbor/ip (inet:ipv4-address-no-zone)

    YANG Description: The IPv4 address of the neighbor node.
    """
    return self.__ip
      
  def _set_ip(self, v, load=False):
    """
    Setter method for ip, mapped from YANG variable /interfaces/interface/ipv4/neighbor/ip (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip() directly.

    YANG Description: The IPv4 address of the neighbor node.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='inet:ipv4-address-no-zone', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='inet:ipv4-address-no-zone', is_config=True)""",
        })

    self.__ip = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip(self):
    self.__ip = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='inet:ipv4-address-no-zone', is_config=True)


  def _get_link_layer_address(self):
    """
    Getter method for link_layer_address, mapped from YANG variable /interfaces/interface/ipv4/neighbor/link_layer_address (yang:phys-address)

    YANG Description: The link-layer address of the neighbor node.
    """
    return self.__link_layer_address
      
  def _set_link_layer_address(self, v, load=False):
    """
    Setter method for link_layer_address, mapped from YANG variable /interfaces/interface/ipv4/neighbor/link_layer_address (yang:phys-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_link_layer_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_link_layer_address() directly.

    YANG Description: The link-layer address of the neighbor node.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9a-fA-F]{2}(:[0-9a-fA-F]{2})*)?'}), is_leaf=True, yang_name="link-layer-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='yang:phys-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """link_layer_address must be of a type compatible with yang:phys-address""",
          'defined-type': "yang:phys-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9a-fA-F]{2}(:[0-9a-fA-F]{2})*)?'}), is_leaf=True, yang_name="link-layer-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='yang:phys-address', is_config=True)""",
        })

    self.__link_layer_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_link_layer_address(self):
    self.__link_layer_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9a-fA-F]{2}(:[0-9a-fA-F]{2})*)?'}), is_leaf=True, yang_name="link-layer-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='yang:phys-address', is_config=True)


  def _get_origin(self):
    """
    Getter method for origin, mapped from YANG variable /interfaces/interface/ipv4/neighbor/origin (neighbor-origin)

    YANG Description: The origin of this neighbor entry.
    """
    return self.__origin
      
  def _set_origin(self, v, load=False):
    """
    Setter method for origin, mapped from YANG variable /interfaces/interface/ipv4/neighbor/origin (neighbor-origin)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_origin is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_origin() directly.

    YANG Description: The origin of this neighbor entry.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'other': {}, 'static': {}, 'dynamic': {}},), is_leaf=True, yang_name="origin", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='neighbor-origin', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """origin must be of a type compatible with neighbor-origin""",
          'defined-type': "ietf-ip:neighbor-origin",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'other': {}, 'static': {}, 'dynamic': {}},), is_leaf=True, yang_name="origin", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='neighbor-origin', is_config=False)""",
        })

    self.__origin = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_origin(self):
    self.__origin = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'other': {}, 'static': {}, 'dynamic': {}},), is_leaf=True, yang_name="origin", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='neighbor-origin', is_config=False)

  ip = __builtin__.property(_get_ip, _set_ip)
  link_layer_address = __builtin__.property(_get_link_layer_address, _set_link_layer_address)
  origin = __builtin__.property(_get_origin)


  _pyangbind_elements = OrderedDict([('ip', ip), ('link_layer_address', link_layer_address), ('origin', origin), ])


class yc_ipv4_ietf_interfaces__interfaces_interface_ipv4(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-interfaces - based on the path /interfaces/interface/ipv4. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Parameters for the IPv4 address family.
  """
  __slots__ = ('_path_helper', '_extmethods', '__enabled','__forwarding','__mtu','__address','__neighbor','__bind_ni_name',)

  _yang_name = 'ipv4'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='boolean', is_config=True)
    self.__forwarding = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="forwarding", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='boolean', is_config=True)
    self.__mtu = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['68..max']}), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='uint16', is_config=True)
    self.__address = YANGDynClass(base=YANGListType("ip",yc_address_ietf_interfaces__interfaces_interface_ipv4_address, yang_name="address", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip', extensions=None), is_container='list', yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='list', is_config=True)
    self.__neighbor = YANGDynClass(base=YANGListType("ip",yc_neighbor_ietf_interfaces__interfaces_interface_ipv4_neighbor, yang_name="neighbor", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip', extensions=None), is_container='list', yang_name="neighbor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='list', is_config=True)
    self.__bind_ni_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="bind-ni-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network-instance', defining_module='ietf-network-instance', yang_type='leafref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'ipv4']

  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /interfaces/interface/ipv4/enabled (boolean)

    YANG Description: Controls whether IPv4 is enabled or disabled on this
interface.  When IPv4 is enabled, this interface is
connected to an IPv4 stack, and the interface can send
and receive IPv4 packets.
    """
    return self.__enabled
      
  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /interfaces/interface/ipv4/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: Controls whether IPv4 is enabled or disabled on this
interface.  When IPv4 is enabled, this interface is
connected to an IPv4 stack, and the interface can send
and receive IPv4 packets.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='boolean', is_config=True)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='boolean', is_config=True)


  def _get_forwarding(self):
    """
    Getter method for forwarding, mapped from YANG variable /interfaces/interface/ipv4/forwarding (boolean)

    YANG Description: Controls IPv4 packet forwarding of datagrams received by,
but not addressed to, this interface.  IPv4 routers
forward datagrams.  IPv4 hosts do not (except those
source-routed via the host).
    """
    return self.__forwarding
      
  def _set_forwarding(self, v, load=False):
    """
    Setter method for forwarding, mapped from YANG variable /interfaces/interface/ipv4/forwarding (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_forwarding is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_forwarding() directly.

    YANG Description: Controls IPv4 packet forwarding of datagrams received by,
but not addressed to, this interface.  IPv4 routers
forward datagrams.  IPv4 hosts do not (except those
source-routed via the host).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="forwarding", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """forwarding must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="forwarding", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='boolean', is_config=True)""",
        })

    self.__forwarding = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_forwarding(self):
    self.__forwarding = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="forwarding", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='boolean', is_config=True)


  def _get_mtu(self):
    """
    Getter method for mtu, mapped from YANG variable /interfaces/interface/ipv4/mtu (uint16)

    YANG Description: The size, in octets, of the largest IPv4 packet that the
interface will send and receive.

The server may restrict the allowed values for this leaf,
depending on the interface's type.

If this leaf is not configured, the operationally used MTU
depends on the interface's type.
    """
    return self.__mtu
      
  def _set_mtu(self, v, load=False):
    """
    Setter method for mtu, mapped from YANG variable /interfaces/interface/ipv4/mtu (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mtu is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mtu() directly.

    YANG Description: The size, in octets, of the largest IPv4 packet that the
interface will send and receive.

The server may restrict the allowed values for this leaf,
depending on the interface's type.

If this leaf is not configured, the operationally used MTU
depends on the interface's type.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['68..max']}), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mtu must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['68..max']}), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='uint16', is_config=True)""",
        })

    self.__mtu = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mtu(self):
    self.__mtu = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['68..max']}), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='uint16', is_config=True)


  def _get_address(self):
    """
    Getter method for address, mapped from YANG variable /interfaces/interface/ipv4/address (list)

    YANG Description: The list of IPv4 addresses on the interface.
    """
    return self.__address
      
  def _set_address(self, v, load=False):
    """
    Setter method for address, mapped from YANG variable /interfaces/interface/ipv4/address (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_address() directly.

    YANG Description: The list of IPv4 addresses on the interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("ip",yc_address_ietf_interfaces__interfaces_interface_ipv4_address, yang_name="address", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip', extensions=None), is_container='list', yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """address must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("ip",yc_address_ietf_interfaces__interfaces_interface_ipv4_address, yang_name="address", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip', extensions=None), is_container='list', yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='list', is_config=True)""",
        })

    self.__address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_address(self):
    self.__address = YANGDynClass(base=YANGListType("ip",yc_address_ietf_interfaces__interfaces_interface_ipv4_address, yang_name="address", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip', extensions=None), is_container='list', yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='list', is_config=True)


  def _get_neighbor(self):
    """
    Getter method for neighbor, mapped from YANG variable /interfaces/interface/ipv4/neighbor (list)

    YANG Description: A list of mappings from IPv4 addresses to
link-layer addresses.

Entries in this list in the intended configuration are
used as static entries in the ARP Cache.

In the operational state, this list represents the ARP
Cache.
    """
    return self.__neighbor
      
  def _set_neighbor(self, v, load=False):
    """
    Setter method for neighbor, mapped from YANG variable /interfaces/interface/ipv4/neighbor (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_neighbor is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_neighbor() directly.

    YANG Description: A list of mappings from IPv4 addresses to
link-layer addresses.

Entries in this list in the intended configuration are
used as static entries in the ARP Cache.

In the operational state, this list represents the ARP
Cache.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("ip",yc_neighbor_ietf_interfaces__interfaces_interface_ipv4_neighbor, yang_name="neighbor", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip', extensions=None), is_container='list', yang_name="neighbor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """neighbor must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("ip",yc_neighbor_ietf_interfaces__interfaces_interface_ipv4_neighbor, yang_name="neighbor", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip', extensions=None), is_container='list', yang_name="neighbor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='list', is_config=True)""",
        })

    self.__neighbor = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_neighbor(self):
    self.__neighbor = YANGDynClass(base=YANGListType("ip",yc_neighbor_ietf_interfaces__interfaces_interface_ipv4_neighbor, yang_name="neighbor", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip', extensions=None), is_container='list', yang_name="neighbor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='list', is_config=True)


  def _get_bind_ni_name(self):
    """
    Getter method for bind_ni_name, mapped from YANG variable /interfaces/interface/ipv4/bind_ni_name (leafref)

    YANG Description: Network Instance to which IPv4 interface is bound.
    """
    return self.__bind_ni_name
      
  def _set_bind_ni_name(self, v, load=False):
    """
    Setter method for bind_ni_name, mapped from YANG variable /interfaces/interface/ipv4/bind_ni_name (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bind_ni_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bind_ni_name() directly.

    YANG Description: Network Instance to which IPv4 interface is bound.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="bind-ni-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network-instance', defining_module='ietf-network-instance', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bind_ni_name must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="bind-ni-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network-instance', defining_module='ietf-network-instance', yang_type='leafref', is_config=True)""",
        })

    self.__bind_ni_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bind_ni_name(self):
    self.__bind_ni_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="bind-ni-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network-instance', defining_module='ietf-network-instance', yang_type='leafref', is_config=True)

  enabled = __builtin__.property(_get_enabled, _set_enabled)
  forwarding = __builtin__.property(_get_forwarding, _set_forwarding)
  mtu = __builtin__.property(_get_mtu, _set_mtu)
  address = __builtin__.property(_get_address, _set_address) # type: yc_address_ietf_interfaces__interfaces_interface_ipv4_address
  neighbor = __builtin__.property(_get_neighbor, _set_neighbor) # type: yc_neighbor_ietf_interfaces__interfaces_interface_ipv4_neighbor
  bind_ni_name = __builtin__.property(_get_bind_ni_name, _set_bind_ni_name)


  _pyangbind_elements = OrderedDict([('enabled', enabled), ('forwarding', forwarding), ('mtu', mtu), ('address', address), ('neighbor', neighbor), ('bind_ni_name', bind_ni_name), ])


class yc_address_ietf_interfaces__interfaces_interface_ipv6_address(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-interfaces - based on the path /interfaces/interface/ipv6/address. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The list of IPv6 addresses on the interface.
  """
  __slots__ = ('_path_helper', '_extmethods', '__ip','__prefix_length','__origin','__status',)

  _yang_name = 'address'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ip = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='inet:ipv6-address-no-zone', is_config=True)
    self.__prefix_length = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..128']}), is_leaf=True, yang_name="prefix-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='uint8', is_config=True)
    self.__origin = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'other': {}, 'static': {}, 'dhcp': {}, 'link-layer': {}, 'random': {}},), is_leaf=True, yang_name="origin", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='ip-address-origin', is_config=False)
    self.__status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'preferred': {}, 'deprecated': {}, 'invalid': {}, 'inaccessible': {}, 'unknown': {}, 'tentative': {}, 'duplicate': {}, 'optimistic': {}},), is_leaf=True, yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='enumeration', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'ipv6', 'address']

  def _get_ip(self):
    """
    Getter method for ip, mapped from YANG variable /interfaces/interface/ipv6/address/ip (inet:ipv6-address-no-zone)

    YANG Description: The IPv6 address on the interface.
    """
    return self.__ip
      
  def _set_ip(self, v, load=False):
    """
    Setter method for ip, mapped from YANG variable /interfaces/interface/ipv6/address/ip (inet:ipv6-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip() directly.

    YANG Description: The IPv6 address on the interface.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='inet:ipv6-address-no-zone', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip must be of a type compatible with inet:ipv6-address-no-zone""",
          'defined-type': "inet:ipv6-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='inet:ipv6-address-no-zone', is_config=True)""",
        })

    self.__ip = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip(self):
    self.__ip = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='inet:ipv6-address-no-zone', is_config=True)


  def _get_prefix_length(self):
    """
    Getter method for prefix_length, mapped from YANG variable /interfaces/interface/ipv6/address/prefix_length (uint8)

    YANG Description: The length of the subnet prefix.
    """
    return self.__prefix_length
      
  def _set_prefix_length(self, v, load=False):
    """
    Setter method for prefix_length, mapped from YANG variable /interfaces/interface/ipv6/address/prefix_length (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prefix_length is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prefix_length() directly.

    YANG Description: The length of the subnet prefix.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..128']}), is_leaf=True, yang_name="prefix-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prefix_length must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..128']}), is_leaf=True, yang_name="prefix-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='uint8', is_config=True)""",
        })

    self.__prefix_length = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prefix_length(self):
    self.__prefix_length = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..128']}), is_leaf=True, yang_name="prefix-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='uint8', is_config=True)


  def _get_origin(self):
    """
    Getter method for origin, mapped from YANG variable /interfaces/interface/ipv6/address/origin (ip-address-origin)

    YANG Description: The origin of this address.
    """
    return self.__origin
      
  def _set_origin(self, v, load=False):
    """
    Setter method for origin, mapped from YANG variable /interfaces/interface/ipv6/address/origin (ip-address-origin)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_origin is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_origin() directly.

    YANG Description: The origin of this address.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'other': {}, 'static': {}, 'dhcp': {}, 'link-layer': {}, 'random': {}},), is_leaf=True, yang_name="origin", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='ip-address-origin', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """origin must be of a type compatible with ip-address-origin""",
          'defined-type': "ietf-ip:ip-address-origin",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'other': {}, 'static': {}, 'dhcp': {}, 'link-layer': {}, 'random': {}},), is_leaf=True, yang_name="origin", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='ip-address-origin', is_config=False)""",
        })

    self.__origin = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_origin(self):
    self.__origin = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'other': {}, 'static': {}, 'dhcp': {}, 'link-layer': {}, 'random': {}},), is_leaf=True, yang_name="origin", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='ip-address-origin', is_config=False)


  def _get_status(self):
    """
    Getter method for status, mapped from YANG variable /interfaces/interface/ipv6/address/status (enumeration)

    YANG Description: The status of an address.  Most of the states correspond
to states from the IPv6 Stateless Address
Autoconfiguration protocol.
    """
    return self.__status
      
  def _set_status(self, v, load=False):
    """
    Setter method for status, mapped from YANG variable /interfaces/interface/ipv6/address/status (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_status() directly.

    YANG Description: The status of an address.  Most of the states correspond
to states from the IPv6 Stateless Address
Autoconfiguration protocol.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'preferred': {}, 'deprecated': {}, 'invalid': {}, 'inaccessible': {}, 'unknown': {}, 'tentative': {}, 'duplicate': {}, 'optimistic': {}},), is_leaf=True, yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='enumeration', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """status must be of a type compatible with enumeration""",
          'defined-type': "ietf-ip:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'preferred': {}, 'deprecated': {}, 'invalid': {}, 'inaccessible': {}, 'unknown': {}, 'tentative': {}, 'duplicate': {}, 'optimistic': {}},), is_leaf=True, yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='enumeration', is_config=False)""",
        })

    self.__status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_status(self):
    self.__status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'preferred': {}, 'deprecated': {}, 'invalid': {}, 'inaccessible': {}, 'unknown': {}, 'tentative': {}, 'duplicate': {}, 'optimistic': {}},), is_leaf=True, yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='enumeration', is_config=False)

  ip = __builtin__.property(_get_ip, _set_ip)
  prefix_length = __builtin__.property(_get_prefix_length, _set_prefix_length)
  origin = __builtin__.property(_get_origin)
  status = __builtin__.property(_get_status)


  _pyangbind_elements = OrderedDict([('ip', ip), ('prefix_length', prefix_length), ('origin', origin), ('status', status), ])


class yc_neighbor_ietf_interfaces__interfaces_interface_ipv6_neighbor(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-interfaces - based on the path /interfaces/interface/ipv6/neighbor. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: A list of mappings from IPv6 addresses to
link-layer addresses.

Entries in this list in the intended configuration are
used as static entries in the Neighbor Cache.

In the operational state, this list represents the
Neighbor Cache.
  """
  __slots__ = ('_path_helper', '_extmethods', '__ip','__link_layer_address','__origin','__is_router','__state',)

  _yang_name = 'neighbor'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ip = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='inet:ipv6-address-no-zone', is_config=True)
    self.__link_layer_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9a-fA-F]{2}(:[0-9a-fA-F]{2})*)?'}), is_leaf=True, yang_name="link-layer-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='yang:phys-address', is_config=True)
    self.__origin = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'other': {}, 'static': {}, 'dynamic': {}},), is_leaf=True, yang_name="origin", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='neighbor-origin', is_config=False)
    self.__is_router = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is-router", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='empty', is_config=False)
    self.__state = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'incomplete': {}, 'reachable': {}, 'stale': {}, 'delay': {}, 'probe': {}},), is_leaf=True, yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='enumeration', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'ipv6', 'neighbor']

  def _get_ip(self):
    """
    Getter method for ip, mapped from YANG variable /interfaces/interface/ipv6/neighbor/ip (inet:ipv6-address-no-zone)

    YANG Description: The IPv6 address of the neighbor node.
    """
    return self.__ip
      
  def _set_ip(self, v, load=False):
    """
    Setter method for ip, mapped from YANG variable /interfaces/interface/ipv6/neighbor/ip (inet:ipv6-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip() directly.

    YANG Description: The IPv6 address of the neighbor node.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='inet:ipv6-address-no-zone', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip must be of a type compatible with inet:ipv6-address-no-zone""",
          'defined-type': "inet:ipv6-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='inet:ipv6-address-no-zone', is_config=True)""",
        })

    self.__ip = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip(self):
    self.__ip = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='inet:ipv6-address-no-zone', is_config=True)


  def _get_link_layer_address(self):
    """
    Getter method for link_layer_address, mapped from YANG variable /interfaces/interface/ipv6/neighbor/link_layer_address (yang:phys-address)

    YANG Description: The link-layer address of the neighbor node.

In the operational state, if the neighbor's 'state' leaf
is 'incomplete', this leaf is not instantiated.
    """
    return self.__link_layer_address
      
  def _set_link_layer_address(self, v, load=False):
    """
    Setter method for link_layer_address, mapped from YANG variable /interfaces/interface/ipv6/neighbor/link_layer_address (yang:phys-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_link_layer_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_link_layer_address() directly.

    YANG Description: The link-layer address of the neighbor node.

In the operational state, if the neighbor's 'state' leaf
is 'incomplete', this leaf is not instantiated.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9a-fA-F]{2}(:[0-9a-fA-F]{2})*)?'}), is_leaf=True, yang_name="link-layer-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='yang:phys-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """link_layer_address must be of a type compatible with yang:phys-address""",
          'defined-type': "yang:phys-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9a-fA-F]{2}(:[0-9a-fA-F]{2})*)?'}), is_leaf=True, yang_name="link-layer-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='yang:phys-address', is_config=True)""",
        })

    self.__link_layer_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_link_layer_address(self):
    self.__link_layer_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9a-fA-F]{2}(:[0-9a-fA-F]{2})*)?'}), is_leaf=True, yang_name="link-layer-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='yang:phys-address', is_config=True)


  def _get_origin(self):
    """
    Getter method for origin, mapped from YANG variable /interfaces/interface/ipv6/neighbor/origin (neighbor-origin)

    YANG Description: The origin of this neighbor entry.
    """
    return self.__origin
      
  def _set_origin(self, v, load=False):
    """
    Setter method for origin, mapped from YANG variable /interfaces/interface/ipv6/neighbor/origin (neighbor-origin)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_origin is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_origin() directly.

    YANG Description: The origin of this neighbor entry.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'other': {}, 'static': {}, 'dynamic': {}},), is_leaf=True, yang_name="origin", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='neighbor-origin', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """origin must be of a type compatible with neighbor-origin""",
          'defined-type': "ietf-ip:neighbor-origin",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'other': {}, 'static': {}, 'dynamic': {}},), is_leaf=True, yang_name="origin", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='neighbor-origin', is_config=False)""",
        })

    self.__origin = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_origin(self):
    self.__origin = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'other': {}, 'static': {}, 'dynamic': {}},), is_leaf=True, yang_name="origin", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='neighbor-origin', is_config=False)


  def _get_is_router(self):
    """
    Getter method for is_router, mapped from YANG variable /interfaces/interface/ipv6/neighbor/is_router (empty)

    YANG Description: Indicates that the neighbor node acts as a router.
    """
    return self.__is_router
      
  def _set_is_router(self, v, load=False):
    """
    Setter method for is_router, mapped from YANG variable /interfaces/interface/ipv6/neighbor/is_router (empty)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_is_router is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_is_router() directly.

    YANG Description: Indicates that the neighbor node acts as a router.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="is-router", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='empty', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """is_router must be of a type compatible with empty""",
          'defined-type': "empty",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is-router", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='empty', is_config=False)""",
        })

    self.__is_router = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_is_router(self):
    self.__is_router = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is-router", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='empty', is_config=False)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /interfaces/interface/ipv6/neighbor/state (enumeration)

    YANG Description: The Neighbor Unreachability Detection state of this
entry.
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /interfaces/interface/ipv6/neighbor/state (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: The Neighbor Unreachability Detection state of this
entry.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'incomplete': {}, 'reachable': {}, 'stale': {}, 'delay': {}, 'probe': {}},), is_leaf=True, yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='enumeration', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with enumeration""",
          'defined-type': "ietf-ip:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'incomplete': {}, 'reachable': {}, 'stale': {}, 'delay': {}, 'probe': {}},), is_leaf=True, yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='enumeration', is_config=False)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'incomplete': {}, 'reachable': {}, 'stale': {}, 'delay': {}, 'probe': {}},), is_leaf=True, yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='enumeration', is_config=False)

  ip = __builtin__.property(_get_ip, _set_ip)
  link_layer_address = __builtin__.property(_get_link_layer_address, _set_link_layer_address)
  origin = __builtin__.property(_get_origin)
  is_router = __builtin__.property(_get_is_router)
  state = __builtin__.property(_get_state)


  _pyangbind_elements = OrderedDict([('ip', ip), ('link_layer_address', link_layer_address), ('origin', origin), ('is_router', is_router), ('state', state), ])


class yc_autoconf_ietf_interfaces__interfaces_interface_ipv6_autoconf(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-interfaces - based on the path /interfaces/interface/ipv6/autoconf. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Parameters to control the autoconfiguration of IPv6
addresses, as described in RFC 4862.
  """
  __slots__ = ('_path_helper', '_extmethods', '__create_global_addresses','__create_temporary_addresses','__temporary_valid_lifetime','__temporary_preferred_lifetime',)

  _yang_name = 'autoconf'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__create_global_addresses = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="create-global-addresses", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='boolean', is_config=True)
    self.__create_temporary_addresses = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="create-temporary-addresses", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='boolean', is_config=True)
    self.__temporary_valid_lifetime = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(604800), is_leaf=True, yang_name="temporary-valid-lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='uint32', is_config=True)
    self.__temporary_preferred_lifetime = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(86400), is_leaf=True, yang_name="temporary-preferred-lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'ipv6', 'autoconf']

  def _get_create_global_addresses(self):
    """
    Getter method for create_global_addresses, mapped from YANG variable /interfaces/interface/ipv6/autoconf/create_global_addresses (boolean)

    YANG Description: If enabled, the host creates global addresses as
described in RFC 4862.
    """
    return self.__create_global_addresses
      
  def _set_create_global_addresses(self, v, load=False):
    """
    Setter method for create_global_addresses, mapped from YANG variable /interfaces/interface/ipv6/autoconf/create_global_addresses (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_create_global_addresses is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_create_global_addresses() directly.

    YANG Description: If enabled, the host creates global addresses as
described in RFC 4862.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="create-global-addresses", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """create_global_addresses must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="create-global-addresses", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='boolean', is_config=True)""",
        })

    self.__create_global_addresses = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_create_global_addresses(self):
    self.__create_global_addresses = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="create-global-addresses", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='boolean', is_config=True)


  def _get_create_temporary_addresses(self):
    """
    Getter method for create_temporary_addresses, mapped from YANG variable /interfaces/interface/ipv6/autoconf/create_temporary_addresses (boolean)

    YANG Description: If enabled, the host creates temporary addresses as
described in RFC 4941.
    """
    return self.__create_temporary_addresses
      
  def _set_create_temporary_addresses(self, v, load=False):
    """
    Setter method for create_temporary_addresses, mapped from YANG variable /interfaces/interface/ipv6/autoconf/create_temporary_addresses (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_create_temporary_addresses is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_create_temporary_addresses() directly.

    YANG Description: If enabled, the host creates temporary addresses as
described in RFC 4941.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="create-temporary-addresses", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """create_temporary_addresses must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="create-temporary-addresses", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='boolean', is_config=True)""",
        })

    self.__create_temporary_addresses = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_create_temporary_addresses(self):
    self.__create_temporary_addresses = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="create-temporary-addresses", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='boolean', is_config=True)


  def _get_temporary_valid_lifetime(self):
    """
    Getter method for temporary_valid_lifetime, mapped from YANG variable /interfaces/interface/ipv6/autoconf/temporary_valid_lifetime (uint32)

    YANG Description: The time period during which the temporary address
is valid.
    """
    return self.__temporary_valid_lifetime
      
  def _set_temporary_valid_lifetime(self, v, load=False):
    """
    Setter method for temporary_valid_lifetime, mapped from YANG variable /interfaces/interface/ipv6/autoconf/temporary_valid_lifetime (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_temporary_valid_lifetime is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_temporary_valid_lifetime() directly.

    YANG Description: The time period during which the temporary address
is valid.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(604800), is_leaf=True, yang_name="temporary-valid-lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """temporary_valid_lifetime must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(604800), is_leaf=True, yang_name="temporary-valid-lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='uint32', is_config=True)""",
        })

    self.__temporary_valid_lifetime = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_temporary_valid_lifetime(self):
    self.__temporary_valid_lifetime = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(604800), is_leaf=True, yang_name="temporary-valid-lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='uint32', is_config=True)


  def _get_temporary_preferred_lifetime(self):
    """
    Getter method for temporary_preferred_lifetime, mapped from YANG variable /interfaces/interface/ipv6/autoconf/temporary_preferred_lifetime (uint32)

    YANG Description: The time period during which the temporary address is
preferred.
    """
    return self.__temporary_preferred_lifetime
      
  def _set_temporary_preferred_lifetime(self, v, load=False):
    """
    Setter method for temporary_preferred_lifetime, mapped from YANG variable /interfaces/interface/ipv6/autoconf/temporary_preferred_lifetime (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_temporary_preferred_lifetime is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_temporary_preferred_lifetime() directly.

    YANG Description: The time period during which the temporary address is
preferred.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(86400), is_leaf=True, yang_name="temporary-preferred-lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """temporary_preferred_lifetime must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(86400), is_leaf=True, yang_name="temporary-preferred-lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='uint32', is_config=True)""",
        })

    self.__temporary_preferred_lifetime = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_temporary_preferred_lifetime(self):
    self.__temporary_preferred_lifetime = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(86400), is_leaf=True, yang_name="temporary-preferred-lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='uint32', is_config=True)

  create_global_addresses = __builtin__.property(_get_create_global_addresses, _set_create_global_addresses)
  create_temporary_addresses = __builtin__.property(_get_create_temporary_addresses, _set_create_temporary_addresses)
  temporary_valid_lifetime = __builtin__.property(_get_temporary_valid_lifetime, _set_temporary_valid_lifetime)
  temporary_preferred_lifetime = __builtin__.property(_get_temporary_preferred_lifetime, _set_temporary_preferred_lifetime)


  _pyangbind_elements = OrderedDict([('create_global_addresses', create_global_addresses), ('create_temporary_addresses', create_temporary_addresses), ('temporary_valid_lifetime', temporary_valid_lifetime), ('temporary_preferred_lifetime', temporary_preferred_lifetime), ])


class yc_ipv6_ietf_interfaces__interfaces_interface_ipv6(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-interfaces - based on the path /interfaces/interface/ipv6. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Parameters for the IPv6 address family.
  """
  __slots__ = ('_path_helper', '_extmethods', '__enabled','__forwarding','__mtu','__address','__neighbor','__dup_addr_detect_transmits','__autoconf','__bind_ni_name',)

  _yang_name = 'ipv6'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='boolean', is_config=True)
    self.__forwarding = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="forwarding", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='boolean', is_config=True)
    self.__mtu = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1280..max']}), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='uint32', is_config=True)
    self.__address = YANGDynClass(base=YANGListType("ip",yc_address_ietf_interfaces__interfaces_interface_ipv6_address, yang_name="address", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip', extensions=None), is_container='list', yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='list', is_config=True)
    self.__neighbor = YANGDynClass(base=YANGListType("ip",yc_neighbor_ietf_interfaces__interfaces_interface_ipv6_neighbor, yang_name="neighbor", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip', extensions=None), is_container='list', yang_name="neighbor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='list', is_config=True)
    self.__dup_addr_detect_transmits = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="dup-addr-detect-transmits", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='uint32', is_config=True)
    self.__autoconf = YANGDynClass(base=yc_autoconf_ietf_interfaces__interfaces_interface_ipv6_autoconf, is_container='container', yang_name="autoconf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='container', is_config=True)
    self.__bind_ni_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="bind-ni-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network-instance', defining_module='ietf-network-instance', yang_type='leafref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'ipv6']

  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /interfaces/interface/ipv6/enabled (boolean)

    YANG Description: Controls whether IPv6 is enabled or disabled on this
interface.  When IPv6 is enabled, this interface is
connected to an IPv6 stack, and the interface can send
and receive IPv6 packets.
    """
    return self.__enabled
      
  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /interfaces/interface/ipv6/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: Controls whether IPv6 is enabled or disabled on this
interface.  When IPv6 is enabled, this interface is
connected to an IPv6 stack, and the interface can send
and receive IPv6 packets.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='boolean', is_config=True)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='boolean', is_config=True)


  def _get_forwarding(self):
    """
    Getter method for forwarding, mapped from YANG variable /interfaces/interface/ipv6/forwarding (boolean)

    YANG Description: Controls IPv6 packet forwarding of datagrams received by,
but not addressed to, this interface.  IPv6 routers
forward datagrams.  IPv6 hosts do not (except those
source-routed via the host).
    """
    return self.__forwarding
      
  def _set_forwarding(self, v, load=False):
    """
    Setter method for forwarding, mapped from YANG variable /interfaces/interface/ipv6/forwarding (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_forwarding is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_forwarding() directly.

    YANG Description: Controls IPv6 packet forwarding of datagrams received by,
but not addressed to, this interface.  IPv6 routers
forward datagrams.  IPv6 hosts do not (except those
source-routed via the host).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="forwarding", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """forwarding must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="forwarding", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='boolean', is_config=True)""",
        })

    self.__forwarding = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_forwarding(self):
    self.__forwarding = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="forwarding", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='boolean', is_config=True)


  def _get_mtu(self):
    """
    Getter method for mtu, mapped from YANG variable /interfaces/interface/ipv6/mtu (uint32)

    YANG Description: The size, in octets, of the largest IPv6 packet that the
interface will send and receive.

The server may restrict the allowed values for this leaf,
depending on the interface's type.

If this leaf is not configured, the operationally used MTU
depends on the interface's type.
    """
    return self.__mtu
      
  def _set_mtu(self, v, load=False):
    """
    Setter method for mtu, mapped from YANG variable /interfaces/interface/ipv6/mtu (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mtu is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mtu() directly.

    YANG Description: The size, in octets, of the largest IPv6 packet that the
interface will send and receive.

The server may restrict the allowed values for this leaf,
depending on the interface's type.

If this leaf is not configured, the operationally used MTU
depends on the interface's type.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1280..max']}), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mtu must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1280..max']}), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='uint32', is_config=True)""",
        })

    self.__mtu = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mtu(self):
    self.__mtu = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1280..max']}), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='uint32', is_config=True)


  def _get_address(self):
    """
    Getter method for address, mapped from YANG variable /interfaces/interface/ipv6/address (list)

    YANG Description: The list of IPv6 addresses on the interface.
    """
    return self.__address
      
  def _set_address(self, v, load=False):
    """
    Setter method for address, mapped from YANG variable /interfaces/interface/ipv6/address (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_address() directly.

    YANG Description: The list of IPv6 addresses on the interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("ip",yc_address_ietf_interfaces__interfaces_interface_ipv6_address, yang_name="address", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip', extensions=None), is_container='list', yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """address must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("ip",yc_address_ietf_interfaces__interfaces_interface_ipv6_address, yang_name="address", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip', extensions=None), is_container='list', yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='list', is_config=True)""",
        })

    self.__address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_address(self):
    self.__address = YANGDynClass(base=YANGListType("ip",yc_address_ietf_interfaces__interfaces_interface_ipv6_address, yang_name="address", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip', extensions=None), is_container='list', yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='list', is_config=True)


  def _get_neighbor(self):
    """
    Getter method for neighbor, mapped from YANG variable /interfaces/interface/ipv6/neighbor (list)

    YANG Description: A list of mappings from IPv6 addresses to
link-layer addresses.

Entries in this list in the intended configuration are
used as static entries in the Neighbor Cache.

In the operational state, this list represents the
Neighbor Cache.
    """
    return self.__neighbor
      
  def _set_neighbor(self, v, load=False):
    """
    Setter method for neighbor, mapped from YANG variable /interfaces/interface/ipv6/neighbor (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_neighbor is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_neighbor() directly.

    YANG Description: A list of mappings from IPv6 addresses to
link-layer addresses.

Entries in this list in the intended configuration are
used as static entries in the Neighbor Cache.

In the operational state, this list represents the
Neighbor Cache.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("ip",yc_neighbor_ietf_interfaces__interfaces_interface_ipv6_neighbor, yang_name="neighbor", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip', extensions=None), is_container='list', yang_name="neighbor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """neighbor must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("ip",yc_neighbor_ietf_interfaces__interfaces_interface_ipv6_neighbor, yang_name="neighbor", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip', extensions=None), is_container='list', yang_name="neighbor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='list', is_config=True)""",
        })

    self.__neighbor = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_neighbor(self):
    self.__neighbor = YANGDynClass(base=YANGListType("ip",yc_neighbor_ietf_interfaces__interfaces_interface_ipv6_neighbor, yang_name="neighbor", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip', extensions=None), is_container='list', yang_name="neighbor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='list', is_config=True)


  def _get_dup_addr_detect_transmits(self):
    """
    Getter method for dup_addr_detect_transmits, mapped from YANG variable /interfaces/interface/ipv6/dup_addr_detect_transmits (uint32)

    YANG Description: The number of consecutive Neighbor Solicitation messages
sent while performing Duplicate Address Detection on a
tentative address.  A value of zero indicates that
Duplicate Address Detection is not performed on
tentative addresses.  A value of one indicates a single
transmission with no follow-up retransmissions.
    """
    return self.__dup_addr_detect_transmits
      
  def _set_dup_addr_detect_transmits(self, v, load=False):
    """
    Setter method for dup_addr_detect_transmits, mapped from YANG variable /interfaces/interface/ipv6/dup_addr_detect_transmits (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dup_addr_detect_transmits is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dup_addr_detect_transmits() directly.

    YANG Description: The number of consecutive Neighbor Solicitation messages
sent while performing Duplicate Address Detection on a
tentative address.  A value of zero indicates that
Duplicate Address Detection is not performed on
tentative addresses.  A value of one indicates a single
transmission with no follow-up retransmissions.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="dup-addr-detect-transmits", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dup_addr_detect_transmits must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="dup-addr-detect-transmits", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='uint32', is_config=True)""",
        })

    self.__dup_addr_detect_transmits = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dup_addr_detect_transmits(self):
    self.__dup_addr_detect_transmits = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="dup-addr-detect-transmits", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='uint32', is_config=True)


  def _get_autoconf(self):
    """
    Getter method for autoconf, mapped from YANG variable /interfaces/interface/ipv6/autoconf (container)

    YANG Description: Parameters to control the autoconfiguration of IPv6
addresses, as described in RFC 4862.
    """
    return self.__autoconf
      
  def _set_autoconf(self, v, load=False):
    """
    Setter method for autoconf, mapped from YANG variable /interfaces/interface/ipv6/autoconf (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_autoconf is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_autoconf() directly.

    YANG Description: Parameters to control the autoconfiguration of IPv6
addresses, as described in RFC 4862.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_autoconf_ietf_interfaces__interfaces_interface_ipv6_autoconf, is_container='container', yang_name="autoconf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """autoconf must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_autoconf_ietf_interfaces__interfaces_interface_ipv6_autoconf, is_container='container', yang_name="autoconf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='container', is_config=True)""",
        })

    self.__autoconf = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_autoconf(self):
    self.__autoconf = YANGDynClass(base=yc_autoconf_ietf_interfaces__interfaces_interface_ipv6_autoconf, is_container='container', yang_name="autoconf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='container', is_config=True)


  def _get_bind_ni_name(self):
    """
    Getter method for bind_ni_name, mapped from YANG variable /interfaces/interface/ipv6/bind_ni_name (leafref)

    YANG Description: Network Instance to which IPv6 interface is bound.
    """
    return self.__bind_ni_name
      
  def _set_bind_ni_name(self, v, load=False):
    """
    Setter method for bind_ni_name, mapped from YANG variable /interfaces/interface/ipv6/bind_ni_name (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bind_ni_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bind_ni_name() directly.

    YANG Description: Network Instance to which IPv6 interface is bound.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="bind-ni-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network-instance', defining_module='ietf-network-instance', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bind_ni_name must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="bind-ni-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network-instance', defining_module='ietf-network-instance', yang_type='leafref', is_config=True)""",
        })

    self.__bind_ni_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bind_ni_name(self):
    self.__bind_ni_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="bind-ni-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network-instance', defining_module='ietf-network-instance', yang_type='leafref', is_config=True)

  enabled = __builtin__.property(_get_enabled, _set_enabled)
  forwarding = __builtin__.property(_get_forwarding, _set_forwarding)
  mtu = __builtin__.property(_get_mtu, _set_mtu)
  address = __builtin__.property(_get_address, _set_address) # type: yc_address_ietf_interfaces__interfaces_interface_ipv6_address
  neighbor = __builtin__.property(_get_neighbor, _set_neighbor) # type: yc_neighbor_ietf_interfaces__interfaces_interface_ipv6_neighbor
  dup_addr_detect_transmits = __builtin__.property(_get_dup_addr_detect_transmits, _set_dup_addr_detect_transmits)
  autoconf = __builtin__.property(_get_autoconf, _set_autoconf) # type: yc_autoconf_ietf_interfaces__interfaces_interface_ipv6_autoconf
  bind_ni_name = __builtin__.property(_get_bind_ni_name, _set_bind_ni_name)


  _pyangbind_elements = OrderedDict([('enabled', enabled), ('forwarding', forwarding), ('mtu', mtu), ('address', address), ('neighbor', neighbor), ('dup_addr_detect_transmits', dup_addr_detect_transmits), ('autoconf', autoconf), ('bind_ni_name', bind_ni_name), ])


class yc_interface_ietf_interfaces__interfaces_interface(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-interfaces - based on the path /interfaces/interface. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The list of interfaces on the device.

The status of an interface is available in this list in the
operational state.  If the configuration of a
system-controlled interface cannot be used by the system
(e.g., the interface hardware present does not match the
interface type), then the configuration is not applied to
the system-controlled interface shown in the operational
state.  If the configuration of a user-controlled interface
cannot be used by the system, the configured interface is
not instantiated in the operational state.

System-controlled interfaces created by the system are
always present in this list in the operational state,
whether they are configured or not.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__description','__type','__enabled','__link_up_down_trap_enable','__admin_status','__oper_status','__last_change','__if_index','__phys_address','__higher_layer_if','__lower_layer_if','__speed','__statistics','__ipv4','__ipv6','__bind_ni_name',)

  _yang_name = 'interface'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='string', is_config=True)
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='string', is_config=True)
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='identityref', is_config=True)
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='boolean', is_config=True)
    self.__link_up_down_trap_enable = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'enabled': {'value': 1}, 'disabled': {'value': 2}},), is_leaf=True, yang_name="link-up-down-trap-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='enumeration', is_config=True)
    self.__admin_status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'up': {'value': 1}, 'down': {'value': 2}, 'testing': {'value': 3}},), is_leaf=True, yang_name="admin-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='enumeration', is_config=False)
    self.__oper_status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'up': {'value': 1}, 'down': {'value': 2}, 'testing': {'value': 3}, 'unknown': {'value': 4}, 'dormant': {'value': 5}, 'not-present': {'value': 6}, 'lower-layer-down': {'value': 7}},), is_leaf=True, yang_name="oper-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='enumeration', is_config=False)
    self.__last_change = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="last-change", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:date-and-time', is_config=False)
    self.__if_index = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), restriction_dict={'range': ['1..2147483647']}), is_leaf=True, yang_name="if-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='int32', is_config=False)
    self.__phys_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9a-fA-F]{2}(:[0-9a-fA-F]{2})*)?'}), is_leaf=True, yang_name="phys-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:phys-address', is_config=False)
    self.__higher_layer_if = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="higher-layer-if", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='interface-ref', is_config=False)
    self.__lower_layer_if = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="lower-layer-if", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='interface-ref', is_config=False)
    self.__speed = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="speed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:gauge64', is_config=False)
    self.__statistics = YANGDynClass(base=yc_statistics_ietf_interfaces__interfaces_interface_statistics, is_container='container', yang_name="statistics", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='container', is_config=True)
    self.__ipv4 = YANGDynClass(base=yc_ipv4_ietf_interfaces__interfaces_interface_ipv4, is_container='container', yang_name="ipv4", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='container', is_config=True)
    self.__ipv6 = YANGDynClass(base=yc_ipv6_ietf_interfaces__interfaces_interface_ipv6, is_container='container', yang_name="ipv6", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='container', is_config=True)
    self.__bind_ni_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="bind-ni-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network-instance', defining_module='ietf-network-instance', yang_type='leafref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /interfaces/interface/name (string)

    YANG Description: The name of the interface.

A device MAY restrict the allowed values for this leaf,
possibly depending on the type of the interface.
For system-controlled interfaces, this leaf is the
device-specific name of the interface.

If a client tries to create configuration for a
system-controlled interface that is not present in the
operational state, the server MAY reject the request if
the implementation does not support pre-provisioning of
interfaces or if the name refers to an interface that can
never exist in the system.  A NETCONF server MUST reply
with an rpc-error with the error-tag 'invalid-value' in
this case.

If the device supports pre-provisioning of interface
configuration, the 'pre-provisioning' feature is
advertised.

If the device allows arbitrarily named user-controlled
interfaces, the 'arbitrary-names' feature is advertised.

When a configured user-controlled interface is created by
the system, it is instantiated with the same name in the
operational state.

A server implementation MAY map this leaf to the ifName
MIB object.  Such an implementation needs to use some
mechanism to handle the differences in size and characters
allowed between this leaf and ifName.  The definition of
such a mechanism is outside the scope of this document.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /interfaces/interface/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: The name of the interface.

A device MAY restrict the allowed values for this leaf,
possibly depending on the type of the interface.
For system-controlled interfaces, this leaf is the
device-specific name of the interface.

If a client tries to create configuration for a
system-controlled interface that is not present in the
operational state, the server MAY reject the request if
the implementation does not support pre-provisioning of
interfaces or if the name refers to an interface that can
never exist in the system.  A NETCONF server MUST reply
with an rpc-error with the error-tag 'invalid-value' in
this case.

If the device supports pre-provisioning of interface
configuration, the 'pre-provisioning' feature is
advertised.

If the device allows arbitrarily named user-controlled
interfaces, the 'arbitrary-names' feature is advertised.

When a configured user-controlled interface is created by
the system, it is instantiated with the same name in the
operational state.

A server implementation MAY map this leaf to the ifName
MIB object.  Such an implementation needs to use some
mechanism to handle the differences in size and characters
allowed between this leaf and ifName.  The definition of
such a mechanism is outside the scope of this document.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='string', is_config=True)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /interfaces/interface/description (string)

    YANG Description: A textual description of the interface.

A server implementation MAY map this leaf to the ifAlias
MIB object.  Such an implementation needs to use some
mechanism to handle the differences in size and characters
allowed between this leaf and ifAlias.  The definition of
such a mechanism is outside the scope of this document.

Since ifAlias is defined to be stored in non-volatile
storage, the MIB implementation MUST map ifAlias to the
value of 'description' in the persistently stored
configuration.
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /interfaces/interface/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: A textual description of the interface.

A server implementation MAY map this leaf to the ifAlias
MIB object.  Such an implementation needs to use some
mechanism to handle the differences in size and characters
allowed between this leaf and ifAlias.  The definition of
such a mechanism is outside the scope of this document.

Since ifAlias is defined to be stored in non-volatile
storage, the MIB implementation MUST map ifAlias to the
value of 'description' in the persistently stored
configuration.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='string', is_config=True)


  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /interfaces/interface/type (identityref)

    YANG Description: The type of the interface.

When an interface entry is created, a server MAY
initialize the type leaf with a valid value, e.g., if it
is possible to derive the type from the name of the
interface.

If a client tries to set the type of an interface to a
value that can never be used by the system, e.g., if the
type is not supported or if the type does not match the
name of the interface, the server MUST reject the request.
A NETCONF server MUST reply with an rpc-error with the
error-tag 'invalid-value' in this case.
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /interfaces/interface/type (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: The type of the interface.

When an interface entry is created, a server MAY
initialize the type leaf with a valid value, e.g., if it
is possible to derive the type from the name of the
interface.

If a client tries to set the type of an interface to a
value that can never be used by the system, e.g., if the
type is not supported or if the type does not match the
name of the interface, the server MUST reject the request.
A NETCONF server MUST reply with an rpc-error with the
error-tag 'invalid-value' in this case.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with identityref""",
          'defined-type': "ietf-interfaces:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='identityref', is_config=True)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='identityref', is_config=True)


  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /interfaces/interface/enabled (boolean)

    YANG Description: This leaf contains the configured, desired state of the
interface.

Systems that implement the IF-MIB use the value of this
leaf in the intended configuration to set
IF-MIB.ifAdminStatus to 'up' or 'down' after an ifEntry
has been initialized, as described in RFC 2863.

Changes in this leaf in the intended configuration are
reflected in ifAdminStatus.
    """
    return self.__enabled
      
  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /interfaces/interface/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: This leaf contains the configured, desired state of the
interface.

Systems that implement the IF-MIB use the value of this
leaf in the intended configuration to set
IF-MIB.ifAdminStatus to 'up' or 'down' after an ifEntry
has been initialized, as described in RFC 2863.

Changes in this leaf in the intended configuration are
reflected in ifAdminStatus.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='boolean', is_config=True)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='boolean', is_config=True)


  def _get_link_up_down_trap_enable(self):
    """
    Getter method for link_up_down_trap_enable, mapped from YANG variable /interfaces/interface/link_up_down_trap_enable (enumeration)

    YANG Description: Controls whether linkUp/linkDown SNMP notifications
should be generated for this interface.

If this node is not configured, the value 'enabled' is
operationally used by the server for interfaces that do
not operate on top of any other interface (i.e., there are
no 'lower-layer-if' entries), and 'disabled' otherwise.
    """
    return self.__link_up_down_trap_enable
      
  def _set_link_up_down_trap_enable(self, v, load=False):
    """
    Setter method for link_up_down_trap_enable, mapped from YANG variable /interfaces/interface/link_up_down_trap_enable (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_link_up_down_trap_enable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_link_up_down_trap_enable() directly.

    YANG Description: Controls whether linkUp/linkDown SNMP notifications
should be generated for this interface.

If this node is not configured, the value 'enabled' is
operationally used by the server for interfaces that do
not operate on top of any other interface (i.e., there are
no 'lower-layer-if' entries), and 'disabled' otherwise.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'enabled': {'value': 1}, 'disabled': {'value': 2}},), is_leaf=True, yang_name="link-up-down-trap-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """link_up_down_trap_enable must be of a type compatible with enumeration""",
          'defined-type': "ietf-interfaces:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'enabled': {'value': 1}, 'disabled': {'value': 2}},), is_leaf=True, yang_name="link-up-down-trap-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='enumeration', is_config=True)""",
        })

    self.__link_up_down_trap_enable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_link_up_down_trap_enable(self):
    self.__link_up_down_trap_enable = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'enabled': {'value': 1}, 'disabled': {'value': 2}},), is_leaf=True, yang_name="link-up-down-trap-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='enumeration', is_config=True)


  def _get_admin_status(self):
    """
    Getter method for admin_status, mapped from YANG variable /interfaces/interface/admin_status (enumeration)

    YANG Description: The desired state of the interface.

This leaf has the same read semantics as ifAdminStatus.
    """
    return self.__admin_status
      
  def _set_admin_status(self, v, load=False):
    """
    Setter method for admin_status, mapped from YANG variable /interfaces/interface/admin_status (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_admin_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_admin_status() directly.

    YANG Description: The desired state of the interface.

This leaf has the same read semantics as ifAdminStatus.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'up': {'value': 1}, 'down': {'value': 2}, 'testing': {'value': 3}},), is_leaf=True, yang_name="admin-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='enumeration', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """admin_status must be of a type compatible with enumeration""",
          'defined-type': "ietf-interfaces:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'up': {'value': 1}, 'down': {'value': 2}, 'testing': {'value': 3}},), is_leaf=True, yang_name="admin-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='enumeration', is_config=False)""",
        })

    self.__admin_status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_admin_status(self):
    self.__admin_status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'up': {'value': 1}, 'down': {'value': 2}, 'testing': {'value': 3}},), is_leaf=True, yang_name="admin-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='enumeration', is_config=False)


  def _get_oper_status(self):
    """
    Getter method for oper_status, mapped from YANG variable /interfaces/interface/oper_status (enumeration)

    YANG Description: The current operational state of the interface.

This leaf has the same semantics as ifOperStatus.
    """
    return self.__oper_status
      
  def _set_oper_status(self, v, load=False):
    """
    Setter method for oper_status, mapped from YANG variable /interfaces/interface/oper_status (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_oper_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_oper_status() directly.

    YANG Description: The current operational state of the interface.

This leaf has the same semantics as ifOperStatus.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'up': {'value': 1}, 'down': {'value': 2}, 'testing': {'value': 3}, 'unknown': {'value': 4}, 'dormant': {'value': 5}, 'not-present': {'value': 6}, 'lower-layer-down': {'value': 7}},), is_leaf=True, yang_name="oper-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='enumeration', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """oper_status must be of a type compatible with enumeration""",
          'defined-type': "ietf-interfaces:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'up': {'value': 1}, 'down': {'value': 2}, 'testing': {'value': 3}, 'unknown': {'value': 4}, 'dormant': {'value': 5}, 'not-present': {'value': 6}, 'lower-layer-down': {'value': 7}},), is_leaf=True, yang_name="oper-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='enumeration', is_config=False)""",
        })

    self.__oper_status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_oper_status(self):
    self.__oper_status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'up': {'value': 1}, 'down': {'value': 2}, 'testing': {'value': 3}, 'unknown': {'value': 4}, 'dormant': {'value': 5}, 'not-present': {'value': 6}, 'lower-layer-down': {'value': 7}},), is_leaf=True, yang_name="oper-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='enumeration', is_config=False)


  def _get_last_change(self):
    """
    Getter method for last_change, mapped from YANG variable /interfaces/interface/last_change (yang:date-and-time)

    YANG Description: The time the interface entered its current operational
state.  If the current state was entered prior to the
last re-initialization of the local network management
subsystem, then this node is not present.
    """
    return self.__last_change
      
  def _set_last_change(self, v, load=False):
    """
    Setter method for last_change, mapped from YANG variable /interfaces/interface/last_change (yang:date-and-time)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_last_change is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_last_change() directly.

    YANG Description: The time the interface entered its current operational
state.  If the current state was entered prior to the
last re-initialization of the local network management
subsystem, then this node is not present.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="last-change", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:date-and-time', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """last_change must be of a type compatible with yang:date-and-time""",
          'defined-type': "yang:date-and-time",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="last-change", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:date-and-time', is_config=False)""",
        })

    self.__last_change = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_last_change(self):
    self.__last_change = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="last-change", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:date-and-time', is_config=False)


  def _get_if_index(self):
    """
    Getter method for if_index, mapped from YANG variable /interfaces/interface/if_index (int32)

    YANG Description: The ifIndex value for the ifEntry represented by this
interface.
    """
    return self.__if_index
      
  def _set_if_index(self, v, load=False):
    """
    Setter method for if_index, mapped from YANG variable /interfaces/interface/if_index (int32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_if_index is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_if_index() directly.

    YANG Description: The ifIndex value for the ifEntry represented by this
interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), restriction_dict={'range': ['1..2147483647']}), is_leaf=True, yang_name="if-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='int32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """if_index must be of a type compatible with int32""",
          'defined-type': "int32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), restriction_dict={'range': ['1..2147483647']}), is_leaf=True, yang_name="if-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='int32', is_config=False)""",
        })

    self.__if_index = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_if_index(self):
    self.__if_index = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), restriction_dict={'range': ['1..2147483647']}), is_leaf=True, yang_name="if-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='int32', is_config=False)


  def _get_phys_address(self):
    """
    Getter method for phys_address, mapped from YANG variable /interfaces/interface/phys_address (yang:phys-address)

    YANG Description: The interface's address at its protocol sub-layer.  For
example, for an 802.x interface, this object normally
contains a Media Access Control (MAC) address.  The
interface's media-specific modules must define the bit
and byte ordering and the format of the value of this
object.  For interfaces that do not have such an address
(e.g., a serial line), this node is not present.
    """
    return self.__phys_address
      
  def _set_phys_address(self, v, load=False):
    """
    Setter method for phys_address, mapped from YANG variable /interfaces/interface/phys_address (yang:phys-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_phys_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_phys_address() directly.

    YANG Description: The interface's address at its protocol sub-layer.  For
example, for an 802.x interface, this object normally
contains a Media Access Control (MAC) address.  The
interface's media-specific modules must define the bit
and byte ordering and the format of the value of this
object.  For interfaces that do not have such an address
(e.g., a serial line), this node is not present.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9a-fA-F]{2}(:[0-9a-fA-F]{2})*)?'}), is_leaf=True, yang_name="phys-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:phys-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """phys_address must be of a type compatible with yang:phys-address""",
          'defined-type': "yang:phys-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9a-fA-F]{2}(:[0-9a-fA-F]{2})*)?'}), is_leaf=True, yang_name="phys-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:phys-address', is_config=False)""",
        })

    self.__phys_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_phys_address(self):
    self.__phys_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9a-fA-F]{2}(:[0-9a-fA-F]{2})*)?'}), is_leaf=True, yang_name="phys-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:phys-address', is_config=False)


  def _get_higher_layer_if(self):
    """
    Getter method for higher_layer_if, mapped from YANG variable /interfaces/interface/higher_layer_if (interface-ref)

    YANG Description: A list of references to interfaces layered on top of this
interface.
    """
    return self.__higher_layer_if
      
  def _set_higher_layer_if(self, v, load=False):
    """
    Setter method for higher_layer_if, mapped from YANG variable /interfaces/interface/higher_layer_if (interface-ref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_higher_layer_if is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_higher_layer_if() directly.

    YANG Description: A list of references to interfaces layered on top of this
interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="higher-layer-if", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='interface-ref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """higher_layer_if must be of a type compatible with interface-ref""",
          'defined-type': "ietf-interfaces:interface-ref",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="higher-layer-if", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='interface-ref', is_config=False)""",
        })

    self.__higher_layer_if = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_higher_layer_if(self):
    self.__higher_layer_if = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="higher-layer-if", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='interface-ref', is_config=False)


  def _get_lower_layer_if(self):
    """
    Getter method for lower_layer_if, mapped from YANG variable /interfaces/interface/lower_layer_if (interface-ref)

    YANG Description: A list of references to interfaces layered underneath this
interface.
    """
    return self.__lower_layer_if
      
  def _set_lower_layer_if(self, v, load=False):
    """
    Setter method for lower_layer_if, mapped from YANG variable /interfaces/interface/lower_layer_if (interface-ref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lower_layer_if is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lower_layer_if() directly.

    YANG Description: A list of references to interfaces layered underneath this
interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="lower-layer-if", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='interface-ref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lower_layer_if must be of a type compatible with interface-ref""",
          'defined-type': "ietf-interfaces:interface-ref",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="lower-layer-if", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='interface-ref', is_config=False)""",
        })

    self.__lower_layer_if = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lower_layer_if(self):
    self.__lower_layer_if = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="lower-layer-if", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='interface-ref', is_config=False)


  def _get_speed(self):
    """
    Getter method for speed, mapped from YANG variable /interfaces/interface/speed (yang:gauge64)

    YANG Description: An estimate of the interface's current bandwidth in bits
per second.  For interfaces that do not vary in
bandwidth or for those where no accurate estimation can
be made, this node should contain the nominal bandwidth.
For interfaces that have no concept of bandwidth, this
node is not present.
    """
    return self.__speed
      
  def _set_speed(self, v, load=False):
    """
    Setter method for speed, mapped from YANG variable /interfaces/interface/speed (yang:gauge64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_speed is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_speed() directly.

    YANG Description: An estimate of the interface's current bandwidth in bits
per second.  For interfaces that do not vary in
bandwidth or for those where no accurate estimation can
be made, this node should contain the nominal bandwidth.
For interfaces that have no concept of bandwidth, this
node is not present.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="speed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:gauge64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """speed must be of a type compatible with yang:gauge64""",
          'defined-type': "yang:gauge64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="speed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:gauge64', is_config=False)""",
        })

    self.__speed = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_speed(self):
    self.__speed = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="speed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:gauge64', is_config=False)


  def _get_statistics(self):
    """
    Getter method for statistics, mapped from YANG variable /interfaces/interface/statistics (container)

    YANG Description: A collection of interface-related statistics objects.
    """
    return self.__statistics
      
  def _set_statistics(self, v, load=False):
    """
    Setter method for statistics, mapped from YANG variable /interfaces/interface/statistics (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_statistics is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_statistics() directly.

    YANG Description: A collection of interface-related statistics objects.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_statistics_ietf_interfaces__interfaces_interface_statistics, is_container='container', yang_name="statistics", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """statistics must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_statistics_ietf_interfaces__interfaces_interface_statistics, is_container='container', yang_name="statistics", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='container', is_config=True)""",
        })

    self.__statistics = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_statistics(self):
    self.__statistics = YANGDynClass(base=yc_statistics_ietf_interfaces__interfaces_interface_statistics, is_container='container', yang_name="statistics", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='container', is_config=True)


  def _get_ipv4(self):
    """
    Getter method for ipv4, mapped from YANG variable /interfaces/interface/ipv4 (container)

    YANG Description: Parameters for the IPv4 address family.
    """
    return self.__ipv4
      
  def _set_ipv4(self, v, load=False):
    """
    Setter method for ipv4, mapped from YANG variable /interfaces/interface/ipv4 (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv4 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv4() directly.

    YANG Description: Parameters for the IPv4 address family.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ipv4_ietf_interfaces__interfaces_interface_ipv4, is_container='container', yang_name="ipv4", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv4 must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ipv4_ietf_interfaces__interfaces_interface_ipv4, is_container='container', yang_name="ipv4", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='container', is_config=True)""",
        })

    self.__ipv4 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv4(self):
    self.__ipv4 = YANGDynClass(base=yc_ipv4_ietf_interfaces__interfaces_interface_ipv4, is_container='container', yang_name="ipv4", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='container', is_config=True)


  def _get_ipv6(self):
    """
    Getter method for ipv6, mapped from YANG variable /interfaces/interface/ipv6 (container)

    YANG Description: Parameters for the IPv6 address family.
    """
    return self.__ipv6
      
  def _set_ipv6(self, v, load=False):
    """
    Setter method for ipv6, mapped from YANG variable /interfaces/interface/ipv6 (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv6 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv6() directly.

    YANG Description: Parameters for the IPv6 address family.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ipv6_ietf_interfaces__interfaces_interface_ipv6, is_container='container', yang_name="ipv6", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv6 must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ipv6_ietf_interfaces__interfaces_interface_ipv6, is_container='container', yang_name="ipv6", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='container', is_config=True)""",
        })

    self.__ipv6 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv6(self):
    self.__ipv6 = YANGDynClass(base=yc_ipv6_ietf_interfaces__interfaces_interface_ipv6, is_container='container', yang_name="ipv6", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='container', is_config=True)


  def _get_bind_ni_name(self):
    """
    Getter method for bind_ni_name, mapped from YANG variable /interfaces/interface/bind_ni_name (leafref)

    YANG Description: Network Instance to which an interface is bound.
    """
    return self.__bind_ni_name
      
  def _set_bind_ni_name(self, v, load=False):
    """
    Setter method for bind_ni_name, mapped from YANG variable /interfaces/interface/bind_ni_name (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bind_ni_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bind_ni_name() directly.

    YANG Description: Network Instance to which an interface is bound.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="bind-ni-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network-instance', defining_module='ietf-network-instance', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bind_ni_name must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="bind-ni-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network-instance', defining_module='ietf-network-instance', yang_type='leafref', is_config=True)""",
        })

    self.__bind_ni_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bind_ni_name(self):
    self.__bind_ni_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="bind-ni-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network-instance', defining_module='ietf-network-instance', yang_type='leafref', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  description = __builtin__.property(_get_description, _set_description)
  type = __builtin__.property(_get_type, _set_type)
  enabled = __builtin__.property(_get_enabled, _set_enabled)
  link_up_down_trap_enable = __builtin__.property(_get_link_up_down_trap_enable, _set_link_up_down_trap_enable)
  admin_status = __builtin__.property(_get_admin_status)
  oper_status = __builtin__.property(_get_oper_status)
  last_change = __builtin__.property(_get_last_change)
  if_index = __builtin__.property(_get_if_index)
  phys_address = __builtin__.property(_get_phys_address)
  higher_layer_if = __builtin__.property(_get_higher_layer_if)
  lower_layer_if = __builtin__.property(_get_lower_layer_if)
  speed = __builtin__.property(_get_speed)
  statistics = __builtin__.property(_get_statistics, _set_statistics) # type: yc_statistics_ietf_interfaces__interfaces_interface_statistics
  ipv4 = __builtin__.property(_get_ipv4, _set_ipv4) # type: yc_ipv4_ietf_interfaces__interfaces_interface_ipv4
  ipv6 = __builtin__.property(_get_ipv6, _set_ipv6) # type: yc_ipv6_ietf_interfaces__interfaces_interface_ipv6
  bind_ni_name = __builtin__.property(_get_bind_ni_name, _set_bind_ni_name)


  _pyangbind_elements = OrderedDict([('name', name), ('description', description), ('type', type), ('enabled', enabled), ('link_up_down_trap_enable', link_up_down_trap_enable), ('admin_status', admin_status), ('oper_status', oper_status), ('last_change', last_change), ('if_index', if_index), ('phys_address', phys_address), ('higher_layer_if', higher_layer_if), ('lower_layer_if', lower_layer_if), ('speed', speed), ('statistics', statistics), ('ipv4', ipv4), ('ipv6', ipv6), ('bind_ni_name', bind_ni_name), ])


class yc_interfaces_ietf_interfaces__interfaces(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-interfaces - based on the path /interfaces. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Interface parameters.
  """
  __slots__ = ('_path_helper', '_extmethods', '__interface',)

  _yang_name = 'interfaces'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__interface = YANGDynClass(base=YANGListType("name",yc_interface_ietf_interfaces__interfaces_interface, yang_name="interface", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces']

  def _get_interface(self):
    """
    Getter method for interface, mapped from YANG variable /interfaces/interface (list)

    YANG Description: The list of interfaces on the device.

The status of an interface is available in this list in the
operational state.  If the configuration of a
system-controlled interface cannot be used by the system
(e.g., the interface hardware present does not match the
interface type), then the configuration is not applied to
the system-controlled interface shown in the operational
state.  If the configuration of a user-controlled interface
cannot be used by the system, the configured interface is
not instantiated in the operational state.

System-controlled interfaces created by the system are
always present in this list in the operational state,
whether they are configured or not.
    """
    return self.__interface
      
  def _set_interface(self, v, load=False):
    """
    Setter method for interface, mapped from YANG variable /interfaces/interface (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface() directly.

    YANG Description: The list of interfaces on the device.

The status of an interface is available in this list in the
operational state.  If the configuration of a
system-controlled interface cannot be used by the system
(e.g., the interface hardware present does not match the
interface type), then the configuration is not applied to
the system-controlled interface shown in the operational
state.  If the configuration of a user-controlled interface
cannot be used by the system, the configured interface is
not instantiated in the operational state.

System-controlled interfaces created by the system are
always present in this list in the operational state,
whether they are configured or not.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_interface_ietf_interfaces__interfaces_interface, yang_name="interface", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_interface_ietf_interfaces__interfaces_interface, yang_name="interface", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='list', is_config=True)""",
        })

    self.__interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface(self):
    self.__interface = YANGDynClass(base=YANGListType("name",yc_interface_ietf_interfaces__interfaces_interface, yang_name="interface", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='list', is_config=True)

  interface = __builtin__.property(_get_interface, _set_interface) # type: yc_interface_ietf_interfaces__interfaces_interface


  _pyangbind_elements = OrderedDict([('interface', interface), ])


class yc_statistics_ietf_interfaces__interfaces_state_interface_statistics(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-interfaces - based on the path /interfaces-state/interface/statistics. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: A collection of interface-related statistics objects.
  """
  __slots__ = ('_path_helper', '_extmethods', '__discontinuity_time','__in_octets','__in_unicast_pkts','__in_broadcast_pkts','__in_multicast_pkts','__in_discards','__in_errors','__in_unknown_protos','__out_octets','__out_unicast_pkts','__out_broadcast_pkts','__out_multicast_pkts','__out_discards','__out_errors',)

  _yang_name = 'statistics'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__discontinuity_time = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="discontinuity-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:date-and-time', is_config=False)
    self.__in_octets = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)
    self.__in_unicast_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-unicast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)
    self.__in_broadcast_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-broadcast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)
    self.__in_multicast_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-multicast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)
    self.__in_discards = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="in-discards", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter32', is_config=False)
    self.__in_errors = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="in-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter32', is_config=False)
    self.__in_unknown_protos = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="in-unknown-protos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter32', is_config=False)
    self.__out_octets = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)
    self.__out_unicast_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-unicast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)
    self.__out_broadcast_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-broadcast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)
    self.__out_multicast_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-multicast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)
    self.__out_discards = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="out-discards", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter32', is_config=False)
    self.__out_errors = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="out-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter32', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces-state', 'interface', 'statistics']

  def _get_discontinuity_time(self):
    """
    Getter method for discontinuity_time, mapped from YANG variable /interfaces_state/interface/statistics/discontinuity_time (yang:date-and-time)

    YANG Description: The time on the most recent occasion at which any one or
more of this interface's counters suffered a
discontinuity.  If no such discontinuities have occurred
since the last re-initialization of the local management
subsystem, then this node contains the time the local
management subsystem re-initialized itself.
    """
    return self.__discontinuity_time
      
  def _set_discontinuity_time(self, v, load=False):
    """
    Setter method for discontinuity_time, mapped from YANG variable /interfaces_state/interface/statistics/discontinuity_time (yang:date-and-time)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_discontinuity_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_discontinuity_time() directly.

    YANG Description: The time on the most recent occasion at which any one or
more of this interface's counters suffered a
discontinuity.  If no such discontinuities have occurred
since the last re-initialization of the local management
subsystem, then this node contains the time the local
management subsystem re-initialized itself.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="discontinuity-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:date-and-time', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """discontinuity_time must be of a type compatible with yang:date-and-time""",
          'defined-type': "yang:date-and-time",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="discontinuity-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:date-and-time', is_config=False)""",
        })

    self.__discontinuity_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_discontinuity_time(self):
    self.__discontinuity_time = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="discontinuity-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:date-and-time', is_config=False)


  def _get_in_octets(self):
    """
    Getter method for in_octets, mapped from YANG variable /interfaces_state/interface/statistics/in_octets (yang:counter64)

    YANG Description: The total number of octets received on the interface,
including framing characters.

Discontinuities in the value of this counter can occur
at re-initialization of the management system, and at
other times as indicated by the value of
'discontinuity-time'.
    """
    return self.__in_octets
      
  def _set_in_octets(self, v, load=False):
    """
    Setter method for in_octets, mapped from YANG variable /interfaces_state/interface/statistics/in_octets (yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_octets is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_octets() directly.

    YANG Description: The total number of octets received on the interface,
including framing characters.

Discontinuities in the value of this counter can occur
at re-initialization of the management system, and at
other times as indicated by the value of
'discontinuity-time'.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_octets must be of a type compatible with yang:counter64""",
          'defined-type': "yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)""",
        })

    self.__in_octets = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_octets(self):
    self.__in_octets = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)


  def _get_in_unicast_pkts(self):
    """
    Getter method for in_unicast_pkts, mapped from YANG variable /interfaces_state/interface/statistics/in_unicast_pkts (yang:counter64)

    YANG Description: The number of packets, delivered by this sub-layer to a
higher (sub-)layer, that were not addressed to a
multicast or broadcast address at this sub-layer.

Discontinuities in the value of this counter can occur
at re-initialization of the management system, and at
other times as indicated by the value of
'discontinuity-time'.
    """
    return self.__in_unicast_pkts
      
  def _set_in_unicast_pkts(self, v, load=False):
    """
    Setter method for in_unicast_pkts, mapped from YANG variable /interfaces_state/interface/statistics/in_unicast_pkts (yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_unicast_pkts is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_unicast_pkts() directly.

    YANG Description: The number of packets, delivered by this sub-layer to a
higher (sub-)layer, that were not addressed to a
multicast or broadcast address at this sub-layer.

Discontinuities in the value of this counter can occur
at re-initialization of the management system, and at
other times as indicated by the value of
'discontinuity-time'.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-unicast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_unicast_pkts must be of a type compatible with yang:counter64""",
          'defined-type': "yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-unicast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)""",
        })

    self.__in_unicast_pkts = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_unicast_pkts(self):
    self.__in_unicast_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-unicast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)


  def _get_in_broadcast_pkts(self):
    """
    Getter method for in_broadcast_pkts, mapped from YANG variable /interfaces_state/interface/statistics/in_broadcast_pkts (yang:counter64)

    YANG Description: The number of packets, delivered by this sub-layer to a
higher (sub-)layer, that were addressed to a broadcast
address at this sub-layer.

Discontinuities in the value of this counter can occur
at re-initialization of the management system, and at
other times as indicated by the value of
'discontinuity-time'.
    """
    return self.__in_broadcast_pkts
      
  def _set_in_broadcast_pkts(self, v, load=False):
    """
    Setter method for in_broadcast_pkts, mapped from YANG variable /interfaces_state/interface/statistics/in_broadcast_pkts (yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_broadcast_pkts is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_broadcast_pkts() directly.

    YANG Description: The number of packets, delivered by this sub-layer to a
higher (sub-)layer, that were addressed to a broadcast
address at this sub-layer.

Discontinuities in the value of this counter can occur
at re-initialization of the management system, and at
other times as indicated by the value of
'discontinuity-time'.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-broadcast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_broadcast_pkts must be of a type compatible with yang:counter64""",
          'defined-type': "yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-broadcast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)""",
        })

    self.__in_broadcast_pkts = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_broadcast_pkts(self):
    self.__in_broadcast_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-broadcast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)


  def _get_in_multicast_pkts(self):
    """
    Getter method for in_multicast_pkts, mapped from YANG variable /interfaces_state/interface/statistics/in_multicast_pkts (yang:counter64)

    YANG Description: The number of packets, delivered by this sub-layer to a
higher (sub-)layer, that were addressed to a multicast
address at this sub-layer.  For a MAC-layer protocol,
this includes both Group and Functional addresses.

Discontinuities in the value of this counter can occur
at re-initialization of the management system, and at
other times as indicated by the value of
'discontinuity-time'.
    """
    return self.__in_multicast_pkts
      
  def _set_in_multicast_pkts(self, v, load=False):
    """
    Setter method for in_multicast_pkts, mapped from YANG variable /interfaces_state/interface/statistics/in_multicast_pkts (yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_multicast_pkts is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_multicast_pkts() directly.

    YANG Description: The number of packets, delivered by this sub-layer to a
higher (sub-)layer, that were addressed to a multicast
address at this sub-layer.  For a MAC-layer protocol,
this includes both Group and Functional addresses.

Discontinuities in the value of this counter can occur
at re-initialization of the management system, and at
other times as indicated by the value of
'discontinuity-time'.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-multicast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_multicast_pkts must be of a type compatible with yang:counter64""",
          'defined-type': "yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-multicast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)""",
        })

    self.__in_multicast_pkts = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_multicast_pkts(self):
    self.__in_multicast_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-multicast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)


  def _get_in_discards(self):
    """
    Getter method for in_discards, mapped from YANG variable /interfaces_state/interface/statistics/in_discards (yang:counter32)

    YANG Description: The number of inbound packets that were chosen to be
discarded even though no errors had been detected to
prevent their being deliverable to a higher-layer
protocol.  One possible reason for discarding such a
packet could be to free up buffer space.

Discontinuities in the value of this counter can occur
at re-initialization of the management system, and at
other times as indicated by the value of
'discontinuity-time'.
    """
    return self.__in_discards
      
  def _set_in_discards(self, v, load=False):
    """
    Setter method for in_discards, mapped from YANG variable /interfaces_state/interface/statistics/in_discards (yang:counter32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_discards is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_discards() directly.

    YANG Description: The number of inbound packets that were chosen to be
discarded even though no errors had been detected to
prevent their being deliverable to a higher-layer
protocol.  One possible reason for discarding such a
packet could be to free up buffer space.

Discontinuities in the value of this counter can occur
at re-initialization of the management system, and at
other times as indicated by the value of
'discontinuity-time'.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="in-discards", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_discards must be of a type compatible with yang:counter32""",
          'defined-type': "yang:counter32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="in-discards", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter32', is_config=False)""",
        })

    self.__in_discards = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_discards(self):
    self.__in_discards = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="in-discards", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter32', is_config=False)


  def _get_in_errors(self):
    """
    Getter method for in_errors, mapped from YANG variable /interfaces_state/interface/statistics/in_errors (yang:counter32)

    YANG Description: For packet-oriented interfaces, the number of inbound
packets that contained errors preventing them from being
deliverable to a higher-layer protocol.  For character-
oriented or fixed-length interfaces, the number of
inbound transmission units that contained errors
preventing them from being deliverable to a higher-layer
protocol.

Discontinuities in the value of this counter can occur
at re-initialization of the management system, and at
other times as indicated by the value of
'discontinuity-time'.
    """
    return self.__in_errors
      
  def _set_in_errors(self, v, load=False):
    """
    Setter method for in_errors, mapped from YANG variable /interfaces_state/interface/statistics/in_errors (yang:counter32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_errors is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_errors() directly.

    YANG Description: For packet-oriented interfaces, the number of inbound
packets that contained errors preventing them from being
deliverable to a higher-layer protocol.  For character-
oriented or fixed-length interfaces, the number of
inbound transmission units that contained errors
preventing them from being deliverable to a higher-layer
protocol.

Discontinuities in the value of this counter can occur
at re-initialization of the management system, and at
other times as indicated by the value of
'discontinuity-time'.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="in-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_errors must be of a type compatible with yang:counter32""",
          'defined-type': "yang:counter32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="in-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter32', is_config=False)""",
        })

    self.__in_errors = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_errors(self):
    self.__in_errors = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="in-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter32', is_config=False)


  def _get_in_unknown_protos(self):
    """
    Getter method for in_unknown_protos, mapped from YANG variable /interfaces_state/interface/statistics/in_unknown_protos (yang:counter32)

    YANG Description: For packet-oriented interfaces, the number of packets
received via the interface that were discarded because
of an unknown or unsupported protocol.  For
character-oriented or fixed-length interfaces that
support protocol multiplexing, the number of
transmission units received via the interface that were
discarded because of an unknown or unsupported protocol.
For any interface that does not support protocol
multiplexing, this counter is not present.

Discontinuities in the value of this counter can occur
at re-initialization of the management system, and at
other times as indicated by the value of
'discontinuity-time'.
    """
    return self.__in_unknown_protos
      
  def _set_in_unknown_protos(self, v, load=False):
    """
    Setter method for in_unknown_protos, mapped from YANG variable /interfaces_state/interface/statistics/in_unknown_protos (yang:counter32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_unknown_protos is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_unknown_protos() directly.

    YANG Description: For packet-oriented interfaces, the number of packets
received via the interface that were discarded because
of an unknown or unsupported protocol.  For
character-oriented or fixed-length interfaces that
support protocol multiplexing, the number of
transmission units received via the interface that were
discarded because of an unknown or unsupported protocol.
For any interface that does not support protocol
multiplexing, this counter is not present.

Discontinuities in the value of this counter can occur
at re-initialization of the management system, and at
other times as indicated by the value of
'discontinuity-time'.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="in-unknown-protos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_unknown_protos must be of a type compatible with yang:counter32""",
          'defined-type': "yang:counter32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="in-unknown-protos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter32', is_config=False)""",
        })

    self.__in_unknown_protos = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_unknown_protos(self):
    self.__in_unknown_protos = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="in-unknown-protos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter32', is_config=False)


  def _get_out_octets(self):
    """
    Getter method for out_octets, mapped from YANG variable /interfaces_state/interface/statistics/out_octets (yang:counter64)

    YANG Description: The total number of octets transmitted out of the
interface, including framing characters.
Discontinuities in the value of this counter can occur
at re-initialization of the management system, and at
other times as indicated by the value of
'discontinuity-time'.
    """
    return self.__out_octets
      
  def _set_out_octets(self, v, load=False):
    """
    Setter method for out_octets, mapped from YANG variable /interfaces_state/interface/statistics/out_octets (yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_octets is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_octets() directly.

    YANG Description: The total number of octets transmitted out of the
interface, including framing characters.
Discontinuities in the value of this counter can occur
at re-initialization of the management system, and at
other times as indicated by the value of
'discontinuity-time'.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_octets must be of a type compatible with yang:counter64""",
          'defined-type': "yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)""",
        })

    self.__out_octets = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_octets(self):
    self.__out_octets = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)


  def _get_out_unicast_pkts(self):
    """
    Getter method for out_unicast_pkts, mapped from YANG variable /interfaces_state/interface/statistics/out_unicast_pkts (yang:counter64)

    YANG Description: The total number of packets that higher-level protocols
requested be transmitted, and that were not addressed
to a multicast or broadcast address at this sub-layer,
including those that were discarded or not sent.

Discontinuities in the value of this counter can occur
at re-initialization of the management system, and at
other times as indicated by the value of
'discontinuity-time'.
    """
    return self.__out_unicast_pkts
      
  def _set_out_unicast_pkts(self, v, load=False):
    """
    Setter method for out_unicast_pkts, mapped from YANG variable /interfaces_state/interface/statistics/out_unicast_pkts (yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_unicast_pkts is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_unicast_pkts() directly.

    YANG Description: The total number of packets that higher-level protocols
requested be transmitted, and that were not addressed
to a multicast or broadcast address at this sub-layer,
including those that were discarded or not sent.

Discontinuities in the value of this counter can occur
at re-initialization of the management system, and at
other times as indicated by the value of
'discontinuity-time'.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-unicast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_unicast_pkts must be of a type compatible with yang:counter64""",
          'defined-type': "yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-unicast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)""",
        })

    self.__out_unicast_pkts = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_unicast_pkts(self):
    self.__out_unicast_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-unicast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)


  def _get_out_broadcast_pkts(self):
    """
    Getter method for out_broadcast_pkts, mapped from YANG variable /interfaces_state/interface/statistics/out_broadcast_pkts (yang:counter64)

    YANG Description: The total number of packets that higher-level protocols
requested be transmitted, and that were addressed to a
broadcast address at this sub-layer, including those
that were discarded or not sent.

Discontinuities in the value of this counter can occur
at re-initialization of the management system, and at
other times as indicated by the value of
'discontinuity-time'.
    """
    return self.__out_broadcast_pkts
      
  def _set_out_broadcast_pkts(self, v, load=False):
    """
    Setter method for out_broadcast_pkts, mapped from YANG variable /interfaces_state/interface/statistics/out_broadcast_pkts (yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_broadcast_pkts is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_broadcast_pkts() directly.

    YANG Description: The total number of packets that higher-level protocols
requested be transmitted, and that were addressed to a
broadcast address at this sub-layer, including those
that were discarded or not sent.

Discontinuities in the value of this counter can occur
at re-initialization of the management system, and at
other times as indicated by the value of
'discontinuity-time'.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-broadcast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_broadcast_pkts must be of a type compatible with yang:counter64""",
          'defined-type': "yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-broadcast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)""",
        })

    self.__out_broadcast_pkts = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_broadcast_pkts(self):
    self.__out_broadcast_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-broadcast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)


  def _get_out_multicast_pkts(self):
    """
    Getter method for out_multicast_pkts, mapped from YANG variable /interfaces_state/interface/statistics/out_multicast_pkts (yang:counter64)

    YANG Description: The total number of packets that higher-level protocols
requested be transmitted, and that were addressed to a
multicast address at this sub-layer, including those
that were discarded or not sent.  For a MAC-layer
protocol, this includes both Group and Functional
addresses.

Discontinuities in the value of this counter can occur
at re-initialization of the management system, and at
other times as indicated by the value of
'discontinuity-time'.
    """
    return self.__out_multicast_pkts
      
  def _set_out_multicast_pkts(self, v, load=False):
    """
    Setter method for out_multicast_pkts, mapped from YANG variable /interfaces_state/interface/statistics/out_multicast_pkts (yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_multicast_pkts is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_multicast_pkts() directly.

    YANG Description: The total number of packets that higher-level protocols
requested be transmitted, and that were addressed to a
multicast address at this sub-layer, including those
that were discarded or not sent.  For a MAC-layer
protocol, this includes both Group and Functional
addresses.

Discontinuities in the value of this counter can occur
at re-initialization of the management system, and at
other times as indicated by the value of
'discontinuity-time'.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-multicast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_multicast_pkts must be of a type compatible with yang:counter64""",
          'defined-type': "yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-multicast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)""",
        })

    self.__out_multicast_pkts = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_multicast_pkts(self):
    self.__out_multicast_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-multicast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter64', is_config=False)


  def _get_out_discards(self):
    """
    Getter method for out_discards, mapped from YANG variable /interfaces_state/interface/statistics/out_discards (yang:counter32)

    YANG Description: The number of outbound packets that were chosen to be
discarded even though no errors had been detected to
prevent their being transmitted.  One possible reason
for discarding such a packet could be to free up buffer
space.

Discontinuities in the value of this counter can occur
at re-initialization of the management system, and at
other times as indicated by the value of
'discontinuity-time'.
    """
    return self.__out_discards
      
  def _set_out_discards(self, v, load=False):
    """
    Setter method for out_discards, mapped from YANG variable /interfaces_state/interface/statistics/out_discards (yang:counter32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_discards is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_discards() directly.

    YANG Description: The number of outbound packets that were chosen to be
discarded even though no errors had been detected to
prevent their being transmitted.  One possible reason
for discarding such a packet could be to free up buffer
space.

Discontinuities in the value of this counter can occur
at re-initialization of the management system, and at
other times as indicated by the value of
'discontinuity-time'.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="out-discards", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_discards must be of a type compatible with yang:counter32""",
          'defined-type': "yang:counter32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="out-discards", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter32', is_config=False)""",
        })

    self.__out_discards = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_discards(self):
    self.__out_discards = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="out-discards", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter32', is_config=False)


  def _get_out_errors(self):
    """
    Getter method for out_errors, mapped from YANG variable /interfaces_state/interface/statistics/out_errors (yang:counter32)

    YANG Description: For packet-oriented interfaces, the number of outbound
packets that could not be transmitted because of errors.
For character-oriented or fixed-length interfaces, the
number of outbound transmission units that could not be
transmitted because of errors.

Discontinuities in the value of this counter can occur
at re-initialization of the management system, and at
other times as indicated by the value of
'discontinuity-time'.
    """
    return self.__out_errors
      
  def _set_out_errors(self, v, load=False):
    """
    Setter method for out_errors, mapped from YANG variable /interfaces_state/interface/statistics/out_errors (yang:counter32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_errors is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_errors() directly.

    YANG Description: For packet-oriented interfaces, the number of outbound
packets that could not be transmitted because of errors.
For character-oriented or fixed-length interfaces, the
number of outbound transmission units that could not be
transmitted because of errors.

Discontinuities in the value of this counter can occur
at re-initialization of the management system, and at
other times as indicated by the value of
'discontinuity-time'.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="out-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_errors must be of a type compatible with yang:counter32""",
          'defined-type': "yang:counter32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="out-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter32', is_config=False)""",
        })

    self.__out_errors = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_errors(self):
    self.__out_errors = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="out-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:counter32', is_config=False)

  discontinuity_time = __builtin__.property(_get_discontinuity_time)
  in_octets = __builtin__.property(_get_in_octets)
  in_unicast_pkts = __builtin__.property(_get_in_unicast_pkts)
  in_broadcast_pkts = __builtin__.property(_get_in_broadcast_pkts)
  in_multicast_pkts = __builtin__.property(_get_in_multicast_pkts)
  in_discards = __builtin__.property(_get_in_discards)
  in_errors = __builtin__.property(_get_in_errors)
  in_unknown_protos = __builtin__.property(_get_in_unknown_protos)
  out_octets = __builtin__.property(_get_out_octets)
  out_unicast_pkts = __builtin__.property(_get_out_unicast_pkts)
  out_broadcast_pkts = __builtin__.property(_get_out_broadcast_pkts)
  out_multicast_pkts = __builtin__.property(_get_out_multicast_pkts)
  out_discards = __builtin__.property(_get_out_discards)
  out_errors = __builtin__.property(_get_out_errors)


  _pyangbind_elements = OrderedDict([('discontinuity_time', discontinuity_time), ('in_octets', in_octets), ('in_unicast_pkts', in_unicast_pkts), ('in_broadcast_pkts', in_broadcast_pkts), ('in_multicast_pkts', in_multicast_pkts), ('in_discards', in_discards), ('in_errors', in_errors), ('in_unknown_protos', in_unknown_protos), ('out_octets', out_octets), ('out_unicast_pkts', out_unicast_pkts), ('out_broadcast_pkts', out_broadcast_pkts), ('out_multicast_pkts', out_multicast_pkts), ('out_discards', out_discards), ('out_errors', out_errors), ])


class yc_address_ietf_interfaces__interfaces_state_interface_ipv4_address(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-interfaces - based on the path /interfaces-state/interface/ipv4/address. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The list of IPv4 addresses on the interface.
  """
  __slots__ = ('_path_helper', '_extmethods', '__ip','__prefix_length','__netmask','__origin',)

  _yang_name = 'address'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ip = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='inet:ipv4-address-no-zone', is_config=False)
    self.__prefix_length = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..32']}), is_leaf=True, yang_name="prefix-length", parent=self, choice=('subnet', 'prefix-length'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='uint8', is_config=False)
    self.__netmask = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'}), is_leaf=True, yang_name="netmask", parent=self, choice=('subnet', 'netmask'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='yang:dotted-quad', is_config=False)
    self.__origin = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'other': {}, 'static': {}, 'dhcp': {}, 'link-layer': {}, 'random': {}},), is_leaf=True, yang_name="origin", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='ip-address-origin', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces-state', 'interface', 'ipv4', 'address']

  def _get_ip(self):
    """
    Getter method for ip, mapped from YANG variable /interfaces_state/interface/ipv4/address/ip (inet:ipv4-address-no-zone)

    YANG Description: The IPv4 address on the interface.
    """
    return self.__ip
      
  def _set_ip(self, v, load=False):
    """
    Setter method for ip, mapped from YANG variable /interfaces_state/interface/ipv4/address/ip (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip() directly.

    YANG Description: The IPv4 address on the interface.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='inet:ipv4-address-no-zone', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='inet:ipv4-address-no-zone', is_config=False)""",
        })

    self.__ip = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip(self):
    self.__ip = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='inet:ipv4-address-no-zone', is_config=False)


  def _get_prefix_length(self):
    """
    Getter method for prefix_length, mapped from YANG variable /interfaces_state/interface/ipv4/address/prefix_length (uint8)

    YANG Description: The length of the subnet prefix.
    """
    return self.__prefix_length
      
  def _set_prefix_length(self, v, load=False):
    """
    Setter method for prefix_length, mapped from YANG variable /interfaces_state/interface/ipv4/address/prefix_length (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prefix_length is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prefix_length() directly.

    YANG Description: The length of the subnet prefix.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..32']}), is_leaf=True, yang_name="prefix-length", parent=self, choice=('subnet', 'prefix-length'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prefix_length must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..32']}), is_leaf=True, yang_name="prefix-length", parent=self, choice=('subnet', 'prefix-length'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='uint8', is_config=False)""",
        })

    self.__prefix_length = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prefix_length(self):
    self.__prefix_length = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..32']}), is_leaf=True, yang_name="prefix-length", parent=self, choice=('subnet', 'prefix-length'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='uint8', is_config=False)


  def _get_netmask(self):
    """
    Getter method for netmask, mapped from YANG variable /interfaces_state/interface/ipv4/address/netmask (yang:dotted-quad)

    YANG Description: The subnet specified as a netmask.
    """
    return self.__netmask
      
  def _set_netmask(self, v, load=False):
    """
    Setter method for netmask, mapped from YANG variable /interfaces_state/interface/ipv4/address/netmask (yang:dotted-quad)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_netmask is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_netmask() directly.

    YANG Description: The subnet specified as a netmask.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'}), is_leaf=True, yang_name="netmask", parent=self, choice=('subnet', 'netmask'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='yang:dotted-quad', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """netmask must be of a type compatible with yang:dotted-quad""",
          'defined-type': "yang:dotted-quad",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'}), is_leaf=True, yang_name="netmask", parent=self, choice=('subnet', 'netmask'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='yang:dotted-quad', is_config=False)""",
        })

    self.__netmask = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_netmask(self):
    self.__netmask = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'}), is_leaf=True, yang_name="netmask", parent=self, choice=('subnet', 'netmask'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='yang:dotted-quad', is_config=False)


  def _get_origin(self):
    """
    Getter method for origin, mapped from YANG variable /interfaces_state/interface/ipv4/address/origin (ip-address-origin)

    YANG Description: The origin of this address.
    """
    return self.__origin
      
  def _set_origin(self, v, load=False):
    """
    Setter method for origin, mapped from YANG variable /interfaces_state/interface/ipv4/address/origin (ip-address-origin)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_origin is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_origin() directly.

    YANG Description: The origin of this address.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'other': {}, 'static': {}, 'dhcp': {}, 'link-layer': {}, 'random': {}},), is_leaf=True, yang_name="origin", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='ip-address-origin', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """origin must be of a type compatible with ip-address-origin""",
          'defined-type': "ietf-ip:ip-address-origin",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'other': {}, 'static': {}, 'dhcp': {}, 'link-layer': {}, 'random': {}},), is_leaf=True, yang_name="origin", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='ip-address-origin', is_config=False)""",
        })

    self.__origin = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_origin(self):
    self.__origin = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'other': {}, 'static': {}, 'dhcp': {}, 'link-layer': {}, 'random': {}},), is_leaf=True, yang_name="origin", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='ip-address-origin', is_config=False)

  ip = __builtin__.property(_get_ip)
  prefix_length = __builtin__.property(_get_prefix_length)
  netmask = __builtin__.property(_get_netmask)
  origin = __builtin__.property(_get_origin)

  __choices__ = {'subnet': {'prefix-length': ['prefix_length'], 'netmask': ['netmask']}}
  _pyangbind_elements = OrderedDict([('ip', ip), ('prefix_length', prefix_length), ('netmask', netmask), ('origin', origin), ])


class yc_neighbor_ietf_interfaces__interfaces_state_interface_ipv4_neighbor(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-interfaces - based on the path /interfaces-state/interface/ipv4/neighbor. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: A list of mappings from IPv4 addresses to
link-layer addresses.

This list represents the ARP Cache.
  """
  __slots__ = ('_path_helper', '_extmethods', '__ip','__link_layer_address','__origin',)

  _yang_name = 'neighbor'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ip = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='inet:ipv4-address-no-zone', is_config=False)
    self.__link_layer_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9a-fA-F]{2}(:[0-9a-fA-F]{2})*)?'}), is_leaf=True, yang_name="link-layer-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='yang:phys-address', is_config=False)
    self.__origin = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'other': {}, 'static': {}, 'dynamic': {}},), is_leaf=True, yang_name="origin", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='neighbor-origin', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces-state', 'interface', 'ipv4', 'neighbor']

  def _get_ip(self):
    """
    Getter method for ip, mapped from YANG variable /interfaces_state/interface/ipv4/neighbor/ip (inet:ipv4-address-no-zone)

    YANG Description: The IPv4 address of the neighbor node.
    """
    return self.__ip
      
  def _set_ip(self, v, load=False):
    """
    Setter method for ip, mapped from YANG variable /interfaces_state/interface/ipv4/neighbor/ip (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip() directly.

    YANG Description: The IPv4 address of the neighbor node.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='inet:ipv4-address-no-zone', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='inet:ipv4-address-no-zone', is_config=False)""",
        })

    self.__ip = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip(self):
    self.__ip = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='inet:ipv4-address-no-zone', is_config=False)


  def _get_link_layer_address(self):
    """
    Getter method for link_layer_address, mapped from YANG variable /interfaces_state/interface/ipv4/neighbor/link_layer_address (yang:phys-address)

    YANG Description: The link-layer address of the neighbor node.
    """
    return self.__link_layer_address
      
  def _set_link_layer_address(self, v, load=False):
    """
    Setter method for link_layer_address, mapped from YANG variable /interfaces_state/interface/ipv4/neighbor/link_layer_address (yang:phys-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_link_layer_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_link_layer_address() directly.

    YANG Description: The link-layer address of the neighbor node.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9a-fA-F]{2}(:[0-9a-fA-F]{2})*)?'}), is_leaf=True, yang_name="link-layer-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='yang:phys-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """link_layer_address must be of a type compatible with yang:phys-address""",
          'defined-type': "yang:phys-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9a-fA-F]{2}(:[0-9a-fA-F]{2})*)?'}), is_leaf=True, yang_name="link-layer-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='yang:phys-address', is_config=False)""",
        })

    self.__link_layer_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_link_layer_address(self):
    self.__link_layer_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9a-fA-F]{2}(:[0-9a-fA-F]{2})*)?'}), is_leaf=True, yang_name="link-layer-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='yang:phys-address', is_config=False)


  def _get_origin(self):
    """
    Getter method for origin, mapped from YANG variable /interfaces_state/interface/ipv4/neighbor/origin (neighbor-origin)

    YANG Description: The origin of this neighbor entry.
    """
    return self.__origin
      
  def _set_origin(self, v, load=False):
    """
    Setter method for origin, mapped from YANG variable /interfaces_state/interface/ipv4/neighbor/origin (neighbor-origin)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_origin is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_origin() directly.

    YANG Description: The origin of this neighbor entry.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'other': {}, 'static': {}, 'dynamic': {}},), is_leaf=True, yang_name="origin", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='neighbor-origin', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """origin must be of a type compatible with neighbor-origin""",
          'defined-type': "ietf-ip:neighbor-origin",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'other': {}, 'static': {}, 'dynamic': {}},), is_leaf=True, yang_name="origin", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='neighbor-origin', is_config=False)""",
        })

    self.__origin = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_origin(self):
    self.__origin = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'other': {}, 'static': {}, 'dynamic': {}},), is_leaf=True, yang_name="origin", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='neighbor-origin', is_config=False)

  ip = __builtin__.property(_get_ip)
  link_layer_address = __builtin__.property(_get_link_layer_address)
  origin = __builtin__.property(_get_origin)


  _pyangbind_elements = OrderedDict([('ip', ip), ('link_layer_address', link_layer_address), ('origin', origin), ])


class yc_ipv4_ietf_interfaces__interfaces_state_interface_ipv4(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-interfaces - based on the path /interfaces-state/interface/ipv4. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Interface-specific parameters for the IPv4 address family.
  """
  __slots__ = ('_path_helper', '_extmethods', '__forwarding','__mtu','__address','__neighbor',)

  _yang_name = 'ipv4'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__forwarding = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="forwarding", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='boolean', is_config=False)
    self.__mtu = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['68..max']}), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='uint16', is_config=False)
    self.__address = YANGDynClass(base=YANGListType("ip",yc_address_ietf_interfaces__interfaces_state_interface_ipv4_address, yang_name="address", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip', extensions=None), is_container='list', yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='list', is_config=False)
    self.__neighbor = YANGDynClass(base=YANGListType("ip",yc_neighbor_ietf_interfaces__interfaces_state_interface_ipv4_neighbor, yang_name="neighbor", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip', extensions=None), is_container='list', yang_name="neighbor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces-state', 'interface', 'ipv4']

  def _get_forwarding(self):
    """
    Getter method for forwarding, mapped from YANG variable /interfaces_state/interface/ipv4/forwarding (boolean)

    YANG Description: Indicates whether IPv4 packet forwarding is enabled or
disabled on this interface.
    """
    return self.__forwarding
      
  def _set_forwarding(self, v, load=False):
    """
    Setter method for forwarding, mapped from YANG variable /interfaces_state/interface/ipv4/forwarding (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_forwarding is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_forwarding() directly.

    YANG Description: Indicates whether IPv4 packet forwarding is enabled or
disabled on this interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="forwarding", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """forwarding must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="forwarding", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='boolean', is_config=False)""",
        })

    self.__forwarding = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_forwarding(self):
    self.__forwarding = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="forwarding", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='boolean', is_config=False)


  def _get_mtu(self):
    """
    Getter method for mtu, mapped from YANG variable /interfaces_state/interface/ipv4/mtu (uint16)

    YANG Description: The size, in octets, of the largest IPv4 packet that the
interface will send and receive.
    """
    return self.__mtu
      
  def _set_mtu(self, v, load=False):
    """
    Setter method for mtu, mapped from YANG variable /interfaces_state/interface/ipv4/mtu (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mtu is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mtu() directly.

    YANG Description: The size, in octets, of the largest IPv4 packet that the
interface will send and receive.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['68..max']}), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mtu must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['68..max']}), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='uint16', is_config=False)""",
        })

    self.__mtu = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mtu(self):
    self.__mtu = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['68..max']}), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='uint16', is_config=False)


  def _get_address(self):
    """
    Getter method for address, mapped from YANG variable /interfaces_state/interface/ipv4/address (list)

    YANG Description: The list of IPv4 addresses on the interface.
    """
    return self.__address
      
  def _set_address(self, v, load=False):
    """
    Setter method for address, mapped from YANG variable /interfaces_state/interface/ipv4/address (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_address() directly.

    YANG Description: The list of IPv4 addresses on the interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("ip",yc_address_ietf_interfaces__interfaces_state_interface_ipv4_address, yang_name="address", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip', extensions=None), is_container='list', yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """address must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("ip",yc_address_ietf_interfaces__interfaces_state_interface_ipv4_address, yang_name="address", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip', extensions=None), is_container='list', yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='list', is_config=False)""",
        })

    self.__address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_address(self):
    self.__address = YANGDynClass(base=YANGListType("ip",yc_address_ietf_interfaces__interfaces_state_interface_ipv4_address, yang_name="address", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip', extensions=None), is_container='list', yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='list', is_config=False)


  def _get_neighbor(self):
    """
    Getter method for neighbor, mapped from YANG variable /interfaces_state/interface/ipv4/neighbor (list)

    YANG Description: A list of mappings from IPv4 addresses to
link-layer addresses.

This list represents the ARP Cache.
    """
    return self.__neighbor
      
  def _set_neighbor(self, v, load=False):
    """
    Setter method for neighbor, mapped from YANG variable /interfaces_state/interface/ipv4/neighbor (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_neighbor is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_neighbor() directly.

    YANG Description: A list of mappings from IPv4 addresses to
link-layer addresses.

This list represents the ARP Cache.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("ip",yc_neighbor_ietf_interfaces__interfaces_state_interface_ipv4_neighbor, yang_name="neighbor", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip', extensions=None), is_container='list', yang_name="neighbor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """neighbor must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("ip",yc_neighbor_ietf_interfaces__interfaces_state_interface_ipv4_neighbor, yang_name="neighbor", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip', extensions=None), is_container='list', yang_name="neighbor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='list', is_config=False)""",
        })

    self.__neighbor = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_neighbor(self):
    self.__neighbor = YANGDynClass(base=YANGListType("ip",yc_neighbor_ietf_interfaces__interfaces_state_interface_ipv4_neighbor, yang_name="neighbor", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip', extensions=None), is_container='list', yang_name="neighbor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='list', is_config=False)

  forwarding = __builtin__.property(_get_forwarding)
  mtu = __builtin__.property(_get_mtu)
  address = __builtin__.property(_get_address) # type: yc_address_ietf_interfaces__interfaces_state_interface_ipv4_address
  neighbor = __builtin__.property(_get_neighbor) # type: yc_neighbor_ietf_interfaces__interfaces_state_interface_ipv4_neighbor


  _pyangbind_elements = OrderedDict([('forwarding', forwarding), ('mtu', mtu), ('address', address), ('neighbor', neighbor), ])


class yc_address_ietf_interfaces__interfaces_state_interface_ipv6_address(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-interfaces - based on the path /interfaces-state/interface/ipv6/address. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The list of IPv6 addresses on the interface.
  """
  __slots__ = ('_path_helper', '_extmethods', '__ip','__prefix_length','__origin','__status',)

  _yang_name = 'address'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ip = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='inet:ipv6-address-no-zone', is_config=False)
    self.__prefix_length = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..128']}), is_leaf=True, yang_name="prefix-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='uint8', is_config=False)
    self.__origin = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'other': {}, 'static': {}, 'dhcp': {}, 'link-layer': {}, 'random': {}},), is_leaf=True, yang_name="origin", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='ip-address-origin', is_config=False)
    self.__status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'preferred': {}, 'deprecated': {}, 'invalid': {}, 'inaccessible': {}, 'unknown': {}, 'tentative': {}, 'duplicate': {}, 'optimistic': {}},), is_leaf=True, yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='enumeration', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces-state', 'interface', 'ipv6', 'address']

  def _get_ip(self):
    """
    Getter method for ip, mapped from YANG variable /interfaces_state/interface/ipv6/address/ip (inet:ipv6-address-no-zone)

    YANG Description: The IPv6 address on the interface.
    """
    return self.__ip
      
  def _set_ip(self, v, load=False):
    """
    Setter method for ip, mapped from YANG variable /interfaces_state/interface/ipv6/address/ip (inet:ipv6-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip() directly.

    YANG Description: The IPv6 address on the interface.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='inet:ipv6-address-no-zone', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip must be of a type compatible with inet:ipv6-address-no-zone""",
          'defined-type': "inet:ipv6-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='inet:ipv6-address-no-zone', is_config=False)""",
        })

    self.__ip = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip(self):
    self.__ip = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='inet:ipv6-address-no-zone', is_config=False)


  def _get_prefix_length(self):
    """
    Getter method for prefix_length, mapped from YANG variable /interfaces_state/interface/ipv6/address/prefix_length (uint8)

    YANG Description: The length of the subnet prefix.
    """
    return self.__prefix_length
      
  def _set_prefix_length(self, v, load=False):
    """
    Setter method for prefix_length, mapped from YANG variable /interfaces_state/interface/ipv6/address/prefix_length (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prefix_length is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prefix_length() directly.

    YANG Description: The length of the subnet prefix.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..128']}), is_leaf=True, yang_name="prefix-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prefix_length must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..128']}), is_leaf=True, yang_name="prefix-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='uint8', is_config=False)""",
        })

    self.__prefix_length = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prefix_length(self):
    self.__prefix_length = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..128']}), is_leaf=True, yang_name="prefix-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='uint8', is_config=False)


  def _get_origin(self):
    """
    Getter method for origin, mapped from YANG variable /interfaces_state/interface/ipv6/address/origin (ip-address-origin)

    YANG Description: The origin of this address.
    """
    return self.__origin
      
  def _set_origin(self, v, load=False):
    """
    Setter method for origin, mapped from YANG variable /interfaces_state/interface/ipv6/address/origin (ip-address-origin)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_origin is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_origin() directly.

    YANG Description: The origin of this address.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'other': {}, 'static': {}, 'dhcp': {}, 'link-layer': {}, 'random': {}},), is_leaf=True, yang_name="origin", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='ip-address-origin', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """origin must be of a type compatible with ip-address-origin""",
          'defined-type': "ietf-ip:ip-address-origin",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'other': {}, 'static': {}, 'dhcp': {}, 'link-layer': {}, 'random': {}},), is_leaf=True, yang_name="origin", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='ip-address-origin', is_config=False)""",
        })

    self.__origin = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_origin(self):
    self.__origin = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'other': {}, 'static': {}, 'dhcp': {}, 'link-layer': {}, 'random': {}},), is_leaf=True, yang_name="origin", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='ip-address-origin', is_config=False)


  def _get_status(self):
    """
    Getter method for status, mapped from YANG variable /interfaces_state/interface/ipv6/address/status (enumeration)

    YANG Description: The status of an address.  Most of the states correspond
to states from the IPv6 Stateless Address
Autoconfiguration protocol.
    """
    return self.__status
      
  def _set_status(self, v, load=False):
    """
    Setter method for status, mapped from YANG variable /interfaces_state/interface/ipv6/address/status (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_status() directly.

    YANG Description: The status of an address.  Most of the states correspond
to states from the IPv6 Stateless Address
Autoconfiguration protocol.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'preferred': {}, 'deprecated': {}, 'invalid': {}, 'inaccessible': {}, 'unknown': {}, 'tentative': {}, 'duplicate': {}, 'optimistic': {}},), is_leaf=True, yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='enumeration', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """status must be of a type compatible with enumeration""",
          'defined-type': "ietf-ip:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'preferred': {}, 'deprecated': {}, 'invalid': {}, 'inaccessible': {}, 'unknown': {}, 'tentative': {}, 'duplicate': {}, 'optimistic': {}},), is_leaf=True, yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='enumeration', is_config=False)""",
        })

    self.__status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_status(self):
    self.__status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'preferred': {}, 'deprecated': {}, 'invalid': {}, 'inaccessible': {}, 'unknown': {}, 'tentative': {}, 'duplicate': {}, 'optimistic': {}},), is_leaf=True, yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='enumeration', is_config=False)

  ip = __builtin__.property(_get_ip)
  prefix_length = __builtin__.property(_get_prefix_length)
  origin = __builtin__.property(_get_origin)
  status = __builtin__.property(_get_status)


  _pyangbind_elements = OrderedDict([('ip', ip), ('prefix_length', prefix_length), ('origin', origin), ('status', status), ])


class yc_neighbor_ietf_interfaces__interfaces_state_interface_ipv6_neighbor(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-interfaces - based on the path /interfaces-state/interface/ipv6/neighbor. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: A list of mappings from IPv6 addresses to
link-layer addresses.

This list represents the Neighbor Cache.
  """
  __slots__ = ('_path_helper', '_extmethods', '__ip','__link_layer_address','__origin','__is_router','__state',)

  _yang_name = 'neighbor'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ip = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='inet:ipv6-address-no-zone', is_config=False)
    self.__link_layer_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9a-fA-F]{2}(:[0-9a-fA-F]{2})*)?'}), is_leaf=True, yang_name="link-layer-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='yang:phys-address', is_config=False)
    self.__origin = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'other': {}, 'static': {}, 'dynamic': {}},), is_leaf=True, yang_name="origin", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='neighbor-origin', is_config=False)
    self.__is_router = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is-router", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='empty', is_config=False)
    self.__state = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'incomplete': {}, 'reachable': {}, 'stale': {}, 'delay': {}, 'probe': {}},), is_leaf=True, yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='enumeration', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces-state', 'interface', 'ipv6', 'neighbor']

  def _get_ip(self):
    """
    Getter method for ip, mapped from YANG variable /interfaces_state/interface/ipv6/neighbor/ip (inet:ipv6-address-no-zone)

    YANG Description: The IPv6 address of the neighbor node.
    """
    return self.__ip
      
  def _set_ip(self, v, load=False):
    """
    Setter method for ip, mapped from YANG variable /interfaces_state/interface/ipv6/neighbor/ip (inet:ipv6-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip() directly.

    YANG Description: The IPv6 address of the neighbor node.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='inet:ipv6-address-no-zone', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip must be of a type compatible with inet:ipv6-address-no-zone""",
          'defined-type': "inet:ipv6-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='inet:ipv6-address-no-zone', is_config=False)""",
        })

    self.__ip = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip(self):
    self.__ip = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='inet:ipv6-address-no-zone', is_config=False)


  def _get_link_layer_address(self):
    """
    Getter method for link_layer_address, mapped from YANG variable /interfaces_state/interface/ipv6/neighbor/link_layer_address (yang:phys-address)

    YANG Description: The link-layer address of the neighbor node.
    """
    return self.__link_layer_address
      
  def _set_link_layer_address(self, v, load=False):
    """
    Setter method for link_layer_address, mapped from YANG variable /interfaces_state/interface/ipv6/neighbor/link_layer_address (yang:phys-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_link_layer_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_link_layer_address() directly.

    YANG Description: The link-layer address of the neighbor node.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9a-fA-F]{2}(:[0-9a-fA-F]{2})*)?'}), is_leaf=True, yang_name="link-layer-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='yang:phys-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """link_layer_address must be of a type compatible with yang:phys-address""",
          'defined-type': "yang:phys-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9a-fA-F]{2}(:[0-9a-fA-F]{2})*)?'}), is_leaf=True, yang_name="link-layer-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='yang:phys-address', is_config=False)""",
        })

    self.__link_layer_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_link_layer_address(self):
    self.__link_layer_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9a-fA-F]{2}(:[0-9a-fA-F]{2})*)?'}), is_leaf=True, yang_name="link-layer-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='yang:phys-address', is_config=False)


  def _get_origin(self):
    """
    Getter method for origin, mapped from YANG variable /interfaces_state/interface/ipv6/neighbor/origin (neighbor-origin)

    YANG Description: The origin of this neighbor entry.
    """
    return self.__origin
      
  def _set_origin(self, v, load=False):
    """
    Setter method for origin, mapped from YANG variable /interfaces_state/interface/ipv6/neighbor/origin (neighbor-origin)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_origin is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_origin() directly.

    YANG Description: The origin of this neighbor entry.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'other': {}, 'static': {}, 'dynamic': {}},), is_leaf=True, yang_name="origin", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='neighbor-origin', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """origin must be of a type compatible with neighbor-origin""",
          'defined-type': "ietf-ip:neighbor-origin",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'other': {}, 'static': {}, 'dynamic': {}},), is_leaf=True, yang_name="origin", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='neighbor-origin', is_config=False)""",
        })

    self.__origin = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_origin(self):
    self.__origin = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'other': {}, 'static': {}, 'dynamic': {}},), is_leaf=True, yang_name="origin", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='neighbor-origin', is_config=False)


  def _get_is_router(self):
    """
    Getter method for is_router, mapped from YANG variable /interfaces_state/interface/ipv6/neighbor/is_router (empty)

    YANG Description: Indicates that the neighbor node acts as a router.
    """
    return self.__is_router
      
  def _set_is_router(self, v, load=False):
    """
    Setter method for is_router, mapped from YANG variable /interfaces_state/interface/ipv6/neighbor/is_router (empty)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_is_router is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_is_router() directly.

    YANG Description: Indicates that the neighbor node acts as a router.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="is-router", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='empty', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """is_router must be of a type compatible with empty""",
          'defined-type': "empty",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is-router", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='empty', is_config=False)""",
        })

    self.__is_router = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_is_router(self):
    self.__is_router = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is-router", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='empty', is_config=False)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /interfaces_state/interface/ipv6/neighbor/state (enumeration)

    YANG Description: The Neighbor Unreachability Detection state of this
entry.
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /interfaces_state/interface/ipv6/neighbor/state (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: The Neighbor Unreachability Detection state of this
entry.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'incomplete': {}, 'reachable': {}, 'stale': {}, 'delay': {}, 'probe': {}},), is_leaf=True, yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='enumeration', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with enumeration""",
          'defined-type': "ietf-ip:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'incomplete': {}, 'reachable': {}, 'stale': {}, 'delay': {}, 'probe': {}},), is_leaf=True, yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='enumeration', is_config=False)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'incomplete': {}, 'reachable': {}, 'stale': {}, 'delay': {}, 'probe': {}},), is_leaf=True, yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='enumeration', is_config=False)

  ip = __builtin__.property(_get_ip)
  link_layer_address = __builtin__.property(_get_link_layer_address)
  origin = __builtin__.property(_get_origin)
  is_router = __builtin__.property(_get_is_router)
  state = __builtin__.property(_get_state)


  _pyangbind_elements = OrderedDict([('ip', ip), ('link_layer_address', link_layer_address), ('origin', origin), ('is_router', is_router), ('state', state), ])


class yc_ipv6_ietf_interfaces__interfaces_state_interface_ipv6(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-interfaces - based on the path /interfaces-state/interface/ipv6. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Parameters for the IPv6 address family.
  """
  __slots__ = ('_path_helper', '_extmethods', '__forwarding','__mtu','__address','__neighbor',)

  _yang_name = 'ipv6'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__forwarding = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="forwarding", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='boolean', is_config=False)
    self.__mtu = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1280..max']}), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='uint32', is_config=False)
    self.__address = YANGDynClass(base=YANGListType("ip",yc_address_ietf_interfaces__interfaces_state_interface_ipv6_address, yang_name="address", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip', extensions=None), is_container='list', yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='list', is_config=False)
    self.__neighbor = YANGDynClass(base=YANGListType("ip",yc_neighbor_ietf_interfaces__interfaces_state_interface_ipv6_neighbor, yang_name="neighbor", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip', extensions=None), is_container='list', yang_name="neighbor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces-state', 'interface', 'ipv6']

  def _get_forwarding(self):
    """
    Getter method for forwarding, mapped from YANG variable /interfaces_state/interface/ipv6/forwarding (boolean)

    YANG Description: Indicates whether IPv6 packet forwarding is enabled or
disabled on this interface.
    """
    return self.__forwarding
      
  def _set_forwarding(self, v, load=False):
    """
    Setter method for forwarding, mapped from YANG variable /interfaces_state/interface/ipv6/forwarding (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_forwarding is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_forwarding() directly.

    YANG Description: Indicates whether IPv6 packet forwarding is enabled or
disabled on this interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="forwarding", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """forwarding must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="forwarding", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='boolean', is_config=False)""",
        })

    self.__forwarding = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_forwarding(self):
    self.__forwarding = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="forwarding", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='boolean', is_config=False)


  def _get_mtu(self):
    """
    Getter method for mtu, mapped from YANG variable /interfaces_state/interface/ipv6/mtu (uint32)

    YANG Description: The size, in octets, of the largest IPv6 packet that the
interface will send and receive.
    """
    return self.__mtu
      
  def _set_mtu(self, v, load=False):
    """
    Setter method for mtu, mapped from YANG variable /interfaces_state/interface/ipv6/mtu (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mtu is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mtu() directly.

    YANG Description: The size, in octets, of the largest IPv6 packet that the
interface will send and receive.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1280..max']}), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mtu must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1280..max']}), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='uint32', is_config=False)""",
        })

    self.__mtu = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mtu(self):
    self.__mtu = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1280..max']}), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='uint32', is_config=False)


  def _get_address(self):
    """
    Getter method for address, mapped from YANG variable /interfaces_state/interface/ipv6/address (list)

    YANG Description: The list of IPv6 addresses on the interface.
    """
    return self.__address
      
  def _set_address(self, v, load=False):
    """
    Setter method for address, mapped from YANG variable /interfaces_state/interface/ipv6/address (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_address() directly.

    YANG Description: The list of IPv6 addresses on the interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("ip",yc_address_ietf_interfaces__interfaces_state_interface_ipv6_address, yang_name="address", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip', extensions=None), is_container='list', yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """address must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("ip",yc_address_ietf_interfaces__interfaces_state_interface_ipv6_address, yang_name="address", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip', extensions=None), is_container='list', yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='list', is_config=False)""",
        })

    self.__address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_address(self):
    self.__address = YANGDynClass(base=YANGListType("ip",yc_address_ietf_interfaces__interfaces_state_interface_ipv6_address, yang_name="address", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip', extensions=None), is_container='list', yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='list', is_config=False)


  def _get_neighbor(self):
    """
    Getter method for neighbor, mapped from YANG variable /interfaces_state/interface/ipv6/neighbor (list)

    YANG Description: A list of mappings from IPv6 addresses to
link-layer addresses.

This list represents the Neighbor Cache.
    """
    return self.__neighbor
      
  def _set_neighbor(self, v, load=False):
    """
    Setter method for neighbor, mapped from YANG variable /interfaces_state/interface/ipv6/neighbor (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_neighbor is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_neighbor() directly.

    YANG Description: A list of mappings from IPv6 addresses to
link-layer addresses.

This list represents the Neighbor Cache.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("ip",yc_neighbor_ietf_interfaces__interfaces_state_interface_ipv6_neighbor, yang_name="neighbor", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip', extensions=None), is_container='list', yang_name="neighbor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """neighbor must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("ip",yc_neighbor_ietf_interfaces__interfaces_state_interface_ipv6_neighbor, yang_name="neighbor", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip', extensions=None), is_container='list', yang_name="neighbor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='list', is_config=False)""",
        })

    self.__neighbor = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_neighbor(self):
    self.__neighbor = YANGDynClass(base=YANGListType("ip",yc_neighbor_ietf_interfaces__interfaces_state_interface_ipv6_neighbor, yang_name="neighbor", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip', extensions=None), is_container='list', yang_name="neighbor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='list', is_config=False)

  forwarding = __builtin__.property(_get_forwarding)
  mtu = __builtin__.property(_get_mtu)
  address = __builtin__.property(_get_address) # type: yc_address_ietf_interfaces__interfaces_state_interface_ipv6_address
  neighbor = __builtin__.property(_get_neighbor) # type: yc_neighbor_ietf_interfaces__interfaces_state_interface_ipv6_neighbor


  _pyangbind_elements = OrderedDict([('forwarding', forwarding), ('mtu', mtu), ('address', address), ('neighbor', neighbor), ])


class yc_interface_ietf_interfaces__interfaces_state_interface(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-interfaces - based on the path /interfaces-state/interface. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The list of interfaces on the device.

System-controlled interfaces created by the system are
always present in this list, whether they are configured or
not.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__type','__admin_status','__oper_status','__last_change','__if_index','__phys_address','__higher_layer_if','__lower_layer_if','__speed','__statistics','__ipv4','__ipv6',)

  _yang_name = 'interface'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='string', is_config=False)
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='identityref', is_config=False)
    self.__admin_status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'up': {'value': 1}, 'down': {'value': 2}, 'testing': {'value': 3}},), is_leaf=True, yang_name="admin-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='enumeration', is_config=False)
    self.__oper_status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'up': {'value': 1}, 'down': {'value': 2}, 'testing': {'value': 3}, 'unknown': {'value': 4}, 'dormant': {'value': 5}, 'not-present': {'value': 6}, 'lower-layer-down': {'value': 7}},), is_leaf=True, yang_name="oper-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='enumeration', is_config=False)
    self.__last_change = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="last-change", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:date-and-time', is_config=False)
    self.__if_index = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), restriction_dict={'range': ['1..2147483647']}), is_leaf=True, yang_name="if-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='int32', is_config=False)
    self.__phys_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9a-fA-F]{2}(:[0-9a-fA-F]{2})*)?'}), is_leaf=True, yang_name="phys-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:phys-address', is_config=False)
    self.__higher_layer_if = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="higher-layer-if", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='interface-state-ref', is_config=False)
    self.__lower_layer_if = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="lower-layer-if", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='interface-state-ref', is_config=False)
    self.__speed = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="speed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:gauge64', is_config=False)
    self.__statistics = YANGDynClass(base=yc_statistics_ietf_interfaces__interfaces_state_interface_statistics, is_container='container', yang_name="statistics", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='container', is_config=False)
    self.__ipv4 = YANGDynClass(base=yc_ipv4_ietf_interfaces__interfaces_state_interface_ipv4, is_container='container', yang_name="ipv4", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='container', is_config=False)
    self.__ipv6 = YANGDynClass(base=yc_ipv6_ietf_interfaces__interfaces_state_interface_ipv6, is_container='container', yang_name="ipv6", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces-state', 'interface']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /interfaces_state/interface/name (string)

    YANG Description: The name of the interface.

A server implementation MAY map this leaf to the ifName
MIB object.  Such an implementation needs to use some
mechanism to handle the differences in size and characters
allowed between this leaf and ifName.  The definition of
such a mechanism is outside the scope of this document.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /interfaces_state/interface/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: The name of the interface.

A server implementation MAY map this leaf to the ifName
MIB object.  Such an implementation needs to use some
mechanism to handle the differences in size and characters
allowed between this leaf and ifName.  The definition of
such a mechanism is outside the scope of this document.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='string', is_config=False)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='string', is_config=False)


  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /interfaces_state/interface/type (identityref)

    YANG Description: The type of the interface.
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /interfaces_state/interface/type (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: The type of the interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with identityref""",
          'defined-type': "ietf-interfaces:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='identityref', is_config=False)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='identityref', is_config=False)


  def _get_admin_status(self):
    """
    Getter method for admin_status, mapped from YANG variable /interfaces_state/interface/admin_status (enumeration)

    YANG Description: The desired state of the interface.

This leaf has the same read semantics as ifAdminStatus.
    """
    return self.__admin_status
      
  def _set_admin_status(self, v, load=False):
    """
    Setter method for admin_status, mapped from YANG variable /interfaces_state/interface/admin_status (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_admin_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_admin_status() directly.

    YANG Description: The desired state of the interface.

This leaf has the same read semantics as ifAdminStatus.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'up': {'value': 1}, 'down': {'value': 2}, 'testing': {'value': 3}},), is_leaf=True, yang_name="admin-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='enumeration', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """admin_status must be of a type compatible with enumeration""",
          'defined-type': "ietf-interfaces:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'up': {'value': 1}, 'down': {'value': 2}, 'testing': {'value': 3}},), is_leaf=True, yang_name="admin-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='enumeration', is_config=False)""",
        })

    self.__admin_status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_admin_status(self):
    self.__admin_status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'up': {'value': 1}, 'down': {'value': 2}, 'testing': {'value': 3}},), is_leaf=True, yang_name="admin-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='enumeration', is_config=False)


  def _get_oper_status(self):
    """
    Getter method for oper_status, mapped from YANG variable /interfaces_state/interface/oper_status (enumeration)

    YANG Description: The current operational state of the interface.

This leaf has the same semantics as ifOperStatus.
    """
    return self.__oper_status
      
  def _set_oper_status(self, v, load=False):
    """
    Setter method for oper_status, mapped from YANG variable /interfaces_state/interface/oper_status (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_oper_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_oper_status() directly.

    YANG Description: The current operational state of the interface.

This leaf has the same semantics as ifOperStatus.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'up': {'value': 1}, 'down': {'value': 2}, 'testing': {'value': 3}, 'unknown': {'value': 4}, 'dormant': {'value': 5}, 'not-present': {'value': 6}, 'lower-layer-down': {'value': 7}},), is_leaf=True, yang_name="oper-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='enumeration', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """oper_status must be of a type compatible with enumeration""",
          'defined-type': "ietf-interfaces:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'up': {'value': 1}, 'down': {'value': 2}, 'testing': {'value': 3}, 'unknown': {'value': 4}, 'dormant': {'value': 5}, 'not-present': {'value': 6}, 'lower-layer-down': {'value': 7}},), is_leaf=True, yang_name="oper-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='enumeration', is_config=False)""",
        })

    self.__oper_status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_oper_status(self):
    self.__oper_status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'up': {'value': 1}, 'down': {'value': 2}, 'testing': {'value': 3}, 'unknown': {'value': 4}, 'dormant': {'value': 5}, 'not-present': {'value': 6}, 'lower-layer-down': {'value': 7}},), is_leaf=True, yang_name="oper-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='enumeration', is_config=False)


  def _get_last_change(self):
    """
    Getter method for last_change, mapped from YANG variable /interfaces_state/interface/last_change (yang:date-and-time)

    YANG Description: The time the interface entered its current operational
state.  If the current state was entered prior to the
last re-initialization of the local network management
subsystem, then this node is not present.
    """
    return self.__last_change
      
  def _set_last_change(self, v, load=False):
    """
    Setter method for last_change, mapped from YANG variable /interfaces_state/interface/last_change (yang:date-and-time)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_last_change is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_last_change() directly.

    YANG Description: The time the interface entered its current operational
state.  If the current state was entered prior to the
last re-initialization of the local network management
subsystem, then this node is not present.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="last-change", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:date-and-time', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """last_change must be of a type compatible with yang:date-and-time""",
          'defined-type': "yang:date-and-time",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="last-change", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:date-and-time', is_config=False)""",
        })

    self.__last_change = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_last_change(self):
    self.__last_change = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="last-change", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:date-and-time', is_config=False)


  def _get_if_index(self):
    """
    Getter method for if_index, mapped from YANG variable /interfaces_state/interface/if_index (int32)

    YANG Description: The ifIndex value for the ifEntry represented by this
interface.
    """
    return self.__if_index
      
  def _set_if_index(self, v, load=False):
    """
    Setter method for if_index, mapped from YANG variable /interfaces_state/interface/if_index (int32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_if_index is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_if_index() directly.

    YANG Description: The ifIndex value for the ifEntry represented by this
interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), restriction_dict={'range': ['1..2147483647']}), is_leaf=True, yang_name="if-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='int32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """if_index must be of a type compatible with int32""",
          'defined-type': "int32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), restriction_dict={'range': ['1..2147483647']}), is_leaf=True, yang_name="if-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='int32', is_config=False)""",
        })

    self.__if_index = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_if_index(self):
    self.__if_index = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), restriction_dict={'range': ['1..2147483647']}), is_leaf=True, yang_name="if-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='int32', is_config=False)


  def _get_phys_address(self):
    """
    Getter method for phys_address, mapped from YANG variable /interfaces_state/interface/phys_address (yang:phys-address)

    YANG Description: The interface's address at its protocol sub-layer.  For
example, for an 802.x interface, this object normally
contains a Media Access Control (MAC) address.  The
interface's media-specific modules must define the bit
and byte ordering and the format of the value of this
object.  For interfaces that do not have such an address
(e.g., a serial line), this node is not present.
    """
    return self.__phys_address
      
  def _set_phys_address(self, v, load=False):
    """
    Setter method for phys_address, mapped from YANG variable /interfaces_state/interface/phys_address (yang:phys-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_phys_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_phys_address() directly.

    YANG Description: The interface's address at its protocol sub-layer.  For
example, for an 802.x interface, this object normally
contains a Media Access Control (MAC) address.  The
interface's media-specific modules must define the bit
and byte ordering and the format of the value of this
object.  For interfaces that do not have such an address
(e.g., a serial line), this node is not present.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9a-fA-F]{2}(:[0-9a-fA-F]{2})*)?'}), is_leaf=True, yang_name="phys-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:phys-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """phys_address must be of a type compatible with yang:phys-address""",
          'defined-type': "yang:phys-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9a-fA-F]{2}(:[0-9a-fA-F]{2})*)?'}), is_leaf=True, yang_name="phys-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:phys-address', is_config=False)""",
        })

    self.__phys_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_phys_address(self):
    self.__phys_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9a-fA-F]{2}(:[0-9a-fA-F]{2})*)?'}), is_leaf=True, yang_name="phys-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:phys-address', is_config=False)


  def _get_higher_layer_if(self):
    """
    Getter method for higher_layer_if, mapped from YANG variable /interfaces_state/interface/higher_layer_if (interface-state-ref)

    YANG Description: A list of references to interfaces layered on top of this
interface.
    """
    return self.__higher_layer_if
      
  def _set_higher_layer_if(self, v, load=False):
    """
    Setter method for higher_layer_if, mapped from YANG variable /interfaces_state/interface/higher_layer_if (interface-state-ref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_higher_layer_if is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_higher_layer_if() directly.

    YANG Description: A list of references to interfaces layered on top of this
interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="higher-layer-if", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='interface-state-ref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """higher_layer_if must be of a type compatible with interface-state-ref""",
          'defined-type': "ietf-interfaces:interface-state-ref",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="higher-layer-if", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='interface-state-ref', is_config=False)""",
        })

    self.__higher_layer_if = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_higher_layer_if(self):
    self.__higher_layer_if = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="higher-layer-if", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='interface-state-ref', is_config=False)


  def _get_lower_layer_if(self):
    """
    Getter method for lower_layer_if, mapped from YANG variable /interfaces_state/interface/lower_layer_if (interface-state-ref)

    YANG Description: A list of references to interfaces layered underneath this
interface.
    """
    return self.__lower_layer_if
      
  def _set_lower_layer_if(self, v, load=False):
    """
    Setter method for lower_layer_if, mapped from YANG variable /interfaces_state/interface/lower_layer_if (interface-state-ref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lower_layer_if is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lower_layer_if() directly.

    YANG Description: A list of references to interfaces layered underneath this
interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="lower-layer-if", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='interface-state-ref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lower_layer_if must be of a type compatible with interface-state-ref""",
          'defined-type': "ietf-interfaces:interface-state-ref",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="lower-layer-if", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='interface-state-ref', is_config=False)""",
        })

    self.__lower_layer_if = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lower_layer_if(self):
    self.__lower_layer_if = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="lower-layer-if", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='interface-state-ref', is_config=False)


  def _get_speed(self):
    """
    Getter method for speed, mapped from YANG variable /interfaces_state/interface/speed (yang:gauge64)

    YANG Description: An estimate of the interface's current bandwidth in bits
per second.  For interfaces that do not vary in
bandwidth or for those where no accurate estimation can
be made, this node should contain the nominal bandwidth.
For interfaces that have no concept of bandwidth, this
node is not present.
    """
    return self.__speed
      
  def _set_speed(self, v, load=False):
    """
    Setter method for speed, mapped from YANG variable /interfaces_state/interface/speed (yang:gauge64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_speed is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_speed() directly.

    YANG Description: An estimate of the interface's current bandwidth in bits
per second.  For interfaces that do not vary in
bandwidth or for those where no accurate estimation can
be made, this node should contain the nominal bandwidth.
For interfaces that have no concept of bandwidth, this
node is not present.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="speed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:gauge64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """speed must be of a type compatible with yang:gauge64""",
          'defined-type': "yang:gauge64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="speed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:gauge64', is_config=False)""",
        })

    self.__speed = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_speed(self):
    self.__speed = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="speed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='yang:gauge64', is_config=False)


  def _get_statistics(self):
    """
    Getter method for statistics, mapped from YANG variable /interfaces_state/interface/statistics (container)

    YANG Description: A collection of interface-related statistics objects.
    """
    return self.__statistics
      
  def _set_statistics(self, v, load=False):
    """
    Setter method for statistics, mapped from YANG variable /interfaces_state/interface/statistics (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_statistics is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_statistics() directly.

    YANG Description: A collection of interface-related statistics objects.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_statistics_ietf_interfaces__interfaces_state_interface_statistics, is_container='container', yang_name="statistics", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """statistics must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_statistics_ietf_interfaces__interfaces_state_interface_statistics, is_container='container', yang_name="statistics", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='container', is_config=False)""",
        })

    self.__statistics = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_statistics(self):
    self.__statistics = YANGDynClass(base=yc_statistics_ietf_interfaces__interfaces_state_interface_statistics, is_container='container', yang_name="statistics", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='container', is_config=False)


  def _get_ipv4(self):
    """
    Getter method for ipv4, mapped from YANG variable /interfaces_state/interface/ipv4 (container)

    YANG Description: Interface-specific parameters for the IPv4 address family.
    """
    return self.__ipv4
      
  def _set_ipv4(self, v, load=False):
    """
    Setter method for ipv4, mapped from YANG variable /interfaces_state/interface/ipv4 (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv4 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv4() directly.

    YANG Description: Interface-specific parameters for the IPv4 address family.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ipv4_ietf_interfaces__interfaces_state_interface_ipv4, is_container='container', yang_name="ipv4", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv4 must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ipv4_ietf_interfaces__interfaces_state_interface_ipv4, is_container='container', yang_name="ipv4", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='container', is_config=False)""",
        })

    self.__ipv4 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv4(self):
    self.__ipv4 = YANGDynClass(base=yc_ipv4_ietf_interfaces__interfaces_state_interface_ipv4, is_container='container', yang_name="ipv4", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='container', is_config=False)


  def _get_ipv6(self):
    """
    Getter method for ipv6, mapped from YANG variable /interfaces_state/interface/ipv6 (container)

    YANG Description: Parameters for the IPv6 address family.
    """
    return self.__ipv6
      
  def _set_ipv6(self, v, load=False):
    """
    Setter method for ipv6, mapped from YANG variable /interfaces_state/interface/ipv6 (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv6 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv6() directly.

    YANG Description: Parameters for the IPv6 address family.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ipv6_ietf_interfaces__interfaces_state_interface_ipv6, is_container='container', yang_name="ipv6", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv6 must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ipv6_ietf_interfaces__interfaces_state_interface_ipv6, is_container='container', yang_name="ipv6", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='container', is_config=False)""",
        })

    self.__ipv6 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv6(self):
    self.__ipv6 = YANGDynClass(base=yc_ipv6_ietf_interfaces__interfaces_state_interface_ipv6, is_container='container', yang_name="ipv6", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-ip', defining_module='ietf-ip', yang_type='container', is_config=False)

  name = __builtin__.property(_get_name)
  type = __builtin__.property(_get_type)
  admin_status = __builtin__.property(_get_admin_status)
  oper_status = __builtin__.property(_get_oper_status)
  last_change = __builtin__.property(_get_last_change)
  if_index = __builtin__.property(_get_if_index)
  phys_address = __builtin__.property(_get_phys_address)
  higher_layer_if = __builtin__.property(_get_higher_layer_if)
  lower_layer_if = __builtin__.property(_get_lower_layer_if)
  speed = __builtin__.property(_get_speed)
  statistics = __builtin__.property(_get_statistics) # type: yc_statistics_ietf_interfaces__interfaces_state_interface_statistics
  ipv4 = __builtin__.property(_get_ipv4) # type: yc_ipv4_ietf_interfaces__interfaces_state_interface_ipv4
  ipv6 = __builtin__.property(_get_ipv6) # type: yc_ipv6_ietf_interfaces__interfaces_state_interface_ipv6


  _pyangbind_elements = OrderedDict([('name', name), ('type', type), ('admin_status', admin_status), ('oper_status', oper_status), ('last_change', last_change), ('if_index', if_index), ('phys_address', phys_address), ('higher_layer_if', higher_layer_if), ('lower_layer_if', lower_layer_if), ('speed', speed), ('statistics', statistics), ('ipv4', ipv4), ('ipv6', ipv6), ])


class yc_interfaces_state_ietf_interfaces__interfaces_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-interfaces - based on the path /interfaces-state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Data nodes for the operational state of interfaces.
  """
  __slots__ = ('_path_helper', '_extmethods', '__interface',)

  _yang_name = 'interfaces-state'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__interface = YANGDynClass(base=YANGListType("name",yc_interface_ietf_interfaces__interfaces_state_interface, yang_name="interface", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces-state']

  def _get_interface(self):
    """
    Getter method for interface, mapped from YANG variable /interfaces_state/interface (list)

    YANG Description: The list of interfaces on the device.

System-controlled interfaces created by the system are
always present in this list, whether they are configured or
not.
    """
    return self.__interface
      
  def _set_interface(self, v, load=False):
    """
    Setter method for interface, mapped from YANG variable /interfaces_state/interface (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface() directly.

    YANG Description: The list of interfaces on the device.

System-controlled interfaces created by the system are
always present in this list, whether they are configured or
not.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_interface_ietf_interfaces__interfaces_state_interface, yang_name="interface", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_interface_ietf_interfaces__interfaces_state_interface, yang_name="interface", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='list', is_config=False)""",
        })

    self.__interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface(self):
    self.__interface = YANGDynClass(base=YANGListType("name",yc_interface_ietf_interfaces__interfaces_state_interface, yang_name="interface", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='list', is_config=False)

  interface = __builtin__.property(_get_interface) # type: yc_interface_ietf_interfaces__interfaces_state_interface


  _pyangbind_elements = OrderedDict([('interface', interface), ])


class ietf_interfaces(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-interfaces - based on the path /ietf-interfaces. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module contains a collection of YANG definitions for
managing network interfaces.

Copyright (c) 2018 IETF Trust and the persons identified as
authors of the code.  All rights reserved.

Redistribution and use in source and binary forms, with or
without modification, is permitted pursuant to, and subject
to the license terms contained in, the Simplified BSD License
set forth in Section 4.c of the IETF Trust's Legal Provisions
Relating to IETF Documents
(http://trustee.ietf.org/license-info).

This version of this YANG module is part of RFC XXXX; see
the RFC itself for full legal notices.
  """
  __slots__ = ('_path_helper', '_extmethods', '__interfaces','__interfaces_state',)

  _yang_name = 'ietf-interfaces'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__interfaces = YANGDynClass(base=yc_interfaces_ietf_interfaces__interfaces, is_container='container', yang_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='container', is_config=True)
    self.__interfaces_state = YANGDynClass(base=yc_interfaces_state_ietf_interfaces__interfaces_state, is_container='container', yang_name="interfaces-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_interfaces(self):
    """
    Getter method for interfaces, mapped from YANG variable /interfaces (container)

    YANG Description: Interface parameters.
    """
    return self.__interfaces
      
  def _set_interfaces(self, v, load=False):
    """
    Setter method for interfaces, mapped from YANG variable /interfaces (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interfaces is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interfaces() directly.

    YANG Description: Interface parameters.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_interfaces_ietf_interfaces__interfaces, is_container='container', yang_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interfaces must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_interfaces_ietf_interfaces__interfaces, is_container='container', yang_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='container', is_config=True)""",
        })

    self.__interfaces = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interfaces(self):
    self.__interfaces = YANGDynClass(base=yc_interfaces_ietf_interfaces__interfaces, is_container='container', yang_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='container', is_config=True)


  def _get_interfaces_state(self):
    """
    Getter method for interfaces_state, mapped from YANG variable /interfaces_state (container)

    YANG Description: Data nodes for the operational state of interfaces.
    """
    return self.__interfaces_state
      
  def _set_interfaces_state(self, v, load=False):
    """
    Setter method for interfaces_state, mapped from YANG variable /interfaces_state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interfaces_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interfaces_state() directly.

    YANG Description: Data nodes for the operational state of interfaces.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_interfaces_state_ietf_interfaces__interfaces_state, is_container='container', yang_name="interfaces-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interfaces_state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_interfaces_state_ietf_interfaces__interfaces_state, is_container='container', yang_name="interfaces-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='container', is_config=True)""",
        })

    self.__interfaces_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interfaces_state(self):
    self.__interfaces_state = YANGDynClass(base=yc_interfaces_state_ietf_interfaces__interfaces_state, is_container='container', yang_name="interfaces-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-interfaces', defining_module='ietf-interfaces', yang_type='container', is_config=True)

  interfaces = __builtin__.property(_get_interfaces, _set_interfaces) # type: yc_interfaces_ietf_interfaces__interfaces
  interfaces_state = __builtin__.property(_get_interfaces_state, _set_interfaces_state) # type: yc_interfaces_state_ietf_interfaces__interfaces_state


  _pyangbind_elements = OrderedDict([('interfaces', interfaces), ('interfaces_state', interfaces_state), ])


class yc_interfaces_ietf_routing__routing_interfaces(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/interfaces. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Network-layer interfaces used for routing.
  """
  __slots__ = ('_path_helper', '_extmethods', '__interface',)

  _yang_name = 'interfaces'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__interface = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'interfaces']

  def _get_interface(self):
    """
    Getter method for interface, mapped from YANG variable /routing/interfaces/interface (if:interface-ref)

    YANG Description: Each entry is a reference to the name of a configured
network-layer interface.
    """
    return self.__interface
      
  def _set_interface(self, v, load=False):
    """
    Setter method for interface, mapped from YANG variable /routing/interfaces/interface (if:interface-ref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface() directly.

    YANG Description: Each entry is a reference to the name of a configured
network-layer interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface must be of a type compatible with if:interface-ref""",
          'defined-type': "if:interface-ref",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=False)""",
        })

    self.__interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface(self):
    self.__interface = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=False)

  interface = __builtin__.property(_get_interface)


  _pyangbind_elements = OrderedDict([('interface', interface), ])


class yc_control_plane_protocol_ietf_routing__routing_control_plane_protocols_control_plane_protocol(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Each entry contains a control-plane protocol instance.
  """
  __slots__ = ('_path_helper', '_extmethods', '__type','__name','__description',)

  _yang_name = 'control-plane-protocol'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'routing-protocol': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:routing-protocol': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'direct': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:direct': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'static': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:static': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=True)
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol']

  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/type (identityref)

    YANG Description: Type of the control-plane protocol -- an identity
derived from the 'control-plane-protocol'
base identity.
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/type (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: Type of the control-plane protocol -- an identity
derived from the 'control-plane-protocol'
base identity.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'routing-protocol': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:routing-protocol': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'direct': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:direct': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'static': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:static': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with identityref""",
          'defined-type': "ietf-routing:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'routing-protocol': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:routing-protocol': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'direct': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:direct': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'static': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:static': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=True)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'routing-protocol': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:routing-protocol': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'direct': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:direct': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'static': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:static': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=True)


  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/name (string)

    YANG Description: An arbitrary name of the control-plane protocol
instance.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: An arbitrary name of the control-plane protocol
instance.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=True)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/description (string)

    YANG Description: Textual description of the control-plane protocol
instance.
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Textual description of the control-plane protocol
instance.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=True)

  type = __builtin__.property(_get_type, _set_type)
  name = __builtin__.property(_get_name, _set_name)
  description = __builtin__.property(_get_description, _set_description)


  _pyangbind_elements = OrderedDict([('type', type), ('name', name), ('description', description), ])


class yc_control_plane_protocols_ietf_routing__routing_control_plane_protocols(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Support for control-plane protocol instances.
  """
  __slots__ = ('_path_helper', '_extmethods', '__control_plane_protocol',)

  _yang_name = 'control-plane-protocols'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__control_plane_protocol = YANGDynClass(base=YANGListType("type name",yc_control_plane_protocol_ietf_routing__routing_control_plane_protocols_control_plane_protocol, yang_name="control-plane-protocol", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='type name', extensions=None), is_container='list', yang_name="control-plane-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols']

  def _get_control_plane_protocol(self):
    """
    Getter method for control_plane_protocol, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol (list)

    YANG Description: Each entry contains a control-plane protocol instance.
    """
    return self.__control_plane_protocol
      
  def _set_control_plane_protocol(self, v, load=False):
    """
    Setter method for control_plane_protocol, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_control_plane_protocol is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_control_plane_protocol() directly.

    YANG Description: Each entry contains a control-plane protocol instance.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("type name",yc_control_plane_protocol_ietf_routing__routing_control_plane_protocols_control_plane_protocol, yang_name="control-plane-protocol", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='type name', extensions=None), is_container='list', yang_name="control-plane-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """control_plane_protocol must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("type name",yc_control_plane_protocol_ietf_routing__routing_control_plane_protocols_control_plane_protocol, yang_name="control-plane-protocol", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='type name', extensions=None), is_container='list', yang_name="control-plane-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=True)""",
        })

    self.__control_plane_protocol = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_control_plane_protocol(self):
    self.__control_plane_protocol = YANGDynClass(base=YANGListType("type name",yc_control_plane_protocol_ietf_routing__routing_control_plane_protocols_control_plane_protocol, yang_name="control-plane-protocol", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='type name', extensions=None), is_container='list', yang_name="control-plane-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=True)

  control_plane_protocol = __builtin__.property(_get_control_plane_protocol, _set_control_plane_protocol) # type: yc_control_plane_protocol_ietf_routing__routing_control_plane_protocols_control_plane_protocol


  _pyangbind_elements = OrderedDict([('control_plane_protocol', control_plane_protocol), ])


class yc_next_hop_ietf_routing__routing_ribs_rib_routes_route_next_hop_next_hop_list_next_hop(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/ribs/rib/routes/route/next-hop/next-hop-list/next-hop. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: An entry in a next-hop list.

Modules for address families MUST augment this list
with a leaf containing a next-hop address of that
address family.
  """
  __slots__ = ('_path_helper', '_extmethods', '__outgoing_interface',)

  _yang_name = 'next-hop'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__outgoing_interface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="outgoing-interface", parent=self, choice=('next-hop-options', 'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'ribs', 'rib', 'routes', 'route', 'next-hop', 'next-hop-list', 'next-hop']

  def _get_outgoing_interface(self):
    """
    Getter method for outgoing_interface, mapped from YANG variable /routing/ribs/rib/routes/route/next_hop/next_hop_list/next_hop/outgoing_interface (if:interface-ref)

    YANG Description: Name of the outgoing interface.
    """
    return self.__outgoing_interface
      
  def _set_outgoing_interface(self, v, load=False):
    """
    Setter method for outgoing_interface, mapped from YANG variable /routing/ribs/rib/routes/route/next_hop/next_hop_list/next_hop/outgoing_interface (if:interface-ref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_outgoing_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_outgoing_interface() directly.

    YANG Description: Name of the outgoing interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="outgoing-interface", parent=self, choice=('next-hop-options', 'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """outgoing_interface must be of a type compatible with if:interface-ref""",
          'defined-type': "if:interface-ref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="outgoing-interface", parent=self, choice=('next-hop-options', 'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=False)""",
        })

    self.__outgoing_interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_outgoing_interface(self):
    self.__outgoing_interface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="outgoing-interface", parent=self, choice=('next-hop-options', 'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=False)

  outgoing_interface = __builtin__.property(_get_outgoing_interface)

  __choices__ = {'next-hop-options': {'next-hop-list': ['outgoing_interface']}}
  _pyangbind_elements = OrderedDict([('outgoing_interface', outgoing_interface), ])


class yc_next_hop_list_ietf_routing__routing_ribs_rib_routes_route_next_hop_next_hop_list(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/ribs/rib/routes/route/next-hop/next-hop-list. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container for multiple next hops.
  """
  __slots__ = ('_path_helper', '_extmethods', '__next_hop',)

  _yang_name = 'next-hop-list'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__next_hop = YANGDynClass(base=YANGListType(False,yc_next_hop_ietf_routing__routing_ribs_rib_routes_route_next_hop_next_hop_list_next_hop, yang_name="next-hop", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='False', extensions=None, choice=('next-hop-options', 'next-hop-list')), is_container='list', yang_name="next-hop", parent=self, choice=('next-hop-options', 'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'ribs', 'rib', 'routes', 'route', 'next-hop', 'next-hop-list']

  def _get_next_hop(self):
    """
    Getter method for next_hop, mapped from YANG variable /routing/ribs/rib/routes/route/next_hop/next_hop_list/next_hop (list)

    YANG Description: An entry in a next-hop list.

Modules for address families MUST augment this list
with a leaf containing a next-hop address of that
address family.
    """
    return self.__next_hop
      
  def _set_next_hop(self, v, load=False):
    """
    Setter method for next_hop, mapped from YANG variable /routing/ribs/rib/routes/route/next_hop/next_hop_list/next_hop (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_next_hop is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_next_hop() directly.

    YANG Description: An entry in a next-hop list.

Modules for address families MUST augment this list
with a leaf containing a next-hop address of that
address family.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType(False,yc_next_hop_ietf_routing__routing_ribs_rib_routes_route_next_hop_next_hop_list_next_hop, yang_name="next-hop", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='False', extensions=None, choice=('next-hop-options', 'next-hop-list')), is_container='list', yang_name="next-hop", parent=self, choice=('next-hop-options', 'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """next_hop must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType(False,yc_next_hop_ietf_routing__routing_ribs_rib_routes_route_next_hop_next_hop_list_next_hop, yang_name="next-hop", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='False', extensions=None, choice=('next-hop-options', 'next-hop-list')), is_container='list', yang_name="next-hop", parent=self, choice=('next-hop-options', 'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)""",
        })

    self.__next_hop = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_next_hop(self):
    self.__next_hop = YANGDynClass(base=YANGListType(False,yc_next_hop_ietf_routing__routing_ribs_rib_routes_route_next_hop_next_hop_list_next_hop, yang_name="next-hop", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='False', extensions=None, choice=('next-hop-options', 'next-hop-list')), is_container='list', yang_name="next-hop", parent=self, choice=('next-hop-options', 'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)

  next_hop = __builtin__.property(_get_next_hop) # type: yc_next_hop_ietf_routing__routing_ribs_rib_routes_route_next_hop_next_hop_list_next_hop

  __choices__ = {'next-hop-options': {'next-hop-list': ['next_hop']}}
  _pyangbind_elements = OrderedDict([('next_hop', next_hop), ])


class yc_next_hop_ietf_routing__routing_ribs_rib_routes_route_next_hop(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/ribs/rib/routes/route/next-hop. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Route's next-hop attribute.
  """
  __slots__ = ('_path_helper', '_extmethods', '__outgoing_interface','__special_next_hop','__next_hop_list',)

  _yang_name = 'next-hop'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__outgoing_interface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="outgoing-interface", parent=self, choice=('next-hop-options', 'simple-next-hop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=False)
    self.__special_next_hop = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'blackhole': {}, 'unreachable': {}, 'prohibit': {}, 'receive': {}},), is_leaf=True, yang_name="special-next-hop", parent=self, choice=('next-hop-options', 'special-next-hop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='enumeration', is_config=False)
    self.__next_hop_list = YANGDynClass(base=yc_next_hop_list_ietf_routing__routing_ribs_rib_routes_route_next_hop_next_hop_list, is_container='container', yang_name="next-hop-list", parent=self, choice=('next-hop-options', 'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'ribs', 'rib', 'routes', 'route', 'next-hop']

  def _get_outgoing_interface(self):
    """
    Getter method for outgoing_interface, mapped from YANG variable /routing/ribs/rib/routes/route/next_hop/outgoing_interface (if:interface-ref)

    YANG Description: Name of the outgoing interface.
    """
    return self.__outgoing_interface
      
  def _set_outgoing_interface(self, v, load=False):
    """
    Setter method for outgoing_interface, mapped from YANG variable /routing/ribs/rib/routes/route/next_hop/outgoing_interface (if:interface-ref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_outgoing_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_outgoing_interface() directly.

    YANG Description: Name of the outgoing interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="outgoing-interface", parent=self, choice=('next-hop-options', 'simple-next-hop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """outgoing_interface must be of a type compatible with if:interface-ref""",
          'defined-type': "if:interface-ref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="outgoing-interface", parent=self, choice=('next-hop-options', 'simple-next-hop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=False)""",
        })

    self.__outgoing_interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_outgoing_interface(self):
    self.__outgoing_interface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="outgoing-interface", parent=self, choice=('next-hop-options', 'simple-next-hop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=False)


  def _get_special_next_hop(self):
    """
    Getter method for special_next_hop, mapped from YANG variable /routing/ribs/rib/routes/route/next_hop/special_next_hop (enumeration)

    YANG Description: Options for special next hops.
    """
    return self.__special_next_hop
      
  def _set_special_next_hop(self, v, load=False):
    """
    Setter method for special_next_hop, mapped from YANG variable /routing/ribs/rib/routes/route/next_hop/special_next_hop (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_special_next_hop is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_special_next_hop() directly.

    YANG Description: Options for special next hops.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'blackhole': {}, 'unreachable': {}, 'prohibit': {}, 'receive': {}},), is_leaf=True, yang_name="special-next-hop", parent=self, choice=('next-hop-options', 'special-next-hop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='enumeration', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """special_next_hop must be of a type compatible with enumeration""",
          'defined-type': "ietf-routing:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'blackhole': {}, 'unreachable': {}, 'prohibit': {}, 'receive': {}},), is_leaf=True, yang_name="special-next-hop", parent=self, choice=('next-hop-options', 'special-next-hop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='enumeration', is_config=False)""",
        })

    self.__special_next_hop = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_special_next_hop(self):
    self.__special_next_hop = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'blackhole': {}, 'unreachable': {}, 'prohibit': {}, 'receive': {}},), is_leaf=True, yang_name="special-next-hop", parent=self, choice=('next-hop-options', 'special-next-hop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='enumeration', is_config=False)


  def _get_next_hop_list(self):
    """
    Getter method for next_hop_list, mapped from YANG variable /routing/ribs/rib/routes/route/next_hop/next_hop_list (container)

    YANG Description: Container for multiple next hops.
    """
    return self.__next_hop_list
      
  def _set_next_hop_list(self, v, load=False):
    """
    Setter method for next_hop_list, mapped from YANG variable /routing/ribs/rib/routes/route/next_hop/next_hop_list (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_next_hop_list is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_next_hop_list() directly.

    YANG Description: Container for multiple next hops.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_next_hop_list_ietf_routing__routing_ribs_rib_routes_route_next_hop_next_hop_list, is_container='container', yang_name="next-hop-list", parent=self, choice=('next-hop-options', 'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """next_hop_list must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_next_hop_list_ietf_routing__routing_ribs_rib_routes_route_next_hop_next_hop_list, is_container='container', yang_name="next-hop-list", parent=self, choice=('next-hop-options', 'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)""",
        })

    self.__next_hop_list = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_next_hop_list(self):
    self.__next_hop_list = YANGDynClass(base=yc_next_hop_list_ietf_routing__routing_ribs_rib_routes_route_next_hop_next_hop_list, is_container='container', yang_name="next-hop-list", parent=self, choice=('next-hop-options', 'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)

  outgoing_interface = __builtin__.property(_get_outgoing_interface)
  special_next_hop = __builtin__.property(_get_special_next_hop)
  next_hop_list = __builtin__.property(_get_next_hop_list) # type: yc_next_hop_list_ietf_routing__routing_ribs_rib_routes_route_next_hop_next_hop_list

  __choices__ = {'next-hop-options': {'simple-next-hop': ['outgoing_interface'], 'special-next-hop': ['special_next_hop'], 'next-hop-list': ['next_hop_list']}}
  _pyangbind_elements = OrderedDict([('outgoing_interface', outgoing_interface), ('special_next_hop', special_next_hop), ('next_hop_list', next_hop_list), ])


class yc_route_ietf_routing__routing_ribs_rib_routes_route(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/ribs/rib/routes/route. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: A RIB route entry.  This data node MUST be augmented
with information specific to routes of each address
family.
  """
  __slots__ = ('_path_helper', '_extmethods', '__route_preference','__next_hop','__source_protocol','__active','__last_updated',)

  _yang_name = 'route'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__route_preference = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="route-preference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='route-preference', is_config=False)
    self.__next_hop = YANGDynClass(base=yc_next_hop_ietf_routing__routing_ribs_rib_routes_route_next_hop, is_container='container', yang_name="next-hop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)
    self.__source_protocol = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'direct': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:direct': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'static': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:static': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}},), is_leaf=True, yang_name="source-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=False)
    self.__active = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="active", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='empty', is_config=False)
    self.__last_updated = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="last-updated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='yang:date-and-time', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'ribs', 'rib', 'routes', 'route']

  def _get_route_preference(self):
    """
    Getter method for route_preference, mapped from YANG variable /routing/ribs/rib/routes/route/route_preference (route-preference)

    YANG Description: This route attribute, also known as 'administrative
distance', allows for selecting the preferred route
among routes with the same destination prefix.  A
smaller value indicates a route that is
more preferred.
    """
    return self.__route_preference
      
  def _set_route_preference(self, v, load=False):
    """
    Setter method for route_preference, mapped from YANG variable /routing/ribs/rib/routes/route/route_preference (route-preference)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_route_preference is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_route_preference() directly.

    YANG Description: This route attribute, also known as 'administrative
distance', allows for selecting the preferred route
among routes with the same destination prefix.  A
smaller value indicates a route that is
more preferred.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="route-preference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='route-preference', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """route_preference must be of a type compatible with route-preference""",
          'defined-type': "ietf-routing:route-preference",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="route-preference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='route-preference', is_config=False)""",
        })

    self.__route_preference = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_route_preference(self):
    self.__route_preference = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="route-preference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='route-preference', is_config=False)


  def _get_next_hop(self):
    """
    Getter method for next_hop, mapped from YANG variable /routing/ribs/rib/routes/route/next_hop (container)

    YANG Description: Route's next-hop attribute.
    """
    return self.__next_hop
      
  def _set_next_hop(self, v, load=False):
    """
    Setter method for next_hop, mapped from YANG variable /routing/ribs/rib/routes/route/next_hop (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_next_hop is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_next_hop() directly.

    YANG Description: Route's next-hop attribute.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_next_hop_ietf_routing__routing_ribs_rib_routes_route_next_hop, is_container='container', yang_name="next-hop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """next_hop must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_next_hop_ietf_routing__routing_ribs_rib_routes_route_next_hop, is_container='container', yang_name="next-hop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)""",
        })

    self.__next_hop = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_next_hop(self):
    self.__next_hop = YANGDynClass(base=yc_next_hop_ietf_routing__routing_ribs_rib_routes_route_next_hop, is_container='container', yang_name="next-hop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)


  def _get_source_protocol(self):
    """
    Getter method for source_protocol, mapped from YANG variable /routing/ribs/rib/routes/route/source_protocol (identityref)

    YANG Description: Type of the routing protocol from which the route
originated.
    """
    return self.__source_protocol
      
  def _set_source_protocol(self, v, load=False):
    """
    Setter method for source_protocol, mapped from YANG variable /routing/ribs/rib/routes/route/source_protocol (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_source_protocol is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_source_protocol() directly.

    YANG Description: Type of the routing protocol from which the route
originated.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'direct': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:direct': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'static': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:static': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}},), is_leaf=True, yang_name="source-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """source_protocol must be of a type compatible with identityref""",
          'defined-type': "ietf-routing:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'direct': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:direct': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'static': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:static': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}},), is_leaf=True, yang_name="source-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=False)""",
        })

    self.__source_protocol = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_source_protocol(self):
    self.__source_protocol = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'direct': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:direct': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'static': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:static': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}},), is_leaf=True, yang_name="source-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=False)


  def _get_active(self):
    """
    Getter method for active, mapped from YANG variable /routing/ribs/rib/routes/route/active (empty)

    YANG Description: The presence of this leaf indicates that the route is
preferred among all routes in the same RIB that have the
same destination prefix.
    """
    return self.__active
      
  def _set_active(self, v, load=False):
    """
    Setter method for active, mapped from YANG variable /routing/ribs/rib/routes/route/active (empty)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_active is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_active() directly.

    YANG Description: The presence of this leaf indicates that the route is
preferred among all routes in the same RIB that have the
same destination prefix.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="active", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='empty', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """active must be of a type compatible with empty""",
          'defined-type': "empty",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="active", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='empty', is_config=False)""",
        })

    self.__active = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_active(self):
    self.__active = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="active", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='empty', is_config=False)


  def _get_last_updated(self):
    """
    Getter method for last_updated, mapped from YANG variable /routing/ribs/rib/routes/route/last_updated (yang:date-and-time)

    YANG Description: Timestamp of the last modification of the route.  If the
route was never modified, it is the time when the route was
inserted into the RIB.
    """
    return self.__last_updated
      
  def _set_last_updated(self, v, load=False):
    """
    Setter method for last_updated, mapped from YANG variable /routing/ribs/rib/routes/route/last_updated (yang:date-and-time)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_last_updated is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_last_updated() directly.

    YANG Description: Timestamp of the last modification of the route.  If the
route was never modified, it is the time when the route was
inserted into the RIB.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="last-updated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='yang:date-and-time', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """last_updated must be of a type compatible with yang:date-and-time""",
          'defined-type': "yang:date-and-time",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="last-updated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='yang:date-and-time', is_config=False)""",
        })

    self.__last_updated = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_last_updated(self):
    self.__last_updated = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="last-updated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='yang:date-and-time', is_config=False)

  route_preference = __builtin__.property(_get_route_preference)
  next_hop = __builtin__.property(_get_next_hop) # type: yc_next_hop_ietf_routing__routing_ribs_rib_routes_route_next_hop
  source_protocol = __builtin__.property(_get_source_protocol)
  active = __builtin__.property(_get_active)
  last_updated = __builtin__.property(_get_last_updated)


  _pyangbind_elements = OrderedDict([('route_preference', route_preference), ('next_hop', next_hop), ('source_protocol', source_protocol), ('active', active), ('last_updated', last_updated), ])


class yc_routes_ietf_routing__routing_ribs_rib_routes(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/ribs/rib/routes. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Current contents of the RIB.
  """
  __slots__ = ('_path_helper', '_extmethods', '__route',)

  _yang_name = 'routes'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__route = YANGDynClass(base=YANGListType(False,yc_route_ietf_routing__routing_ribs_rib_routes_route, yang_name="route", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='False', extensions=None), is_container='list', yang_name="route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'ribs', 'rib', 'routes']

  def _get_route(self):
    """
    Getter method for route, mapped from YANG variable /routing/ribs/rib/routes/route (list)

    YANG Description: A RIB route entry.  This data node MUST be augmented
with information specific to routes of each address
family.
    """
    return self.__route
      
  def _set_route(self, v, load=False):
    """
    Setter method for route, mapped from YANG variable /routing/ribs/rib/routes/route (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_route is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_route() directly.

    YANG Description: A RIB route entry.  This data node MUST be augmented
with information specific to routes of each address
family.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType(False,yc_route_ietf_routing__routing_ribs_rib_routes_route, yang_name="route", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='False', extensions=None), is_container='list', yang_name="route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """route must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType(False,yc_route_ietf_routing__routing_ribs_rib_routes_route, yang_name="route", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='False', extensions=None), is_container='list', yang_name="route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)""",
        })

    self.__route = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_route(self):
    self.__route = YANGDynClass(base=YANGListType(False,yc_route_ietf_routing__routing_ribs_rib_routes_route, yang_name="route", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='False', extensions=None), is_container='list', yang_name="route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)

  route = __builtin__.property(_get_route) # type: yc_route_ietf_routing__routing_ribs_rib_routes_route


  _pyangbind_elements = OrderedDict([('route', route), ])


class yc_next_hop_ietf_routing__routing_ribs_rib_active_route_output_route_next_hop_next_hop_list_next_hop(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/ribs/rib/active-route/output/route/next-hop/next-hop-list/next-hop. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: An entry in a next-hop list.

Modules for address families MUST augment this list
with a leaf containing a next-hop address of that
address family.
  """
  __slots__ = ('_path_helper', '_extmethods', '__outgoing_interface',)

  _yang_name = 'next-hop'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__outgoing_interface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="outgoing-interface", parent=self, choice=('next-hop-options', 'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'ribs', 'rib', 'active-route', 'output', 'route', 'next-hop', 'next-hop-list', 'next-hop']

  def _get_outgoing_interface(self):
    """
    Getter method for outgoing_interface, mapped from YANG variable /routing/ribs/rib/active_route/output/route/next_hop/next_hop_list/next_hop/outgoing_interface (if:interface-ref)

    YANG Description: Name of the outgoing interface.
    """
    return self.__outgoing_interface
      
  def _set_outgoing_interface(self, v, load=False):
    """
    Setter method for outgoing_interface, mapped from YANG variable /routing/ribs/rib/active_route/output/route/next_hop/next_hop_list/next_hop/outgoing_interface (if:interface-ref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_outgoing_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_outgoing_interface() directly.

    YANG Description: Name of the outgoing interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="outgoing-interface", parent=self, choice=('next-hop-options', 'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """outgoing_interface must be of a type compatible with if:interface-ref""",
          'defined-type': "if:interface-ref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="outgoing-interface", parent=self, choice=('next-hop-options', 'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=True)""",
        })

    self.__outgoing_interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_outgoing_interface(self):
    self.__outgoing_interface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="outgoing-interface", parent=self, choice=('next-hop-options', 'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=True)

  outgoing_interface = __builtin__.property(_get_outgoing_interface, _set_outgoing_interface)

  __choices__ = {'next-hop-options': {'next-hop-list': ['outgoing_interface']}}
  _pyangbind_elements = OrderedDict([('outgoing_interface', outgoing_interface), ])


class yc_next_hop_list_ietf_routing__routing_ribs_rib_active_route_output_route_next_hop_next_hop_list(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/ribs/rib/active-route/output/route/next-hop/next-hop-list. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container for multiple next hops.
  """
  __slots__ = ('_path_helper', '_extmethods', '__next_hop',)

  _yang_name = 'next-hop-list'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__next_hop = YANGDynClass(base=YANGListType(False,yc_next_hop_ietf_routing__routing_ribs_rib_active_route_output_route_next_hop_next_hop_list_next_hop, yang_name="next-hop", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='False', extensions=None, choice=('next-hop-options', 'next-hop-list')), is_container='list', yang_name="next-hop", parent=self, choice=('next-hop-options', 'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'ribs', 'rib', 'active-route', 'output', 'route', 'next-hop', 'next-hop-list']

  def _get_next_hop(self):
    """
    Getter method for next_hop, mapped from YANG variable /routing/ribs/rib/active_route/output/route/next_hop/next_hop_list/next_hop (list)

    YANG Description: An entry in a next-hop list.

Modules for address families MUST augment this list
with a leaf containing a next-hop address of that
address family.
    """
    return self.__next_hop
      
  def _set_next_hop(self, v, load=False):
    """
    Setter method for next_hop, mapped from YANG variable /routing/ribs/rib/active_route/output/route/next_hop/next_hop_list/next_hop (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_next_hop is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_next_hop() directly.

    YANG Description: An entry in a next-hop list.

Modules for address families MUST augment this list
with a leaf containing a next-hop address of that
address family.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType(False,yc_next_hop_ietf_routing__routing_ribs_rib_active_route_output_route_next_hop_next_hop_list_next_hop, yang_name="next-hop", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='False', extensions=None, choice=('next-hop-options', 'next-hop-list')), is_container='list', yang_name="next-hop", parent=self, choice=('next-hop-options', 'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """next_hop must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType(False,yc_next_hop_ietf_routing__routing_ribs_rib_active_route_output_route_next_hop_next_hop_list_next_hop, yang_name="next-hop", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='False', extensions=None, choice=('next-hop-options', 'next-hop-list')), is_container='list', yang_name="next-hop", parent=self, choice=('next-hop-options', 'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=True)""",
        })

    self.__next_hop = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_next_hop(self):
    self.__next_hop = YANGDynClass(base=YANGListType(False,yc_next_hop_ietf_routing__routing_ribs_rib_active_route_output_route_next_hop_next_hop_list_next_hop, yang_name="next-hop", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='False', extensions=None, choice=('next-hop-options', 'next-hop-list')), is_container='list', yang_name="next-hop", parent=self, choice=('next-hop-options', 'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=True)

  next_hop = __builtin__.property(_get_next_hop, _set_next_hop) # type: yc_next_hop_ietf_routing__routing_ribs_rib_active_route_output_route_next_hop_next_hop_list_next_hop

  __choices__ = {'next-hop-options': {'next-hop-list': ['next_hop']}}
  _pyangbind_elements = OrderedDict([('next_hop', next_hop), ])


class yc_next_hop_ietf_routing__routing_ribs_rib_active_route_output_route_next_hop(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/ribs/rib/active-route/output/route/next-hop. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Route's next-hop attribute.
  """
  __slots__ = ('_path_helper', '_extmethods', '__outgoing_interface','__special_next_hop','__next_hop_list',)

  _yang_name = 'next-hop'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__outgoing_interface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="outgoing-interface", parent=self, choice=('next-hop-options', 'simple-next-hop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=True)
    self.__special_next_hop = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'blackhole': {}, 'unreachable': {}, 'prohibit': {}, 'receive': {}},), is_leaf=True, yang_name="special-next-hop", parent=self, choice=('next-hop-options', 'special-next-hop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='enumeration', is_config=True)
    self.__next_hop_list = YANGDynClass(base=yc_next_hop_list_ietf_routing__routing_ribs_rib_active_route_output_route_next_hop_next_hop_list, is_container='container', yang_name="next-hop-list", parent=self, choice=('next-hop-options', 'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'ribs', 'rib', 'active-route', 'output', 'route', 'next-hop']

  def _get_outgoing_interface(self):
    """
    Getter method for outgoing_interface, mapped from YANG variable /routing/ribs/rib/active_route/output/route/next_hop/outgoing_interface (if:interface-ref)

    YANG Description: Name of the outgoing interface.
    """
    return self.__outgoing_interface
      
  def _set_outgoing_interface(self, v, load=False):
    """
    Setter method for outgoing_interface, mapped from YANG variable /routing/ribs/rib/active_route/output/route/next_hop/outgoing_interface (if:interface-ref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_outgoing_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_outgoing_interface() directly.

    YANG Description: Name of the outgoing interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="outgoing-interface", parent=self, choice=('next-hop-options', 'simple-next-hop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """outgoing_interface must be of a type compatible with if:interface-ref""",
          'defined-type': "if:interface-ref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="outgoing-interface", parent=self, choice=('next-hop-options', 'simple-next-hop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=True)""",
        })

    self.__outgoing_interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_outgoing_interface(self):
    self.__outgoing_interface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="outgoing-interface", parent=self, choice=('next-hop-options', 'simple-next-hop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=True)


  def _get_special_next_hop(self):
    """
    Getter method for special_next_hop, mapped from YANG variable /routing/ribs/rib/active_route/output/route/next_hop/special_next_hop (enumeration)

    YANG Description: Options for special next hops.
    """
    return self.__special_next_hop
      
  def _set_special_next_hop(self, v, load=False):
    """
    Setter method for special_next_hop, mapped from YANG variable /routing/ribs/rib/active_route/output/route/next_hop/special_next_hop (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_special_next_hop is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_special_next_hop() directly.

    YANG Description: Options for special next hops.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'blackhole': {}, 'unreachable': {}, 'prohibit': {}, 'receive': {}},), is_leaf=True, yang_name="special-next-hop", parent=self, choice=('next-hop-options', 'special-next-hop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """special_next_hop must be of a type compatible with enumeration""",
          'defined-type': "ietf-routing:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'blackhole': {}, 'unreachable': {}, 'prohibit': {}, 'receive': {}},), is_leaf=True, yang_name="special-next-hop", parent=self, choice=('next-hop-options', 'special-next-hop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='enumeration', is_config=True)""",
        })

    self.__special_next_hop = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_special_next_hop(self):
    self.__special_next_hop = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'blackhole': {}, 'unreachable': {}, 'prohibit': {}, 'receive': {}},), is_leaf=True, yang_name="special-next-hop", parent=self, choice=('next-hop-options', 'special-next-hop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='enumeration', is_config=True)


  def _get_next_hop_list(self):
    """
    Getter method for next_hop_list, mapped from YANG variable /routing/ribs/rib/active_route/output/route/next_hop/next_hop_list (container)

    YANG Description: Container for multiple next hops.
    """
    return self.__next_hop_list
      
  def _set_next_hop_list(self, v, load=False):
    """
    Setter method for next_hop_list, mapped from YANG variable /routing/ribs/rib/active_route/output/route/next_hop/next_hop_list (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_next_hop_list is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_next_hop_list() directly.

    YANG Description: Container for multiple next hops.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_next_hop_list_ietf_routing__routing_ribs_rib_active_route_output_route_next_hop_next_hop_list, is_container='container', yang_name="next-hop-list", parent=self, choice=('next-hop-options', 'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """next_hop_list must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_next_hop_list_ietf_routing__routing_ribs_rib_active_route_output_route_next_hop_next_hop_list, is_container='container', yang_name="next-hop-list", parent=self, choice=('next-hop-options', 'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)""",
        })

    self.__next_hop_list = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_next_hop_list(self):
    self.__next_hop_list = YANGDynClass(base=yc_next_hop_list_ietf_routing__routing_ribs_rib_active_route_output_route_next_hop_next_hop_list, is_container='container', yang_name="next-hop-list", parent=self, choice=('next-hop-options', 'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)

  outgoing_interface = __builtin__.property(_get_outgoing_interface, _set_outgoing_interface)
  special_next_hop = __builtin__.property(_get_special_next_hop, _set_special_next_hop)
  next_hop_list = __builtin__.property(_get_next_hop_list, _set_next_hop_list) # type: yc_next_hop_list_ietf_routing__routing_ribs_rib_active_route_output_route_next_hop_next_hop_list

  __choices__ = {'next-hop-options': {'simple-next-hop': ['outgoing_interface'], 'special-next-hop': ['special_next_hop'], 'next-hop-list': ['next_hop_list']}}
  _pyangbind_elements = OrderedDict([('outgoing_interface', outgoing_interface), ('special_next_hop', special_next_hop), ('next_hop_list', next_hop_list), ])


class yc_route_ietf_routing__routing_ribs_rib_active_route_output_route(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/ribs/rib/active-route/output/route. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The active RIB route for the specified destination.

If no route exists in the RIB for the destination
address, no output is returned.

Address-family-specific modules MUST augment this
container with appropriate route contents.
  """
  __slots__ = ('_path_helper', '_extmethods', '__next_hop','__source_protocol','__active','__last_updated',)

  _yang_name = 'route'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__next_hop = YANGDynClass(base=yc_next_hop_ietf_routing__routing_ribs_rib_active_route_output_route_next_hop, is_container='container', yang_name="next-hop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)
    self.__source_protocol = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'direct': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:direct': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'static': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:static': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}},), is_leaf=True, yang_name="source-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=True)
    self.__active = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="active", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='empty', is_config=True)
    self.__last_updated = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="last-updated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='yang:date-and-time', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'ribs', 'rib', 'active-route', 'output', 'route']

  def _get_next_hop(self):
    """
    Getter method for next_hop, mapped from YANG variable /routing/ribs/rib/active_route/output/route/next_hop (container)

    YANG Description: Route's next-hop attribute.
    """
    return self.__next_hop
      
  def _set_next_hop(self, v, load=False):
    """
    Setter method for next_hop, mapped from YANG variable /routing/ribs/rib/active_route/output/route/next_hop (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_next_hop is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_next_hop() directly.

    YANG Description: Route's next-hop attribute.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_next_hop_ietf_routing__routing_ribs_rib_active_route_output_route_next_hop, is_container='container', yang_name="next-hop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """next_hop must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_next_hop_ietf_routing__routing_ribs_rib_active_route_output_route_next_hop, is_container='container', yang_name="next-hop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)""",
        })

    self.__next_hop = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_next_hop(self):
    self.__next_hop = YANGDynClass(base=yc_next_hop_ietf_routing__routing_ribs_rib_active_route_output_route_next_hop, is_container='container', yang_name="next-hop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)


  def _get_source_protocol(self):
    """
    Getter method for source_protocol, mapped from YANG variable /routing/ribs/rib/active_route/output/route/source_protocol (identityref)

    YANG Description: Type of the routing protocol from which the route
originated.
    """
    return self.__source_protocol
      
  def _set_source_protocol(self, v, load=False):
    """
    Setter method for source_protocol, mapped from YANG variable /routing/ribs/rib/active_route/output/route/source_protocol (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_source_protocol is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_source_protocol() directly.

    YANG Description: Type of the routing protocol from which the route
originated.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'direct': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:direct': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'static': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:static': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}},), is_leaf=True, yang_name="source-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """source_protocol must be of a type compatible with identityref""",
          'defined-type': "ietf-routing:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'direct': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:direct': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'static': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:static': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}},), is_leaf=True, yang_name="source-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=True)""",
        })

    self.__source_protocol = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_source_protocol(self):
    self.__source_protocol = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'direct': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:direct': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'static': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:static': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}},), is_leaf=True, yang_name="source-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=True)


  def _get_active(self):
    """
    Getter method for active, mapped from YANG variable /routing/ribs/rib/active_route/output/route/active (empty)

    YANG Description: The presence of this leaf indicates that the route is
preferred among all routes in the same RIB that have the
same destination prefix.
    """
    return self.__active
      
  def _set_active(self, v, load=False):
    """
    Setter method for active, mapped from YANG variable /routing/ribs/rib/active_route/output/route/active (empty)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_active is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_active() directly.

    YANG Description: The presence of this leaf indicates that the route is
preferred among all routes in the same RIB that have the
same destination prefix.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="active", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='empty', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """active must be of a type compatible with empty""",
          'defined-type': "empty",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="active", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='empty', is_config=True)""",
        })

    self.__active = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_active(self):
    self.__active = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="active", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='empty', is_config=True)


  def _get_last_updated(self):
    """
    Getter method for last_updated, mapped from YANG variable /routing/ribs/rib/active_route/output/route/last_updated (yang:date-and-time)

    YANG Description: Timestamp of the last modification of the route.  If the
route was never modified, it is the time when the route was
inserted into the RIB.
    """
    return self.__last_updated
      
  def _set_last_updated(self, v, load=False):
    """
    Setter method for last_updated, mapped from YANG variable /routing/ribs/rib/active_route/output/route/last_updated (yang:date-and-time)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_last_updated is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_last_updated() directly.

    YANG Description: Timestamp of the last modification of the route.  If the
route was never modified, it is the time when the route was
inserted into the RIB.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="last-updated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='yang:date-and-time', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """last_updated must be of a type compatible with yang:date-and-time""",
          'defined-type': "yang:date-and-time",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="last-updated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='yang:date-and-time', is_config=True)""",
        })

    self.__last_updated = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_last_updated(self):
    self.__last_updated = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="last-updated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='yang:date-and-time', is_config=True)

  next_hop = __builtin__.property(_get_next_hop, _set_next_hop) # type: yc_next_hop_ietf_routing__routing_ribs_rib_active_route_output_route_next_hop
  source_protocol = __builtin__.property(_get_source_protocol, _set_source_protocol)
  active = __builtin__.property(_get_active, _set_active)
  last_updated = __builtin__.property(_get_last_updated, _set_last_updated)


  _pyangbind_elements = OrderedDict([('next_hop', next_hop), ('source_protocol', source_protocol), ('active', active), ('last_updated', last_updated), ])


class yc_output_ietf_routing__routing_ribs_rib_active_route_output(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/ribs/rib/active-route/output. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__route',)

  _yang_name = 'output'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__route = YANGDynClass(base=yc_route_ietf_routing__routing_ribs_rib_active_route_output_route, is_container='container', yang_name="route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'ribs', 'rib', 'active-route', 'output']

  def _get_route(self):
    """
    Getter method for route, mapped from YANG variable /routing/ribs/rib/active_route/output/route (container)

    YANG Description: The active RIB route for the specified destination.

If no route exists in the RIB for the destination
address, no output is returned.

Address-family-specific modules MUST augment this
container with appropriate route contents.
    """
    return self.__route
      
  def _set_route(self, v, load=False):
    """
    Setter method for route, mapped from YANG variable /routing/ribs/rib/active_route/output/route (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_route is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_route() directly.

    YANG Description: The active RIB route for the specified destination.

If no route exists in the RIB for the destination
address, no output is returned.

Address-family-specific modules MUST augment this
container with appropriate route contents.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_route_ietf_routing__routing_ribs_rib_active_route_output_route, is_container='container', yang_name="route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """route must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_route_ietf_routing__routing_ribs_rib_active_route_output_route, is_container='container', yang_name="route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)""",
        })

    self.__route = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_route(self):
    self.__route = YANGDynClass(base=yc_route_ietf_routing__routing_ribs_rib_active_route_output_route, is_container='container', yang_name="route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)

  route = __builtin__.property(_get_route, _set_route) # type: yc_route_ietf_routing__routing_ribs_rib_active_route_output_route


  _pyangbind_elements = OrderedDict([('route', route), ])


class yc_active_route_ietf_routing__routing_ribs_rib_active_route(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/ribs/rib/active-route. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Return the active RIB route that is used for the
destination address.

Address-family-specific modules MUST augment input
parameters with a leaf named 'destination-address'.
  """
  __slots__ = ('_path_helper', '_extmethods', '__output',)

  _yang_name = 'active-route'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__output = YANGDynClass(base=yc_output_ietf_routing__routing_ribs_rib_active_route_output, is_leaf=True, yang_name="output", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='output', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'ribs', 'rib', 'active-route']

  def _get_output(self):
    """
    Getter method for output, mapped from YANG variable /routing/ribs/rib/active_route/output (output)
    """
    return self.__output
      
  def _set_output(self, v, load=False):
    """
    Setter method for output, mapped from YANG variable /routing/ribs/rib/active_route/output (output)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_output is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_output() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_output_ietf_routing__routing_ribs_rib_active_route_output, is_leaf=True, yang_name="output", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='output', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """output must be of a type compatible with output""",
          'defined-type': "ietf-routing:output",
          'generated-type': """YANGDynClass(base=yc_output_ietf_routing__routing_ribs_rib_active_route_output, is_leaf=True, yang_name="output", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='output', is_config=True)""",
        })

    self.__output = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_output(self):
    self.__output = YANGDynClass(base=yc_output_ietf_routing__routing_ribs_rib_active_route_output, is_leaf=True, yang_name="output", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='output', is_config=True)

  output = __builtin__.property(_get_output, _set_output)


  _pyangbind_elements = OrderedDict([('output', output), ])


class yc_rib_ietf_routing__routing_ribs_rib(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/ribs/rib. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Each entry contains a configuration for a RIB identified
by the 'name' key.

Entries having the same key as a system-controlled entry
in the list '/routing/ribs/rib' are used for
configuring parameters of that entry.  Other entries
define additional user-controlled RIBs.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__address_family','__default_rib','__routes','__active_route','__description',)

  _yang_name = 'rib'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=True)
    self.__address_family = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'ipv4': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:ipv4': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'ipv6': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:ipv6': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}},), is_leaf=True, yang_name="address-family", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=True)
    self.__default_rib = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="default-rib", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='boolean', is_config=False)
    self.__routes = YANGDynClass(base=yc_routes_ietf_routing__routing_ribs_rib_routes, is_container='container', yang_name="routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)
    self.__active_route = YANGDynClass(base=yc_active_route_ietf_routing__routing_ribs_rib_active_route, is_leaf=True, yang_name="active-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='action', is_config=True)
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'ribs', 'rib']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /routing/ribs/rib/name (string)

    YANG Description: The name of the RIB.

For system-controlled entries, the value of this leaf
must be the same as the name of the corresponding entry
in the operational state.

For user-controlled entries, an arbitrary name can be
used.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /routing/ribs/rib/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: The name of the RIB.

For system-controlled entries, the value of this leaf
must be the same as the name of the corresponding entry
in the operational state.

For user-controlled entries, an arbitrary name can be
used.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=True)


  def _get_address_family(self):
    """
    Getter method for address_family, mapped from YANG variable /routing/ribs/rib/address_family (identityref)

    YANG Description: Address family.
    """
    return self.__address_family
      
  def _set_address_family(self, v, load=False):
    """
    Setter method for address_family, mapped from YANG variable /routing/ribs/rib/address_family (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_address_family is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_address_family() directly.

    YANG Description: Address family.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'ipv4': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:ipv4': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'ipv6': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:ipv6': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}},), is_leaf=True, yang_name="address-family", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """address_family must be of a type compatible with identityref""",
          'defined-type': "ietf-routing:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'ipv4': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:ipv4': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'ipv6': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:ipv6': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}},), is_leaf=True, yang_name="address-family", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=True)""",
        })

    self.__address_family = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_address_family(self):
    self.__address_family = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'ipv4': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:ipv4': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'ipv6': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:ipv6': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}},), is_leaf=True, yang_name="address-family", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=True)


  def _get_default_rib(self):
    """
    Getter method for default_rib, mapped from YANG variable /routing/ribs/rib/default_rib (boolean)

    YANG Description: This flag has the value of 'true' if and only if the RIB
is the default RIB for the given address family.

By default, control-plane protocols place their routes
in the default RIBs.
    """
    return self.__default_rib
      
  def _set_default_rib(self, v, load=False):
    """
    Setter method for default_rib, mapped from YANG variable /routing/ribs/rib/default_rib (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_default_rib is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_default_rib() directly.

    YANG Description: This flag has the value of 'true' if and only if the RIB
is the default RIB for the given address family.

By default, control-plane protocols place their routes
in the default RIBs.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="default-rib", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """default_rib must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="default-rib", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='boolean', is_config=False)""",
        })

    self.__default_rib = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_default_rib(self):
    self.__default_rib = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="default-rib", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='boolean', is_config=False)


  def _get_routes(self):
    """
    Getter method for routes, mapped from YANG variable /routing/ribs/rib/routes (container)

    YANG Description: Current contents of the RIB.
    """
    return self.__routes
      
  def _set_routes(self, v, load=False):
    """
    Setter method for routes, mapped from YANG variable /routing/ribs/rib/routes (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_routes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_routes() directly.

    YANG Description: Current contents of the RIB.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_routes_ietf_routing__routing_ribs_rib_routes, is_container='container', yang_name="routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """routes must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_routes_ietf_routing__routing_ribs_rib_routes, is_container='container', yang_name="routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)""",
        })

    self.__routes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_routes(self):
    self.__routes = YANGDynClass(base=yc_routes_ietf_routing__routing_ribs_rib_routes, is_container='container', yang_name="routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)


  def _get_active_route(self):
    """
    Getter method for active_route, mapped from YANG variable /routing/ribs/rib/active_route (action)

    YANG Description: Return the active RIB route that is used for the
destination address.

Address-family-specific modules MUST augment input
parameters with a leaf named 'destination-address'.
    """
    return self.__active_route
      
  def _set_active_route(self, v, load=False):
    """
    Setter method for active_route, mapped from YANG variable /routing/ribs/rib/active_route (action)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_active_route is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_active_route() directly.

    YANG Description: Return the active RIB route that is used for the
destination address.

Address-family-specific modules MUST augment input
parameters with a leaf named 'destination-address'.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_active_route_ietf_routing__routing_ribs_rib_active_route, is_leaf=True, yang_name="active-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='action', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """active_route must be of a type compatible with action""",
          'defined-type': "ietf-routing:action",
          'generated-type': """YANGDynClass(base=yc_active_route_ietf_routing__routing_ribs_rib_active_route, is_leaf=True, yang_name="active-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='action', is_config=True)""",
        })

    self.__active_route = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_active_route(self):
    self.__active_route = YANGDynClass(base=yc_active_route_ietf_routing__routing_ribs_rib_active_route, is_leaf=True, yang_name="active-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='action', is_config=True)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /routing/ribs/rib/description (string)

    YANG Description: Textual description of the RIB.
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /routing/ribs/rib/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Textual description of the RIB.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  address_family = __builtin__.property(_get_address_family, _set_address_family)
  default_rib = __builtin__.property(_get_default_rib)
  routes = __builtin__.property(_get_routes, _set_routes) # type: yc_routes_ietf_routing__routing_ribs_rib_routes
  active_route = __builtin__.property(_get_active_route, _set_active_route)
  description = __builtin__.property(_get_description, _set_description)


  _pyangbind_elements = OrderedDict([('name', name), ('address_family', address_family), ('default_rib', default_rib), ('routes', routes), ('active_route', active_route), ('description', description), ])


class yc_ribs_ietf_routing__routing_ribs(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/ribs. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Support for RIBs.
  """
  __slots__ = ('_path_helper', '_extmethods', '__rib',)

  _yang_name = 'ribs'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__rib = YANGDynClass(base=YANGListType("name",yc_rib_ietf_routing__routing_ribs_rib, yang_name="rib", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="rib", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'ribs']

  def _get_rib(self):
    """
    Getter method for rib, mapped from YANG variable /routing/ribs/rib (list)

    YANG Description: Each entry contains a configuration for a RIB identified
by the 'name' key.

Entries having the same key as a system-controlled entry
in the list '/routing/ribs/rib' are used for
configuring parameters of that entry.  Other entries
define additional user-controlled RIBs.
    """
    return self.__rib
      
  def _set_rib(self, v, load=False):
    """
    Setter method for rib, mapped from YANG variable /routing/ribs/rib (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rib is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rib() directly.

    YANG Description: Each entry contains a configuration for a RIB identified
by the 'name' key.

Entries having the same key as a system-controlled entry
in the list '/routing/ribs/rib' are used for
configuring parameters of that entry.  Other entries
define additional user-controlled RIBs.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_rib_ietf_routing__routing_ribs_rib, yang_name="rib", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="rib", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rib must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_rib_ietf_routing__routing_ribs_rib, yang_name="rib", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="rib", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=True)""",
        })

    self.__rib = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rib(self):
    self.__rib = YANGDynClass(base=YANGListType("name",yc_rib_ietf_routing__routing_ribs_rib, yang_name="rib", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="rib", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=True)

  rib = __builtin__.property(_get_rib, _set_rib) # type: yc_rib_ietf_routing__routing_ribs_rib


  _pyangbind_elements = OrderedDict([('rib', rib), ])


class yc_routing_ietf_routing__routing(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration parameters for the routing subsystem.
  """
  __slots__ = ('_path_helper', '_extmethods', '__router_id','__interfaces','__control_plane_protocols','__ribs',)

  _yang_name = 'routing'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__router_id = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='yang:dotted-quad', is_config=True)
    self.__interfaces = YANGDynClass(base=yc_interfaces_ietf_routing__routing_interfaces, is_container='container', yang_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)
    self.__control_plane_protocols = YANGDynClass(base=yc_control_plane_protocols_ietf_routing__routing_control_plane_protocols, is_container='container', yang_name="control-plane-protocols", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)
    self.__ribs = YANGDynClass(base=yc_ribs_ietf_routing__routing_ribs, is_container='container', yang_name="ribs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing']

  def _get_router_id(self):
    """
    Getter method for router_id, mapped from YANG variable /routing/router_id (yang:dotted-quad)

    YANG Description: A 32-bit number in the form of a dotted quad that is used by
some routing protocols identifying a router.
    """
    return self.__router_id
      
  def _set_router_id(self, v, load=False):
    """
    Setter method for router_id, mapped from YANG variable /routing/router_id (yang:dotted-quad)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_router_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_router_id() directly.

    YANG Description: A 32-bit number in the form of a dotted quad that is used by
some routing protocols identifying a router.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='yang:dotted-quad', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """router_id must be of a type compatible with yang:dotted-quad""",
          'defined-type': "yang:dotted-quad",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='yang:dotted-quad', is_config=True)""",
        })

    self.__router_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_router_id(self):
    self.__router_id = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='yang:dotted-quad', is_config=True)


  def _get_interfaces(self):
    """
    Getter method for interfaces, mapped from YANG variable /routing/interfaces (container)

    YANG Description: Network-layer interfaces used for routing.
    """
    return self.__interfaces
      
  def _set_interfaces(self, v, load=False):
    """
    Setter method for interfaces, mapped from YANG variable /routing/interfaces (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interfaces is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interfaces() directly.

    YANG Description: Network-layer interfaces used for routing.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_interfaces_ietf_routing__routing_interfaces, is_container='container', yang_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interfaces must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_interfaces_ietf_routing__routing_interfaces, is_container='container', yang_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)""",
        })

    self.__interfaces = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interfaces(self):
    self.__interfaces = YANGDynClass(base=yc_interfaces_ietf_routing__routing_interfaces, is_container='container', yang_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)


  def _get_control_plane_protocols(self):
    """
    Getter method for control_plane_protocols, mapped from YANG variable /routing/control_plane_protocols (container)

    YANG Description: Support for control-plane protocol instances.
    """
    return self.__control_plane_protocols
      
  def _set_control_plane_protocols(self, v, load=False):
    """
    Setter method for control_plane_protocols, mapped from YANG variable /routing/control_plane_protocols (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_control_plane_protocols is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_control_plane_protocols() directly.

    YANG Description: Support for control-plane protocol instances.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_control_plane_protocols_ietf_routing__routing_control_plane_protocols, is_container='container', yang_name="control-plane-protocols", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """control_plane_protocols must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_control_plane_protocols_ietf_routing__routing_control_plane_protocols, is_container='container', yang_name="control-plane-protocols", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)""",
        })

    self.__control_plane_protocols = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_control_plane_protocols(self):
    self.__control_plane_protocols = YANGDynClass(base=yc_control_plane_protocols_ietf_routing__routing_control_plane_protocols, is_container='container', yang_name="control-plane-protocols", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)


  def _get_ribs(self):
    """
    Getter method for ribs, mapped from YANG variable /routing/ribs (container)

    YANG Description: Support for RIBs.
    """
    return self.__ribs
      
  def _set_ribs(self, v, load=False):
    """
    Setter method for ribs, mapped from YANG variable /routing/ribs (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ribs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ribs() directly.

    YANG Description: Support for RIBs.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ribs_ietf_routing__routing_ribs, is_container='container', yang_name="ribs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ribs must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ribs_ietf_routing__routing_ribs, is_container='container', yang_name="ribs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)""",
        })

    self.__ribs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ribs(self):
    self.__ribs = YANGDynClass(base=yc_ribs_ietf_routing__routing_ribs, is_container='container', yang_name="ribs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)

  router_id = __builtin__.property(_get_router_id, _set_router_id)
  interfaces = __builtin__.property(_get_interfaces, _set_interfaces) # type: yc_interfaces_ietf_routing__routing_interfaces
  control_plane_protocols = __builtin__.property(_get_control_plane_protocols, _set_control_plane_protocols) # type: yc_control_plane_protocols_ietf_routing__routing_control_plane_protocols
  ribs = __builtin__.property(_get_ribs, _set_ribs) # type: yc_ribs_ietf_routing__routing_ribs


  _pyangbind_elements = OrderedDict([('router_id', router_id), ('interfaces', interfaces), ('control_plane_protocols', control_plane_protocols), ('ribs', ribs), ])


class yc_interfaces_ietf_routing__routing_state_interfaces(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing-state/interfaces. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Network-layer interfaces used for routing.
  """
  __slots__ = ('_path_helper', '_extmethods', '__interface',)

  _yang_name = 'interfaces'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__interface = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-state-ref', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing-state', 'interfaces']

  def _get_interface(self):
    """
    Getter method for interface, mapped from YANG variable /routing_state/interfaces/interface (if:interface-state-ref)

    YANG Description: Each entry is a reference to the name of a configured
network-layer interface.
    """
    return self.__interface
      
  def _set_interface(self, v, load=False):
    """
    Setter method for interface, mapped from YANG variable /routing_state/interfaces/interface (if:interface-state-ref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface() directly.

    YANG Description: Each entry is a reference to the name of a configured
network-layer interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-state-ref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface must be of a type compatible with if:interface-state-ref""",
          'defined-type': "if:interface-state-ref",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-state-ref', is_config=False)""",
        })

    self.__interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface(self):
    self.__interface = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-state-ref', is_config=False)

  interface = __builtin__.property(_get_interface)


  _pyangbind_elements = OrderedDict([('interface', interface), ])


class yc_control_plane_protocol_ietf_routing__routing_state_control_plane_protocols_control_plane_protocol(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing-state/control-plane-protocols/control-plane-protocol. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: State data of a control-plane protocol instance.

An implementation MUST provide exactly one
system-controlled instance of the 'direct'
pseudo-protocol.  Instances of other control-plane
protocols MAY be created by configuration.
  """
  __slots__ = ('_path_helper', '_extmethods', '__type','__name',)

  _yang_name = 'control-plane-protocol'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'routing-protocol': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:routing-protocol': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'direct': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:direct': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'static': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:static': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=False)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing-state', 'control-plane-protocols', 'control-plane-protocol']

  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /routing_state/control_plane_protocols/control_plane_protocol/type (identityref)

    YANG Description: Type of the control-plane protocol.
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /routing_state/control_plane_protocols/control_plane_protocol/type (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: Type of the control-plane protocol.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'routing-protocol': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:routing-protocol': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'direct': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:direct': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'static': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:static': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with identityref""",
          'defined-type': "ietf-routing:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'routing-protocol': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:routing-protocol': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'direct': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:direct': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'static': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:static': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=False)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'routing-protocol': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:routing-protocol': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'direct': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:direct': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'static': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:static': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=False)


  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /routing_state/control_plane_protocols/control_plane_protocol/name (string)

    YANG Description: The name of the control-plane protocol instance.

For system-controlled instances, this name is
persistent, i.e., it SHOULD NOT change across
reboots.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /routing_state/control_plane_protocols/control_plane_protocol/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: The name of the control-plane protocol instance.

For system-controlled instances, this name is
persistent, i.e., it SHOULD NOT change across
reboots.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=False)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=False)

  type = __builtin__.property(_get_type)
  name = __builtin__.property(_get_name)


  _pyangbind_elements = OrderedDict([('type', type), ('name', name), ])


class yc_control_plane_protocols_ietf_routing__routing_state_control_plane_protocols(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing-state/control-plane-protocols. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container for the list of routing protocol instances.
  """
  __slots__ = ('_path_helper', '_extmethods', '__control_plane_protocol',)

  _yang_name = 'control-plane-protocols'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__control_plane_protocol = YANGDynClass(base=YANGListType("type name",yc_control_plane_protocol_ietf_routing__routing_state_control_plane_protocols_control_plane_protocol, yang_name="control-plane-protocol", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='type name', extensions=None), is_container='list', yang_name="control-plane-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing-state', 'control-plane-protocols']

  def _get_control_plane_protocol(self):
    """
    Getter method for control_plane_protocol, mapped from YANG variable /routing_state/control_plane_protocols/control_plane_protocol (list)

    YANG Description: State data of a control-plane protocol instance.

An implementation MUST provide exactly one
system-controlled instance of the 'direct'
pseudo-protocol.  Instances of other control-plane
protocols MAY be created by configuration.
    """
    return self.__control_plane_protocol
      
  def _set_control_plane_protocol(self, v, load=False):
    """
    Setter method for control_plane_protocol, mapped from YANG variable /routing_state/control_plane_protocols/control_plane_protocol (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_control_plane_protocol is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_control_plane_protocol() directly.

    YANG Description: State data of a control-plane protocol instance.

An implementation MUST provide exactly one
system-controlled instance of the 'direct'
pseudo-protocol.  Instances of other control-plane
protocols MAY be created by configuration.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("type name",yc_control_plane_protocol_ietf_routing__routing_state_control_plane_protocols_control_plane_protocol, yang_name="control-plane-protocol", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='type name', extensions=None), is_container='list', yang_name="control-plane-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """control_plane_protocol must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("type name",yc_control_plane_protocol_ietf_routing__routing_state_control_plane_protocols_control_plane_protocol, yang_name="control-plane-protocol", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='type name', extensions=None), is_container='list', yang_name="control-plane-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)""",
        })

    self.__control_plane_protocol = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_control_plane_protocol(self):
    self.__control_plane_protocol = YANGDynClass(base=YANGListType("type name",yc_control_plane_protocol_ietf_routing__routing_state_control_plane_protocols_control_plane_protocol, yang_name="control-plane-protocol", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='type name', extensions=None), is_container='list', yang_name="control-plane-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)

  control_plane_protocol = __builtin__.property(_get_control_plane_protocol) # type: yc_control_plane_protocol_ietf_routing__routing_state_control_plane_protocols_control_plane_protocol


  _pyangbind_elements = OrderedDict([('control_plane_protocol', control_plane_protocol), ])


class yc_next_hop_ietf_routing__routing_state_ribs_rib_routes_route_next_hop_next_hop_list_next_hop(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing-state/ribs/rib/routes/route/next-hop/next-hop-list/next-hop. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: An entry in a next-hop list.

Modules for address families MUST augment this list
with a leaf containing a next-hop address of that
address family.
  """
  __slots__ = ('_path_helper', '_extmethods', '__outgoing_interface',)

  _yang_name = 'next-hop'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__outgoing_interface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="outgoing-interface", parent=self, choice=('next-hop-options', 'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing-state', 'ribs', 'rib', 'routes', 'route', 'next-hop', 'next-hop-list', 'next-hop']

  def _get_outgoing_interface(self):
    """
    Getter method for outgoing_interface, mapped from YANG variable /routing_state/ribs/rib/routes/route/next_hop/next_hop_list/next_hop/outgoing_interface (if:interface-ref)

    YANG Description: Name of the outgoing interface.
    """
    return self.__outgoing_interface
      
  def _set_outgoing_interface(self, v, load=False):
    """
    Setter method for outgoing_interface, mapped from YANG variable /routing_state/ribs/rib/routes/route/next_hop/next_hop_list/next_hop/outgoing_interface (if:interface-ref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_outgoing_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_outgoing_interface() directly.

    YANG Description: Name of the outgoing interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="outgoing-interface", parent=self, choice=('next-hop-options', 'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """outgoing_interface must be of a type compatible with if:interface-ref""",
          'defined-type': "if:interface-ref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="outgoing-interface", parent=self, choice=('next-hop-options', 'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=False)""",
        })

    self.__outgoing_interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_outgoing_interface(self):
    self.__outgoing_interface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="outgoing-interface", parent=self, choice=('next-hop-options', 'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=False)

  outgoing_interface = __builtin__.property(_get_outgoing_interface)

  __choices__ = {'next-hop-options': {'next-hop-list': ['outgoing_interface']}}
  _pyangbind_elements = OrderedDict([('outgoing_interface', outgoing_interface), ])


class yc_next_hop_list_ietf_routing__routing_state_ribs_rib_routes_route_next_hop_next_hop_list(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing-state/ribs/rib/routes/route/next-hop/next-hop-list. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container for multiple next hops.
  """
  __slots__ = ('_path_helper', '_extmethods', '__next_hop',)

  _yang_name = 'next-hop-list'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__next_hop = YANGDynClass(base=YANGListType(False,yc_next_hop_ietf_routing__routing_state_ribs_rib_routes_route_next_hop_next_hop_list_next_hop, yang_name="next-hop", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='False', extensions=None, choice=('next-hop-options', 'next-hop-list')), is_container='list', yang_name="next-hop", parent=self, choice=('next-hop-options', 'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing-state', 'ribs', 'rib', 'routes', 'route', 'next-hop', 'next-hop-list']

  def _get_next_hop(self):
    """
    Getter method for next_hop, mapped from YANG variable /routing_state/ribs/rib/routes/route/next_hop/next_hop_list/next_hop (list)

    YANG Description: An entry in a next-hop list.

Modules for address families MUST augment this list
with a leaf containing a next-hop address of that
address family.
    """
    return self.__next_hop
      
  def _set_next_hop(self, v, load=False):
    """
    Setter method for next_hop, mapped from YANG variable /routing_state/ribs/rib/routes/route/next_hop/next_hop_list/next_hop (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_next_hop is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_next_hop() directly.

    YANG Description: An entry in a next-hop list.

Modules for address families MUST augment this list
with a leaf containing a next-hop address of that
address family.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType(False,yc_next_hop_ietf_routing__routing_state_ribs_rib_routes_route_next_hop_next_hop_list_next_hop, yang_name="next-hop", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='False', extensions=None, choice=('next-hop-options', 'next-hop-list')), is_container='list', yang_name="next-hop", parent=self, choice=('next-hop-options', 'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """next_hop must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType(False,yc_next_hop_ietf_routing__routing_state_ribs_rib_routes_route_next_hop_next_hop_list_next_hop, yang_name="next-hop", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='False', extensions=None, choice=('next-hop-options', 'next-hop-list')), is_container='list', yang_name="next-hop", parent=self, choice=('next-hop-options', 'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)""",
        })

    self.__next_hop = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_next_hop(self):
    self.__next_hop = YANGDynClass(base=YANGListType(False,yc_next_hop_ietf_routing__routing_state_ribs_rib_routes_route_next_hop_next_hop_list_next_hop, yang_name="next-hop", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='False', extensions=None, choice=('next-hop-options', 'next-hop-list')), is_container='list', yang_name="next-hop", parent=self, choice=('next-hop-options', 'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)

  next_hop = __builtin__.property(_get_next_hop) # type: yc_next_hop_ietf_routing__routing_state_ribs_rib_routes_route_next_hop_next_hop_list_next_hop

  __choices__ = {'next-hop-options': {'next-hop-list': ['next_hop']}}
  _pyangbind_elements = OrderedDict([('next_hop', next_hop), ])


class yc_next_hop_ietf_routing__routing_state_ribs_rib_routes_route_next_hop(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing-state/ribs/rib/routes/route/next-hop. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Route's next-hop attribute.
  """
  __slots__ = ('_path_helper', '_extmethods', '__outgoing_interface','__special_next_hop','__next_hop_list',)

  _yang_name = 'next-hop'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__outgoing_interface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="outgoing-interface", parent=self, choice=('next-hop-options', 'simple-next-hop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=False)
    self.__special_next_hop = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'blackhole': {}, 'unreachable': {}, 'prohibit': {}, 'receive': {}},), is_leaf=True, yang_name="special-next-hop", parent=self, choice=('next-hop-options', 'special-next-hop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='enumeration', is_config=False)
    self.__next_hop_list = YANGDynClass(base=yc_next_hop_list_ietf_routing__routing_state_ribs_rib_routes_route_next_hop_next_hop_list, is_container='container', yang_name="next-hop-list", parent=self, choice=('next-hop-options', 'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing-state', 'ribs', 'rib', 'routes', 'route', 'next-hop']

  def _get_outgoing_interface(self):
    """
    Getter method for outgoing_interface, mapped from YANG variable /routing_state/ribs/rib/routes/route/next_hop/outgoing_interface (if:interface-ref)

    YANG Description: Name of the outgoing interface.
    """
    return self.__outgoing_interface
      
  def _set_outgoing_interface(self, v, load=False):
    """
    Setter method for outgoing_interface, mapped from YANG variable /routing_state/ribs/rib/routes/route/next_hop/outgoing_interface (if:interface-ref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_outgoing_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_outgoing_interface() directly.

    YANG Description: Name of the outgoing interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="outgoing-interface", parent=self, choice=('next-hop-options', 'simple-next-hop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """outgoing_interface must be of a type compatible with if:interface-ref""",
          'defined-type': "if:interface-ref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="outgoing-interface", parent=self, choice=('next-hop-options', 'simple-next-hop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=False)""",
        })

    self.__outgoing_interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_outgoing_interface(self):
    self.__outgoing_interface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="outgoing-interface", parent=self, choice=('next-hop-options', 'simple-next-hop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=False)


  def _get_special_next_hop(self):
    """
    Getter method for special_next_hop, mapped from YANG variable /routing_state/ribs/rib/routes/route/next_hop/special_next_hop (enumeration)

    YANG Description: Options for special next hops.
    """
    return self.__special_next_hop
      
  def _set_special_next_hop(self, v, load=False):
    """
    Setter method for special_next_hop, mapped from YANG variable /routing_state/ribs/rib/routes/route/next_hop/special_next_hop (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_special_next_hop is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_special_next_hop() directly.

    YANG Description: Options for special next hops.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'blackhole': {}, 'unreachable': {}, 'prohibit': {}, 'receive': {}},), is_leaf=True, yang_name="special-next-hop", parent=self, choice=('next-hop-options', 'special-next-hop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='enumeration', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """special_next_hop must be of a type compatible with enumeration""",
          'defined-type': "ietf-routing:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'blackhole': {}, 'unreachable': {}, 'prohibit': {}, 'receive': {}},), is_leaf=True, yang_name="special-next-hop", parent=self, choice=('next-hop-options', 'special-next-hop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='enumeration', is_config=False)""",
        })

    self.__special_next_hop = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_special_next_hop(self):
    self.__special_next_hop = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'blackhole': {}, 'unreachable': {}, 'prohibit': {}, 'receive': {}},), is_leaf=True, yang_name="special-next-hop", parent=self, choice=('next-hop-options', 'special-next-hop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='enumeration', is_config=False)


  def _get_next_hop_list(self):
    """
    Getter method for next_hop_list, mapped from YANG variable /routing_state/ribs/rib/routes/route/next_hop/next_hop_list (container)

    YANG Description: Container for multiple next hops.
    """
    return self.__next_hop_list
      
  def _set_next_hop_list(self, v, load=False):
    """
    Setter method for next_hop_list, mapped from YANG variable /routing_state/ribs/rib/routes/route/next_hop/next_hop_list (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_next_hop_list is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_next_hop_list() directly.

    YANG Description: Container for multiple next hops.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_next_hop_list_ietf_routing__routing_state_ribs_rib_routes_route_next_hop_next_hop_list, is_container='container', yang_name="next-hop-list", parent=self, choice=('next-hop-options', 'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """next_hop_list must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_next_hop_list_ietf_routing__routing_state_ribs_rib_routes_route_next_hop_next_hop_list, is_container='container', yang_name="next-hop-list", parent=self, choice=('next-hop-options', 'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)""",
        })

    self.__next_hop_list = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_next_hop_list(self):
    self.__next_hop_list = YANGDynClass(base=yc_next_hop_list_ietf_routing__routing_state_ribs_rib_routes_route_next_hop_next_hop_list, is_container='container', yang_name="next-hop-list", parent=self, choice=('next-hop-options', 'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)

  outgoing_interface = __builtin__.property(_get_outgoing_interface)
  special_next_hop = __builtin__.property(_get_special_next_hop)
  next_hop_list = __builtin__.property(_get_next_hop_list) # type: yc_next_hop_list_ietf_routing__routing_state_ribs_rib_routes_route_next_hop_next_hop_list

  __choices__ = {'next-hop-options': {'simple-next-hop': ['outgoing_interface'], 'special-next-hop': ['special_next_hop'], 'next-hop-list': ['next_hop_list']}}
  _pyangbind_elements = OrderedDict([('outgoing_interface', outgoing_interface), ('special_next_hop', special_next_hop), ('next_hop_list', next_hop_list), ])


class yc_route_ietf_routing__routing_state_ribs_rib_routes_route(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing-state/ribs/rib/routes/route. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: A RIB route entry.  This data node MUST be augmented
with information specific to routes of each address
family.
  """
  __slots__ = ('_path_helper', '_extmethods', '__route_preference','__next_hop','__source_protocol','__active','__last_updated',)

  _yang_name = 'route'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__route_preference = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="route-preference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='route-preference', is_config=False)
    self.__next_hop = YANGDynClass(base=yc_next_hop_ietf_routing__routing_state_ribs_rib_routes_route_next_hop, is_container='container', yang_name="next-hop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)
    self.__source_protocol = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'direct': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:direct': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'static': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:static': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}},), is_leaf=True, yang_name="source-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=False)
    self.__active = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="active", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='empty', is_config=False)
    self.__last_updated = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="last-updated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='yang:date-and-time', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing-state', 'ribs', 'rib', 'routes', 'route']

  def _get_route_preference(self):
    """
    Getter method for route_preference, mapped from YANG variable /routing_state/ribs/rib/routes/route/route_preference (route-preference)

    YANG Description: This route attribute, also known as 'administrative
distance', allows for selecting the preferred route
among routes with the same destination prefix.  A
smaller value indicates a route that is
more preferred.
    """
    return self.__route_preference
      
  def _set_route_preference(self, v, load=False):
    """
    Setter method for route_preference, mapped from YANG variable /routing_state/ribs/rib/routes/route/route_preference (route-preference)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_route_preference is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_route_preference() directly.

    YANG Description: This route attribute, also known as 'administrative
distance', allows for selecting the preferred route
among routes with the same destination prefix.  A
smaller value indicates a route that is
more preferred.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="route-preference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='route-preference', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """route_preference must be of a type compatible with route-preference""",
          'defined-type': "ietf-routing:route-preference",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="route-preference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='route-preference', is_config=False)""",
        })

    self.__route_preference = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_route_preference(self):
    self.__route_preference = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="route-preference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='route-preference', is_config=False)


  def _get_next_hop(self):
    """
    Getter method for next_hop, mapped from YANG variable /routing_state/ribs/rib/routes/route/next_hop (container)

    YANG Description: Route's next-hop attribute.
    """
    return self.__next_hop
      
  def _set_next_hop(self, v, load=False):
    """
    Setter method for next_hop, mapped from YANG variable /routing_state/ribs/rib/routes/route/next_hop (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_next_hop is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_next_hop() directly.

    YANG Description: Route's next-hop attribute.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_next_hop_ietf_routing__routing_state_ribs_rib_routes_route_next_hop, is_container='container', yang_name="next-hop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """next_hop must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_next_hop_ietf_routing__routing_state_ribs_rib_routes_route_next_hop, is_container='container', yang_name="next-hop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)""",
        })

    self.__next_hop = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_next_hop(self):
    self.__next_hop = YANGDynClass(base=yc_next_hop_ietf_routing__routing_state_ribs_rib_routes_route_next_hop, is_container='container', yang_name="next-hop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)


  def _get_source_protocol(self):
    """
    Getter method for source_protocol, mapped from YANG variable /routing_state/ribs/rib/routes/route/source_protocol (identityref)

    YANG Description: Type of the routing protocol from which the route
originated.
    """
    return self.__source_protocol
      
  def _set_source_protocol(self, v, load=False):
    """
    Setter method for source_protocol, mapped from YANG variable /routing_state/ribs/rib/routes/route/source_protocol (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_source_protocol is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_source_protocol() directly.

    YANG Description: Type of the routing protocol from which the route
originated.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'direct': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:direct': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'static': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:static': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}},), is_leaf=True, yang_name="source-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """source_protocol must be of a type compatible with identityref""",
          'defined-type': "ietf-routing:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'direct': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:direct': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'static': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:static': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}},), is_leaf=True, yang_name="source-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=False)""",
        })

    self.__source_protocol = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_source_protocol(self):
    self.__source_protocol = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'direct': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:direct': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'static': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:static': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}},), is_leaf=True, yang_name="source-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=False)


  def _get_active(self):
    """
    Getter method for active, mapped from YANG variable /routing_state/ribs/rib/routes/route/active (empty)

    YANG Description: The presence of this leaf indicates that the route is
preferred among all routes in the same RIB that have the
same destination prefix.
    """
    return self.__active
      
  def _set_active(self, v, load=False):
    """
    Setter method for active, mapped from YANG variable /routing_state/ribs/rib/routes/route/active (empty)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_active is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_active() directly.

    YANG Description: The presence of this leaf indicates that the route is
preferred among all routes in the same RIB that have the
same destination prefix.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="active", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='empty', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """active must be of a type compatible with empty""",
          'defined-type': "empty",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="active", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='empty', is_config=False)""",
        })

    self.__active = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_active(self):
    self.__active = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="active", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='empty', is_config=False)


  def _get_last_updated(self):
    """
    Getter method for last_updated, mapped from YANG variable /routing_state/ribs/rib/routes/route/last_updated (yang:date-and-time)

    YANG Description: Timestamp of the last modification of the route.  If the
route was never modified, it is the time when the route was
inserted into the RIB.
    """
    return self.__last_updated
      
  def _set_last_updated(self, v, load=False):
    """
    Setter method for last_updated, mapped from YANG variable /routing_state/ribs/rib/routes/route/last_updated (yang:date-and-time)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_last_updated is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_last_updated() directly.

    YANG Description: Timestamp of the last modification of the route.  If the
route was never modified, it is the time when the route was
inserted into the RIB.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="last-updated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='yang:date-and-time', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """last_updated must be of a type compatible with yang:date-and-time""",
          'defined-type': "yang:date-and-time",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="last-updated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='yang:date-and-time', is_config=False)""",
        })

    self.__last_updated = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_last_updated(self):
    self.__last_updated = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="last-updated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='yang:date-and-time', is_config=False)

  route_preference = __builtin__.property(_get_route_preference)
  next_hop = __builtin__.property(_get_next_hop) # type: yc_next_hop_ietf_routing__routing_state_ribs_rib_routes_route_next_hop
  source_protocol = __builtin__.property(_get_source_protocol)
  active = __builtin__.property(_get_active)
  last_updated = __builtin__.property(_get_last_updated)


  _pyangbind_elements = OrderedDict([('route_preference', route_preference), ('next_hop', next_hop), ('source_protocol', source_protocol), ('active', active), ('last_updated', last_updated), ])


class yc_routes_ietf_routing__routing_state_ribs_rib_routes(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing-state/ribs/rib/routes. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Current contents of the RIB.
  """
  __slots__ = ('_path_helper', '_extmethods', '__route',)

  _yang_name = 'routes'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__route = YANGDynClass(base=YANGListType(False,yc_route_ietf_routing__routing_state_ribs_rib_routes_route, yang_name="route", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='False', extensions=None), is_container='list', yang_name="route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing-state', 'ribs', 'rib', 'routes']

  def _get_route(self):
    """
    Getter method for route, mapped from YANG variable /routing_state/ribs/rib/routes/route (list)

    YANG Description: A RIB route entry.  This data node MUST be augmented
with information specific to routes of each address
family.
    """
    return self.__route
      
  def _set_route(self, v, load=False):
    """
    Setter method for route, mapped from YANG variable /routing_state/ribs/rib/routes/route (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_route is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_route() directly.

    YANG Description: A RIB route entry.  This data node MUST be augmented
with information specific to routes of each address
family.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType(False,yc_route_ietf_routing__routing_state_ribs_rib_routes_route, yang_name="route", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='False', extensions=None), is_container='list', yang_name="route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """route must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType(False,yc_route_ietf_routing__routing_state_ribs_rib_routes_route, yang_name="route", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='False', extensions=None), is_container='list', yang_name="route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)""",
        })

    self.__route = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_route(self):
    self.__route = YANGDynClass(base=YANGListType(False,yc_route_ietf_routing__routing_state_ribs_rib_routes_route, yang_name="route", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='False', extensions=None), is_container='list', yang_name="route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)

  route = __builtin__.property(_get_route) # type: yc_route_ietf_routing__routing_state_ribs_rib_routes_route


  _pyangbind_elements = OrderedDict([('route', route), ])


class yc_next_hop_ietf_routing__routing_state_ribs_rib_active_route_output_route_next_hop_next_hop_list_next_hop(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing-state/ribs/rib/active-route/output/route/next-hop/next-hop-list/next-hop. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: An entry in a next-hop list.

Modules for address families MUST augment this list
with a leaf containing a next-hop address of that
address family.
  """
  __slots__ = ('_path_helper', '_extmethods', '__outgoing_interface',)

  _yang_name = 'next-hop'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__outgoing_interface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="outgoing-interface", parent=self, choice=('next-hop-options', 'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing-state', 'ribs', 'rib', 'active-route', 'output', 'route', 'next-hop', 'next-hop-list', 'next-hop']

  def _get_outgoing_interface(self):
    """
    Getter method for outgoing_interface, mapped from YANG variable /routing_state/ribs/rib/active_route/output/route/next_hop/next_hop_list/next_hop/outgoing_interface (if:interface-ref)

    YANG Description: Name of the outgoing interface.
    """
    return self.__outgoing_interface
      
  def _set_outgoing_interface(self, v, load=False):
    """
    Setter method for outgoing_interface, mapped from YANG variable /routing_state/ribs/rib/active_route/output/route/next_hop/next_hop_list/next_hop/outgoing_interface (if:interface-ref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_outgoing_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_outgoing_interface() directly.

    YANG Description: Name of the outgoing interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="outgoing-interface", parent=self, choice=('next-hop-options', 'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """outgoing_interface must be of a type compatible with if:interface-ref""",
          'defined-type': "if:interface-ref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="outgoing-interface", parent=self, choice=('next-hop-options', 'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=False)""",
        })

    self.__outgoing_interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_outgoing_interface(self):
    self.__outgoing_interface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="outgoing-interface", parent=self, choice=('next-hop-options', 'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=False)

  outgoing_interface = __builtin__.property(_get_outgoing_interface)

  __choices__ = {'next-hop-options': {'next-hop-list': ['outgoing_interface']}}
  _pyangbind_elements = OrderedDict([('outgoing_interface', outgoing_interface), ])


class yc_next_hop_list_ietf_routing__routing_state_ribs_rib_active_route_output_route_next_hop_next_hop_list(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing-state/ribs/rib/active-route/output/route/next-hop/next-hop-list. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container for multiple next hops.
  """
  __slots__ = ('_path_helper', '_extmethods', '__next_hop',)

  _yang_name = 'next-hop-list'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__next_hop = YANGDynClass(base=YANGListType(False,yc_next_hop_ietf_routing__routing_state_ribs_rib_active_route_output_route_next_hop_next_hop_list_next_hop, yang_name="next-hop", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='False', extensions=None, choice=('next-hop-options', 'next-hop-list')), is_container='list', yang_name="next-hop", parent=self, choice=('next-hop-options', 'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing-state', 'ribs', 'rib', 'active-route', 'output', 'route', 'next-hop', 'next-hop-list']

  def _get_next_hop(self):
    """
    Getter method for next_hop, mapped from YANG variable /routing_state/ribs/rib/active_route/output/route/next_hop/next_hop_list/next_hop (list)

    YANG Description: An entry in a next-hop list.

Modules for address families MUST augment this list
with a leaf containing a next-hop address of that
address family.
    """
    return self.__next_hop
      
  def _set_next_hop(self, v, load=False):
    """
    Setter method for next_hop, mapped from YANG variable /routing_state/ribs/rib/active_route/output/route/next_hop/next_hop_list/next_hop (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_next_hop is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_next_hop() directly.

    YANG Description: An entry in a next-hop list.

Modules for address families MUST augment this list
with a leaf containing a next-hop address of that
address family.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType(False,yc_next_hop_ietf_routing__routing_state_ribs_rib_active_route_output_route_next_hop_next_hop_list_next_hop, yang_name="next-hop", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='False', extensions=None, choice=('next-hop-options', 'next-hop-list')), is_container='list', yang_name="next-hop", parent=self, choice=('next-hop-options', 'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """next_hop must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType(False,yc_next_hop_ietf_routing__routing_state_ribs_rib_active_route_output_route_next_hop_next_hop_list_next_hop, yang_name="next-hop", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='False', extensions=None, choice=('next-hop-options', 'next-hop-list')), is_container='list', yang_name="next-hop", parent=self, choice=('next-hop-options', 'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)""",
        })

    self.__next_hop = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_next_hop(self):
    self.__next_hop = YANGDynClass(base=YANGListType(False,yc_next_hop_ietf_routing__routing_state_ribs_rib_active_route_output_route_next_hop_next_hop_list_next_hop, yang_name="next-hop", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='False', extensions=None, choice=('next-hop-options', 'next-hop-list')), is_container='list', yang_name="next-hop", parent=self, choice=('next-hop-options', 'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)

  next_hop = __builtin__.property(_get_next_hop) # type: yc_next_hop_ietf_routing__routing_state_ribs_rib_active_route_output_route_next_hop_next_hop_list_next_hop

  __choices__ = {'next-hop-options': {'next-hop-list': ['next_hop']}}
  _pyangbind_elements = OrderedDict([('next_hop', next_hop), ])


class yc_next_hop_ietf_routing__routing_state_ribs_rib_active_route_output_route_next_hop(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing-state/ribs/rib/active-route/output/route/next-hop. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Route's next-hop attribute.
  """
  __slots__ = ('_path_helper', '_extmethods', '__outgoing_interface','__special_next_hop','__next_hop_list',)

  _yang_name = 'next-hop'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__outgoing_interface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="outgoing-interface", parent=self, choice=('next-hop-options', 'simple-next-hop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=False)
    self.__special_next_hop = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'blackhole': {}, 'unreachable': {}, 'prohibit': {}, 'receive': {}},), is_leaf=True, yang_name="special-next-hop", parent=self, choice=('next-hop-options', 'special-next-hop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='enumeration', is_config=False)
    self.__next_hop_list = YANGDynClass(base=yc_next_hop_list_ietf_routing__routing_state_ribs_rib_active_route_output_route_next_hop_next_hop_list, is_container='container', yang_name="next-hop-list", parent=self, choice=('next-hop-options', 'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing-state', 'ribs', 'rib', 'active-route', 'output', 'route', 'next-hop']

  def _get_outgoing_interface(self):
    """
    Getter method for outgoing_interface, mapped from YANG variable /routing_state/ribs/rib/active_route/output/route/next_hop/outgoing_interface (if:interface-ref)

    YANG Description: Name of the outgoing interface.
    """
    return self.__outgoing_interface
      
  def _set_outgoing_interface(self, v, load=False):
    """
    Setter method for outgoing_interface, mapped from YANG variable /routing_state/ribs/rib/active_route/output/route/next_hop/outgoing_interface (if:interface-ref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_outgoing_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_outgoing_interface() directly.

    YANG Description: Name of the outgoing interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="outgoing-interface", parent=self, choice=('next-hop-options', 'simple-next-hop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """outgoing_interface must be of a type compatible with if:interface-ref""",
          'defined-type': "if:interface-ref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="outgoing-interface", parent=self, choice=('next-hop-options', 'simple-next-hop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=False)""",
        })

    self.__outgoing_interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_outgoing_interface(self):
    self.__outgoing_interface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="outgoing-interface", parent=self, choice=('next-hop-options', 'simple-next-hop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=False)


  def _get_special_next_hop(self):
    """
    Getter method for special_next_hop, mapped from YANG variable /routing_state/ribs/rib/active_route/output/route/next_hop/special_next_hop (enumeration)

    YANG Description: Options for special next hops.
    """
    return self.__special_next_hop
      
  def _set_special_next_hop(self, v, load=False):
    """
    Setter method for special_next_hop, mapped from YANG variable /routing_state/ribs/rib/active_route/output/route/next_hop/special_next_hop (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_special_next_hop is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_special_next_hop() directly.

    YANG Description: Options for special next hops.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'blackhole': {}, 'unreachable': {}, 'prohibit': {}, 'receive': {}},), is_leaf=True, yang_name="special-next-hop", parent=self, choice=('next-hop-options', 'special-next-hop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='enumeration', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """special_next_hop must be of a type compatible with enumeration""",
          'defined-type': "ietf-routing:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'blackhole': {}, 'unreachable': {}, 'prohibit': {}, 'receive': {}},), is_leaf=True, yang_name="special-next-hop", parent=self, choice=('next-hop-options', 'special-next-hop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='enumeration', is_config=False)""",
        })

    self.__special_next_hop = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_special_next_hop(self):
    self.__special_next_hop = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'blackhole': {}, 'unreachable': {}, 'prohibit': {}, 'receive': {}},), is_leaf=True, yang_name="special-next-hop", parent=self, choice=('next-hop-options', 'special-next-hop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='enumeration', is_config=False)


  def _get_next_hop_list(self):
    """
    Getter method for next_hop_list, mapped from YANG variable /routing_state/ribs/rib/active_route/output/route/next_hop/next_hop_list (container)

    YANG Description: Container for multiple next hops.
    """
    return self.__next_hop_list
      
  def _set_next_hop_list(self, v, load=False):
    """
    Setter method for next_hop_list, mapped from YANG variable /routing_state/ribs/rib/active_route/output/route/next_hop/next_hop_list (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_next_hop_list is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_next_hop_list() directly.

    YANG Description: Container for multiple next hops.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_next_hop_list_ietf_routing__routing_state_ribs_rib_active_route_output_route_next_hop_next_hop_list, is_container='container', yang_name="next-hop-list", parent=self, choice=('next-hop-options', 'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """next_hop_list must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_next_hop_list_ietf_routing__routing_state_ribs_rib_active_route_output_route_next_hop_next_hop_list, is_container='container', yang_name="next-hop-list", parent=self, choice=('next-hop-options', 'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)""",
        })

    self.__next_hop_list = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_next_hop_list(self):
    self.__next_hop_list = YANGDynClass(base=yc_next_hop_list_ietf_routing__routing_state_ribs_rib_active_route_output_route_next_hop_next_hop_list, is_container='container', yang_name="next-hop-list", parent=self, choice=('next-hop-options', 'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)

  outgoing_interface = __builtin__.property(_get_outgoing_interface)
  special_next_hop = __builtin__.property(_get_special_next_hop)
  next_hop_list = __builtin__.property(_get_next_hop_list) # type: yc_next_hop_list_ietf_routing__routing_state_ribs_rib_active_route_output_route_next_hop_next_hop_list

  __choices__ = {'next-hop-options': {'simple-next-hop': ['outgoing_interface'], 'special-next-hop': ['special_next_hop'], 'next-hop-list': ['next_hop_list']}}
  _pyangbind_elements = OrderedDict([('outgoing_interface', outgoing_interface), ('special_next_hop', special_next_hop), ('next_hop_list', next_hop_list), ])


class yc_route_ietf_routing__routing_state_ribs_rib_active_route_output_route(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing-state/ribs/rib/active-route/output/route. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The active RIB route for the specified
destination.

If no route exists in the RIB for the destination
address, no output is returned.

Address-family-specific modules MUST augment this
container with appropriate route contents.
  """
  __slots__ = ('_path_helper', '_extmethods', '__next_hop','__source_protocol','__active','__last_updated',)

  _yang_name = 'route'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__next_hop = YANGDynClass(base=yc_next_hop_ietf_routing__routing_state_ribs_rib_active_route_output_route_next_hop, is_container='container', yang_name="next-hop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)
    self.__source_protocol = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'direct': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:direct': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'static': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:static': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}},), is_leaf=True, yang_name="source-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=False)
    self.__active = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="active", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='empty', is_config=False)
    self.__last_updated = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="last-updated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='yang:date-and-time', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing-state', 'ribs', 'rib', 'active-route', 'output', 'route']

  def _get_next_hop(self):
    """
    Getter method for next_hop, mapped from YANG variable /routing_state/ribs/rib/active_route/output/route/next_hop (container)

    YANG Description: Route's next-hop attribute.
    """
    return self.__next_hop
      
  def _set_next_hop(self, v, load=False):
    """
    Setter method for next_hop, mapped from YANG variable /routing_state/ribs/rib/active_route/output/route/next_hop (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_next_hop is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_next_hop() directly.

    YANG Description: Route's next-hop attribute.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_next_hop_ietf_routing__routing_state_ribs_rib_active_route_output_route_next_hop, is_container='container', yang_name="next-hop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """next_hop must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_next_hop_ietf_routing__routing_state_ribs_rib_active_route_output_route_next_hop, is_container='container', yang_name="next-hop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)""",
        })

    self.__next_hop = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_next_hop(self):
    self.__next_hop = YANGDynClass(base=yc_next_hop_ietf_routing__routing_state_ribs_rib_active_route_output_route_next_hop, is_container='container', yang_name="next-hop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)


  def _get_source_protocol(self):
    """
    Getter method for source_protocol, mapped from YANG variable /routing_state/ribs/rib/active_route/output/route/source_protocol (identityref)

    YANG Description: Type of the routing protocol from which the route
originated.
    """
    return self.__source_protocol
      
  def _set_source_protocol(self, v, load=False):
    """
    Setter method for source_protocol, mapped from YANG variable /routing_state/ribs/rib/active_route/output/route/source_protocol (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_source_protocol is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_source_protocol() directly.

    YANG Description: Type of the routing protocol from which the route
originated.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'direct': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:direct': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'static': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:static': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}},), is_leaf=True, yang_name="source-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """source_protocol must be of a type compatible with identityref""",
          'defined-type': "ietf-routing:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'direct': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:direct': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'static': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:static': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}},), is_leaf=True, yang_name="source-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=False)""",
        })

    self.__source_protocol = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_source_protocol(self):
    self.__source_protocol = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'direct': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:direct': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'static': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:static': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}},), is_leaf=True, yang_name="source-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=False)


  def _get_active(self):
    """
    Getter method for active, mapped from YANG variable /routing_state/ribs/rib/active_route/output/route/active (empty)

    YANG Description: The presence of this leaf indicates that the route is
preferred among all routes in the same RIB that have the
same destination prefix.
    """
    return self.__active
      
  def _set_active(self, v, load=False):
    """
    Setter method for active, mapped from YANG variable /routing_state/ribs/rib/active_route/output/route/active (empty)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_active is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_active() directly.

    YANG Description: The presence of this leaf indicates that the route is
preferred among all routes in the same RIB that have the
same destination prefix.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="active", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='empty', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """active must be of a type compatible with empty""",
          'defined-type': "empty",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="active", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='empty', is_config=False)""",
        })

    self.__active = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_active(self):
    self.__active = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="active", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='empty', is_config=False)


  def _get_last_updated(self):
    """
    Getter method for last_updated, mapped from YANG variable /routing_state/ribs/rib/active_route/output/route/last_updated (yang:date-and-time)

    YANG Description: Timestamp of the last modification of the route.  If the
route was never modified, it is the time when the route was
inserted into the RIB.
    """
    return self.__last_updated
      
  def _set_last_updated(self, v, load=False):
    """
    Setter method for last_updated, mapped from YANG variable /routing_state/ribs/rib/active_route/output/route/last_updated (yang:date-and-time)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_last_updated is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_last_updated() directly.

    YANG Description: Timestamp of the last modification of the route.  If the
route was never modified, it is the time when the route was
inserted into the RIB.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="last-updated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='yang:date-and-time', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """last_updated must be of a type compatible with yang:date-and-time""",
          'defined-type': "yang:date-and-time",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="last-updated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='yang:date-and-time', is_config=False)""",
        })

    self.__last_updated = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_last_updated(self):
    self.__last_updated = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="last-updated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='yang:date-and-time', is_config=False)

  next_hop = __builtin__.property(_get_next_hop) # type: yc_next_hop_ietf_routing__routing_state_ribs_rib_active_route_output_route_next_hop
  source_protocol = __builtin__.property(_get_source_protocol)
  active = __builtin__.property(_get_active)
  last_updated = __builtin__.property(_get_last_updated)


  _pyangbind_elements = OrderedDict([('next_hop', next_hop), ('source_protocol', source_protocol), ('active', active), ('last_updated', last_updated), ])


class yc_output_ietf_routing__routing_state_ribs_rib_active_route_output(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing-state/ribs/rib/active-route/output. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__route',)

  _yang_name = 'output'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__route = YANGDynClass(base=yc_route_ietf_routing__routing_state_ribs_rib_active_route_output_route, is_container='container', yang_name="route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing-state', 'ribs', 'rib', 'active-route', 'output']

  def _get_route(self):
    """
    Getter method for route, mapped from YANG variable /routing_state/ribs/rib/active_route/output/route (container)

    YANG Description: The active RIB route for the specified
destination.

If no route exists in the RIB for the destination
address, no output is returned.

Address-family-specific modules MUST augment this
container with appropriate route contents.
    """
    return self.__route
      
  def _set_route(self, v, load=False):
    """
    Setter method for route, mapped from YANG variable /routing_state/ribs/rib/active_route/output/route (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_route is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_route() directly.

    YANG Description: The active RIB route for the specified
destination.

If no route exists in the RIB for the destination
address, no output is returned.

Address-family-specific modules MUST augment this
container with appropriate route contents.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_route_ietf_routing__routing_state_ribs_rib_active_route_output_route, is_container='container', yang_name="route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """route must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_route_ietf_routing__routing_state_ribs_rib_active_route_output_route, is_container='container', yang_name="route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)""",
        })

    self.__route = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_route(self):
    self.__route = YANGDynClass(base=yc_route_ietf_routing__routing_state_ribs_rib_active_route_output_route, is_container='container', yang_name="route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)

  route = __builtin__.property(_get_route) # type: yc_route_ietf_routing__routing_state_ribs_rib_active_route_output_route


  _pyangbind_elements = OrderedDict([('route', route), ])


class yc_active_route_ietf_routing__routing_state_ribs_rib_active_route(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing-state/ribs/rib/active-route. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Return the active RIB route that is used for the
destination address.

Address-family-specific modules MUST augment input
parameters with a leaf named 'destination-address'.
  """
  __slots__ = ('_path_helper', '_extmethods', '__output',)

  _yang_name = 'active-route'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__output = YANGDynClass(base=yc_output_ietf_routing__routing_state_ribs_rib_active_route_output, is_leaf=True, yang_name="output", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='output', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing-state', 'ribs', 'rib', 'active-route']

  def _get_output(self):
    """
    Getter method for output, mapped from YANG variable /routing_state/ribs/rib/active_route/output (output)
    """
    return self.__output
      
  def _set_output(self, v, load=False):
    """
    Setter method for output, mapped from YANG variable /routing_state/ribs/rib/active_route/output (output)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_output is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_output() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_output_ietf_routing__routing_state_ribs_rib_active_route_output, is_leaf=True, yang_name="output", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='output', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """output must be of a type compatible with output""",
          'defined-type': "ietf-routing:output",
          'generated-type': """YANGDynClass(base=yc_output_ietf_routing__routing_state_ribs_rib_active_route_output, is_leaf=True, yang_name="output", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='output', is_config=False)""",
        })

    self.__output = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_output(self):
    self.__output = YANGDynClass(base=yc_output_ietf_routing__routing_state_ribs_rib_active_route_output, is_leaf=True, yang_name="output", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='output', is_config=False)

  output = __builtin__.property(_get_output)


  _pyangbind_elements = OrderedDict([('output', output), ])


class yc_rib_ietf_routing__routing_state_ribs_rib(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing-state/ribs/rib. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Each entry represents a RIB identified by the 'name'
key.  All routes in a RIB MUST belong to the same address
family.

An implementation SHOULD provide one system-controlled
default RIB for each supported address family.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__address_family','__default_rib','__routes','__active_route',)

  _yang_name = 'rib'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=False)
    self.__address_family = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'ipv4': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:ipv4': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'ipv6': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:ipv6': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}},), is_leaf=True, yang_name="address-family", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=False)
    self.__default_rib = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="default-rib", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='boolean', is_config=False)
    self.__routes = YANGDynClass(base=yc_routes_ietf_routing__routing_state_ribs_rib_routes, is_container='container', yang_name="routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)
    self.__active_route = YANGDynClass(base=yc_active_route_ietf_routing__routing_state_ribs_rib_active_route, is_leaf=True, yang_name="active-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='action', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing-state', 'ribs', 'rib']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /routing_state/ribs/rib/name (string)

    YANG Description: The name of the RIB.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /routing_state/ribs/rib/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: The name of the RIB.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=False)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=False)


  def _get_address_family(self):
    """
    Getter method for address_family, mapped from YANG variable /routing_state/ribs/rib/address_family (identityref)

    YANG Description: Address family.
    """
    return self.__address_family
      
  def _set_address_family(self, v, load=False):
    """
    Setter method for address_family, mapped from YANG variable /routing_state/ribs/rib/address_family (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_address_family is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_address_family() directly.

    YANG Description: Address family.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'ipv4': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:ipv4': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'ipv6': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:ipv6': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}},), is_leaf=True, yang_name="address-family", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """address_family must be of a type compatible with identityref""",
          'defined-type': "ietf-routing:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'ipv4': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:ipv4': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'ipv6': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:ipv6': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}},), is_leaf=True, yang_name="address-family", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=False)""",
        })

    self.__address_family = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_address_family(self):
    self.__address_family = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'ipv4': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:ipv4': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'ipv6': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:ipv6': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}},), is_leaf=True, yang_name="address-family", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=False)


  def _get_default_rib(self):
    """
    Getter method for default_rib, mapped from YANG variable /routing_state/ribs/rib/default_rib (boolean)

    YANG Description: This flag has the value of 'true' if and only if the
RIB is the default RIB for the given address family.

By default, control-plane protocols place their routes
in the default RIBs.
    """
    return self.__default_rib
      
  def _set_default_rib(self, v, load=False):
    """
    Setter method for default_rib, mapped from YANG variable /routing_state/ribs/rib/default_rib (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_default_rib is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_default_rib() directly.

    YANG Description: This flag has the value of 'true' if and only if the
RIB is the default RIB for the given address family.

By default, control-plane protocols place their routes
in the default RIBs.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="default-rib", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """default_rib must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="default-rib", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='boolean', is_config=False)""",
        })

    self.__default_rib = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_default_rib(self):
    self.__default_rib = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="default-rib", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='boolean', is_config=False)


  def _get_routes(self):
    """
    Getter method for routes, mapped from YANG variable /routing_state/ribs/rib/routes (container)

    YANG Description: Current contents of the RIB.
    """
    return self.__routes
      
  def _set_routes(self, v, load=False):
    """
    Setter method for routes, mapped from YANG variable /routing_state/ribs/rib/routes (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_routes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_routes() directly.

    YANG Description: Current contents of the RIB.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_routes_ietf_routing__routing_state_ribs_rib_routes, is_container='container', yang_name="routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """routes must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_routes_ietf_routing__routing_state_ribs_rib_routes, is_container='container', yang_name="routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)""",
        })

    self.__routes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_routes(self):
    self.__routes = YANGDynClass(base=yc_routes_ietf_routing__routing_state_ribs_rib_routes, is_container='container', yang_name="routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)


  def _get_active_route(self):
    """
    Getter method for active_route, mapped from YANG variable /routing_state/ribs/rib/active_route (action)

    YANG Description: Return the active RIB route that is used for the
destination address.

Address-family-specific modules MUST augment input
parameters with a leaf named 'destination-address'.
    """
    return self.__active_route
      
  def _set_active_route(self, v, load=False):
    """
    Setter method for active_route, mapped from YANG variable /routing_state/ribs/rib/active_route (action)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_active_route is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_active_route() directly.

    YANG Description: Return the active RIB route that is used for the
destination address.

Address-family-specific modules MUST augment input
parameters with a leaf named 'destination-address'.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_active_route_ietf_routing__routing_state_ribs_rib_active_route, is_leaf=True, yang_name="active-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='action', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """active_route must be of a type compatible with action""",
          'defined-type': "ietf-routing:action",
          'generated-type': """YANGDynClass(base=yc_active_route_ietf_routing__routing_state_ribs_rib_active_route, is_leaf=True, yang_name="active-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='action', is_config=False)""",
        })

    self.__active_route = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_active_route(self):
    self.__active_route = YANGDynClass(base=yc_active_route_ietf_routing__routing_state_ribs_rib_active_route, is_leaf=True, yang_name="active-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='action', is_config=False)

  name = __builtin__.property(_get_name)
  address_family = __builtin__.property(_get_address_family)
  default_rib = __builtin__.property(_get_default_rib)
  routes = __builtin__.property(_get_routes) # type: yc_routes_ietf_routing__routing_state_ribs_rib_routes
  active_route = __builtin__.property(_get_active_route)


  _pyangbind_elements = OrderedDict([('name', name), ('address_family', address_family), ('default_rib', default_rib), ('routes', routes), ('active_route', active_route), ])


class yc_ribs_ietf_routing__routing_state_ribs(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing-state/ribs. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container for RIBs.
  """
  __slots__ = ('_path_helper', '_extmethods', '__rib',)

  _yang_name = 'ribs'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__rib = YANGDynClass(base=YANGListType("name",yc_rib_ietf_routing__routing_state_ribs_rib, yang_name="rib", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="rib", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing-state', 'ribs']

  def _get_rib(self):
    """
    Getter method for rib, mapped from YANG variable /routing_state/ribs/rib (list)

    YANG Description: Each entry represents a RIB identified by the 'name'
key.  All routes in a RIB MUST belong to the same address
family.

An implementation SHOULD provide one system-controlled
default RIB for each supported address family.
    """
    return self.__rib
      
  def _set_rib(self, v, load=False):
    """
    Setter method for rib, mapped from YANG variable /routing_state/ribs/rib (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rib is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rib() directly.

    YANG Description: Each entry represents a RIB identified by the 'name'
key.  All routes in a RIB MUST belong to the same address
family.

An implementation SHOULD provide one system-controlled
default RIB for each supported address family.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_rib_ietf_routing__routing_state_ribs_rib, yang_name="rib", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="rib", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rib must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_rib_ietf_routing__routing_state_ribs_rib, yang_name="rib", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="rib", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)""",
        })

    self.__rib = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rib(self):
    self.__rib = YANGDynClass(base=YANGListType("name",yc_rib_ietf_routing__routing_state_ribs_rib, yang_name="rib", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="rib", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)

  rib = __builtin__.property(_get_rib) # type: yc_rib_ietf_routing__routing_state_ribs_rib


  _pyangbind_elements = OrderedDict([('rib', rib), ])


class yc_routing_state_ietf_routing__routing_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing-state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: State data of the routing subsystem.
  """
  __slots__ = ('_path_helper', '_extmethods', '__router_id','__interfaces','__control_plane_protocols','__ribs',)

  _yang_name = 'routing-state'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__router_id = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='yang:dotted-quad', is_config=False)
    self.__interfaces = YANGDynClass(base=yc_interfaces_ietf_routing__routing_state_interfaces, is_container='container', yang_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)
    self.__control_plane_protocols = YANGDynClass(base=yc_control_plane_protocols_ietf_routing__routing_state_control_plane_protocols, is_container='container', yang_name="control-plane-protocols", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)
    self.__ribs = YANGDynClass(base=yc_ribs_ietf_routing__routing_state_ribs, is_container='container', yang_name="ribs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing-state']

  def _get_router_id(self):
    """
    Getter method for router_id, mapped from YANG variable /routing_state/router_id (yang:dotted-quad)

    YANG Description: A 32-bit number in the form of a dotted quad that is used by
some routing protocols identifying a router.
    """
    return self.__router_id
      
  def _set_router_id(self, v, load=False):
    """
    Setter method for router_id, mapped from YANG variable /routing_state/router_id (yang:dotted-quad)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_router_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_router_id() directly.

    YANG Description: A 32-bit number in the form of a dotted quad that is used by
some routing protocols identifying a router.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='yang:dotted-quad', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """router_id must be of a type compatible with yang:dotted-quad""",
          'defined-type': "yang:dotted-quad",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='yang:dotted-quad', is_config=False)""",
        })

    self.__router_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_router_id(self):
    self.__router_id = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='yang:dotted-quad', is_config=False)


  def _get_interfaces(self):
    """
    Getter method for interfaces, mapped from YANG variable /routing_state/interfaces (container)

    YANG Description: Network-layer interfaces used for routing.
    """
    return self.__interfaces
      
  def _set_interfaces(self, v, load=False):
    """
    Setter method for interfaces, mapped from YANG variable /routing_state/interfaces (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interfaces is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interfaces() directly.

    YANG Description: Network-layer interfaces used for routing.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_interfaces_ietf_routing__routing_state_interfaces, is_container='container', yang_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interfaces must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_interfaces_ietf_routing__routing_state_interfaces, is_container='container', yang_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)""",
        })

    self.__interfaces = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interfaces(self):
    self.__interfaces = YANGDynClass(base=yc_interfaces_ietf_routing__routing_state_interfaces, is_container='container', yang_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)


  def _get_control_plane_protocols(self):
    """
    Getter method for control_plane_protocols, mapped from YANG variable /routing_state/control_plane_protocols (container)

    YANG Description: Container for the list of routing protocol instances.
    """
    return self.__control_plane_protocols
      
  def _set_control_plane_protocols(self, v, load=False):
    """
    Setter method for control_plane_protocols, mapped from YANG variable /routing_state/control_plane_protocols (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_control_plane_protocols is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_control_plane_protocols() directly.

    YANG Description: Container for the list of routing protocol instances.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_control_plane_protocols_ietf_routing__routing_state_control_plane_protocols, is_container='container', yang_name="control-plane-protocols", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """control_plane_protocols must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_control_plane_protocols_ietf_routing__routing_state_control_plane_protocols, is_container='container', yang_name="control-plane-protocols", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)""",
        })

    self.__control_plane_protocols = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_control_plane_protocols(self):
    self.__control_plane_protocols = YANGDynClass(base=yc_control_plane_protocols_ietf_routing__routing_state_control_plane_protocols, is_container='container', yang_name="control-plane-protocols", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)


  def _get_ribs(self):
    """
    Getter method for ribs, mapped from YANG variable /routing_state/ribs (container)

    YANG Description: Container for RIBs.
    """
    return self.__ribs
      
  def _set_ribs(self, v, load=False):
    """
    Setter method for ribs, mapped from YANG variable /routing_state/ribs (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ribs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ribs() directly.

    YANG Description: Container for RIBs.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ribs_ietf_routing__routing_state_ribs, is_container='container', yang_name="ribs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ribs must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ribs_ietf_routing__routing_state_ribs, is_container='container', yang_name="ribs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)""",
        })

    self.__ribs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ribs(self):
    self.__ribs = YANGDynClass(base=yc_ribs_ietf_routing__routing_state_ribs, is_container='container', yang_name="ribs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)

  router_id = __builtin__.property(_get_router_id)
  interfaces = __builtin__.property(_get_interfaces) # type: yc_interfaces_ietf_routing__routing_state_interfaces
  control_plane_protocols = __builtin__.property(_get_control_plane_protocols) # type: yc_control_plane_protocols_ietf_routing__routing_state_control_plane_protocols
  ribs = __builtin__.property(_get_ribs) # type: yc_ribs_ietf_routing__routing_state_ribs


  _pyangbind_elements = OrderedDict([('router_id', router_id), ('interfaces', interfaces), ('control_plane_protocols', control_plane_protocols), ('ribs', ribs), ])


class ietf_routing(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /ietf-routing. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This YANG module defines essential components for the management
of a routing subsystem.  The model fully conforms to the Network
Management Datastore Architecture (NMDA).

Copyright (c) 2018 IETF Trust and the persons
identified as authors of the code.  All rights reserved.

Redistribution and use in source and binary forms, with or
without modification, is permitted pursuant to, and subject
to the license terms contained in, the Simplified BSD License
set forth in Section 4.c of the IETF Trust's Legal Provisions
Relating to IETF Documents
(https://trustee.ietf.org/license-info).
This version of this YANG module is part of RFC 8349; see
the RFC itself for full legal notices.
  """
  __slots__ = ('_path_helper', '_extmethods', '__routing','__routing_state',)

  _yang_name = 'ietf-routing'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__routing = YANGDynClass(base=yc_routing_ietf_routing__routing, is_container='container', yang_name="routing", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)
    self.__routing_state = YANGDynClass(base=yc_routing_state_ietf_routing__routing_state, is_container='container', yang_name="routing-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_routing(self):
    """
    Getter method for routing, mapped from YANG variable /routing (container)

    YANG Description: Configuration parameters for the routing subsystem.
    """
    return self.__routing
      
  def _set_routing(self, v, load=False):
    """
    Setter method for routing, mapped from YANG variable /routing (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_routing is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_routing() directly.

    YANG Description: Configuration parameters for the routing subsystem.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_routing_ietf_routing__routing, is_container='container', yang_name="routing", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """routing must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_routing_ietf_routing__routing, is_container='container', yang_name="routing", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)""",
        })

    self.__routing = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_routing(self):
    self.__routing = YANGDynClass(base=yc_routing_ietf_routing__routing, is_container='container', yang_name="routing", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)


  def _get_routing_state(self):
    """
    Getter method for routing_state, mapped from YANG variable /routing_state (container)

    YANG Description: State data of the routing subsystem.
    """
    return self.__routing_state
      
  def _set_routing_state(self, v, load=False):
    """
    Setter method for routing_state, mapped from YANG variable /routing_state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_routing_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_routing_state() directly.

    YANG Description: State data of the routing subsystem.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_routing_state_ietf_routing__routing_state, is_container='container', yang_name="routing-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """routing_state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_routing_state_ietf_routing__routing_state, is_container='container', yang_name="routing-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)""",
        })

    self.__routing_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_routing_state(self):
    self.__routing_state = YANGDynClass(base=yc_routing_state_ietf_routing__routing_state, is_container='container', yang_name="routing-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)

  routing = __builtin__.property(_get_routing, _set_routing) # type: yc_routing_ietf_routing__routing
  routing_state = __builtin__.property(_get_routing_state, _set_routing_state) # type: yc_routing_state_ietf_routing__routing_state


  _pyangbind_elements = OrderedDict([('routing', routing), ('routing_state', routing_state), ])


