# -*- coding: utf-8 -*-
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType
from pyangbind.lib.yangtypes import RestrictedClassType
from pyangbind.lib.yangtypes import TypedListType
from pyangbind.lib.yangtypes import YANGBool
from pyangbind.lib.yangtypes import YANGListType
from pyangbind.lib.yangtypes import YANGDynClass
from pyangbind.lib.yangtypes import ReferenceType
from pyangbind.lib.base import PybindBase
from collections import OrderedDict
from decimal import Decimal
from bitarray import bitarray
import six

# PY3 support of some PY2 keywords (needs improved)
if six.PY3:
  import builtins as __builtin__
  long = int
elif six.PY2:
  import __builtin__

class yc_ipv4_conflict_enable_huawei_ifm__ifm_global_ipv4_conflict_enable(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-ifm - based on the path /ifm/global/ipv4-conflict-enable. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enable/disable ip conflict function.
  """
  __slots__ = ('_path_helper', '_extmethods', '__preempt_enable',)

  _yang_name = 'ipv4-conflict-enable'
  _yang_namespace = 'urn:huawei:yang:huawei-ifm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__preempt_enable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="preempt-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ifm', 'global', 'ipv4-conflict-enable']

  def _get_preempt_enable(self):
    """
    Getter method for preempt_enable, mapped from YANG variable /ifm/global/ipv4_conflict_enable/preempt_enable (boolean)

    YANG Description: Enable/disable IPv4 address conflict preemption.
    """
    return self.__preempt_enable
      
  def _set_preempt_enable(self, v, load=False):
    """
    Setter method for preempt_enable, mapped from YANG variable /ifm/global/ipv4_conflict_enable/preempt_enable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_preempt_enable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_preempt_enable() directly.

    YANG Description: Enable/disable IPv4 address conflict preemption.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="preempt-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """preempt_enable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="preempt-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=True)""",
        })

    self.__preempt_enable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_preempt_enable(self):
    self.__preempt_enable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="preempt-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=True)

  preempt_enable = __builtin__.property(_get_preempt_enable, _set_preempt_enable)


  _pyangbind_elements = OrderedDict([('preempt_enable', preempt_enable), ])


class yc_ipv6_conflict_enable_huawei_ifm__ifm_global_ipv6_conflict_enable(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-ifm - based on the path /ifm/global/ipv6-conflict-enable. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enable/disable IPv6 conflict function.
  """
  __slots__ = ('_path_helper', '_extmethods', '__preempt_enable',)

  _yang_name = 'ipv6-conflict-enable'
  _yang_namespace = 'urn:huawei:yang:huawei-ifm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__preempt_enable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="preempt-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ifm', 'global', 'ipv6-conflict-enable']

  def _get_preempt_enable(self):
    """
    Getter method for preempt_enable, mapped from YANG variable /ifm/global/ipv6_conflict_enable/preempt_enable (boolean)

    YANG Description: Enable/disable IPv6 address conflict preemption.
    """
    return self.__preempt_enable
      
  def _set_preempt_enable(self, v, load=False):
    """
    Setter method for preempt_enable, mapped from YANG variable /ifm/global/ipv6_conflict_enable/preempt_enable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_preempt_enable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_preempt_enable() directly.

    YANG Description: Enable/disable IPv6 address conflict preemption.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="preempt-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """preempt_enable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="preempt-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=True)""",
        })

    self.__preempt_enable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_preempt_enable(self):
    self.__preempt_enable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="preempt-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=True)

  preempt_enable = __builtin__.property(_get_preempt_enable, _set_preempt_enable)


  _pyangbind_elements = OrderedDict([('preempt_enable', preempt_enable), ])


class yc_global__huawei_ifm__ifm_global(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-ifm - based on the path /ifm/global. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure globally configured attributes.
  """
  __slots__ = ('_path_helper', '_extmethods', '__statistic_interval','__ipv4_ignore_primary_sub','__sub_interface_link_trap_enable','__ipv4_conflict_enable','__ipv6_conflict_enable',)

  _yang_name = 'global'
  _yang_namespace = 'urn:huawei:yang:huawei-ifm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__statistic_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['10..600']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(300), is_leaf=True, yang_name="statistic-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)
    self.__ipv4_ignore_primary_sub = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ipv4-ignore-primary-sub", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=True)
    self.__sub_interface_link_trap_enable = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="sub-interface-link-trap-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=True)
    self.__ipv4_conflict_enable = YANGDynClass(base=yc_ipv4_conflict_enable_huawei_ifm__ifm_global_ipv4_conflict_enable, is_container='container', yang_name="ipv4-conflict-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)
    self.__ipv6_conflict_enable = YANGDynClass(base=yc_ipv6_conflict_enable_huawei_ifm__ifm_global_ipv6_conflict_enable, is_container='container', yang_name="ipv6-conflict-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ifm', 'global']

  def _get_statistic_interval(self):
    """
    Getter method for statistic_interval, mapped from YANG variable /ifm/global/statistic_interval (uint32)

    YANG Description: Set the interval at which global flow statistics are collected.
    """
    return self.__statistic_interval
      
  def _set_statistic_interval(self, v, load=False):
    """
    Setter method for statistic_interval, mapped from YANG variable /ifm/global/statistic_interval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_statistic_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_statistic_interval() directly.

    YANG Description: Set the interval at which global flow statistics are collected.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['10..600']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(300), is_leaf=True, yang_name="statistic-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """statistic_interval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['10..600']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(300), is_leaf=True, yang_name="statistic-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)""",
        })

    self.__statistic_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_statistic_interval(self):
    self.__statistic_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['10..600']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(300), is_leaf=True, yang_name="statistic-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)


  def _get_ipv4_ignore_primary_sub(self):
    """
    Getter method for ipv4_ignore_primary_sub, mapped from YANG variable /ifm/global/ipv4_ignore_primary_sub (boolean)

    YANG Description: Enable/disable the function of ignoring primary/secondary of IPv4 address type. All secondary addresses must be deleted before this function is enabled.
    """
    return self.__ipv4_ignore_primary_sub
      
  def _set_ipv4_ignore_primary_sub(self, v, load=False):
    """
    Setter method for ipv4_ignore_primary_sub, mapped from YANG variable /ifm/global/ipv4_ignore_primary_sub (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv4_ignore_primary_sub is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv4_ignore_primary_sub() directly.

    YANG Description: Enable/disable the function of ignoring primary/secondary of IPv4 address type. All secondary addresses must be deleted before this function is enabled.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ipv4-ignore-primary-sub", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv4_ignore_primary_sub must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ipv4-ignore-primary-sub", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=True)""",
        })

    self.__ipv4_ignore_primary_sub = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv4_ignore_primary_sub(self):
    self.__ipv4_ignore_primary_sub = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ipv4-ignore-primary-sub", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=True)


  def _get_sub_interface_link_trap_enable(self):
    """
    Getter method for sub_interface_link_trap_enable, mapped from YANG variable /ifm/global/sub_interface_link_trap_enable (boolean)

    YANG Description: Enable/disable the trap function on all Sub-interface.
    """
    return self.__sub_interface_link_trap_enable
      
  def _set_sub_interface_link_trap_enable(self, v, load=False):
    """
    Setter method for sub_interface_link_trap_enable, mapped from YANG variable /ifm/global/sub_interface_link_trap_enable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_sub_interface_link_trap_enable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_sub_interface_link_trap_enable() directly.

    YANG Description: Enable/disable the trap function on all Sub-interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="sub-interface-link-trap-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """sub_interface_link_trap_enable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="sub-interface-link-trap-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=True)""",
        })

    self.__sub_interface_link_trap_enable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_sub_interface_link_trap_enable(self):
    self.__sub_interface_link_trap_enable = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="sub-interface-link-trap-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=True)


  def _get_ipv4_conflict_enable(self):
    """
    Getter method for ipv4_conflict_enable, mapped from YANG variable /ifm/global/ipv4_conflict_enable (container)

    YANG Description: Enable/disable ip conflict function.
    """
    return self.__ipv4_conflict_enable
      
  def _set_ipv4_conflict_enable(self, v, load=False):
    """
    Setter method for ipv4_conflict_enable, mapped from YANG variable /ifm/global/ipv4_conflict_enable (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv4_conflict_enable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv4_conflict_enable() directly.

    YANG Description: Enable/disable ip conflict function.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ipv4_conflict_enable_huawei_ifm__ifm_global_ipv4_conflict_enable, is_container='container', yang_name="ipv4-conflict-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv4_conflict_enable must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ipv4_conflict_enable_huawei_ifm__ifm_global_ipv4_conflict_enable, is_container='container', yang_name="ipv4-conflict-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)""",
        })

    self.__ipv4_conflict_enable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv4_conflict_enable(self):
    self.__ipv4_conflict_enable = YANGDynClass(base=yc_ipv4_conflict_enable_huawei_ifm__ifm_global_ipv4_conflict_enable, is_container='container', yang_name="ipv4-conflict-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)


  def _get_ipv6_conflict_enable(self):
    """
    Getter method for ipv6_conflict_enable, mapped from YANG variable /ifm/global/ipv6_conflict_enable (container)

    YANG Description: Enable/disable IPv6 conflict function.
    """
    return self.__ipv6_conflict_enable
      
  def _set_ipv6_conflict_enable(self, v, load=False):
    """
    Setter method for ipv6_conflict_enable, mapped from YANG variable /ifm/global/ipv6_conflict_enable (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv6_conflict_enable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv6_conflict_enable() directly.

    YANG Description: Enable/disable IPv6 conflict function.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ipv6_conflict_enable_huawei_ifm__ifm_global_ipv6_conflict_enable, is_container='container', yang_name="ipv6-conflict-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv6_conflict_enable must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ipv6_conflict_enable_huawei_ifm__ifm_global_ipv6_conflict_enable, is_container='container', yang_name="ipv6-conflict-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)""",
        })

    self.__ipv6_conflict_enable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv6_conflict_enable(self):
    self.__ipv6_conflict_enable = YANGDynClass(base=yc_ipv6_conflict_enable_huawei_ifm__ifm_global_ipv6_conflict_enable, is_container='container', yang_name="ipv6-conflict-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)

  statistic_interval = __builtin__.property(_get_statistic_interval, _set_statistic_interval)
  ipv4_ignore_primary_sub = __builtin__.property(_get_ipv4_ignore_primary_sub, _set_ipv4_ignore_primary_sub)
  sub_interface_link_trap_enable = __builtin__.property(_get_sub_interface_link_trap_enable, _set_sub_interface_link_trap_enable)
  ipv4_conflict_enable = __builtin__.property(_get_ipv4_conflict_enable, _set_ipv4_conflict_enable) # type: yc_ipv4_conflict_enable_huawei_ifm__ifm_global_ipv4_conflict_enable
  ipv6_conflict_enable = __builtin__.property(_get_ipv6_conflict_enable, _set_ipv6_conflict_enable) # type: yc_ipv6_conflict_enable_huawei_ifm__ifm_global_ipv6_conflict_enable


  _pyangbind_elements = OrderedDict([('statistic_interval', statistic_interval), ('ipv4_ignore_primary_sub', ipv4_ignore_primary_sub), ('sub_interface_link_trap_enable', sub_interface_link_trap_enable), ('ipv4_conflict_enable', ipv4_conflict_enable), ('ipv6_conflict_enable', ipv6_conflict_enable), ])


class yc_auto_huawei_ifm__ifm_damp_auto(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-ifm - based on the path /ifm/damp/auto. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure an auto suppression level.
  """
  __slots__ = ('_path_helper', '_extmethods', '__level',)

  _yang_name = 'auto'
  _yang_namespace = 'urn:huawei:yang:huawei-ifm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__level = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'light': {'value': 0}, 'middle': {'value': 1}, 'heavy': {'value': 2}},), default=six.text_type("light"), is_leaf=True, yang_name="level", parent=self, choice=('level', 'auto'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='damp-level-type', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ifm', 'damp', 'auto']

  def _get_level(self):
    """
    Getter method for level, mapped from YANG variable /ifm/damp/auto/level (damp-level-type)

    YANG Description: Auto damping level.
    """
    return self.__level
      
  def _set_level(self, v, load=False):
    """
    Setter method for level, mapped from YANG variable /ifm/damp/auto/level (damp-level-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_level is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_level() directly.

    YANG Description: Auto damping level.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'light': {'value': 0}, 'middle': {'value': 1}, 'heavy': {'value': 2}},), default=six.text_type("light"), is_leaf=True, yang_name="level", parent=self, choice=('level', 'auto'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='damp-level-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """level must be of a type compatible with damp-level-type""",
          'defined-type': "huawei-ifm:damp-level-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'light': {'value': 0}, 'middle': {'value': 1}, 'heavy': {'value': 2}},), default=six.text_type("light"), is_leaf=True, yang_name="level", parent=self, choice=('level', 'auto'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='damp-level-type', is_config=True)""",
        })

    self.__level = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_level(self):
    self.__level = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'light': {'value': 0}, 'middle': {'value': 1}, 'heavy': {'value': 2}},), default=six.text_type("light"), is_leaf=True, yang_name="level", parent=self, choice=('level', 'auto'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='damp-level-type', is_config=True)

  level = __builtin__.property(_get_level, _set_level)

  __choices__ = {'level': {'auto': ['level']}}
  _pyangbind_elements = OrderedDict([('level', level), ])


class yc_manual_huawei_ifm__ifm_damp_manual(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-ifm - based on the path /ifm/damp/manual. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure a manual suppression level.
  """
  __slots__ = ('_path_helper', '_extmethods', '__suppress','__reuse','__max_suppress_time','__half_life_period',)

  _yang_name = 'manual'
  _yang_namespace = 'urn:huawei:yang:huawei-ifm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__suppress = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..20000']}), is_leaf=True, yang_name="suppress", parent=self, choice=('level', 'manual'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)
    self.__reuse = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..20000']}), is_leaf=True, yang_name="reuse", parent=self, choice=('level', 'manual'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)
    self.__max_suppress_time = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="max-suppress-time", parent=self, choice=('level', 'manual'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint16', is_config=True)
    self.__half_life_period = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..60']}), is_leaf=True, yang_name="half-life-period", parent=self, choice=('level', 'manual'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint16', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ifm', 'damp', 'manual']

  def _get_suppress(self):
    """
    Getter method for suppress, mapped from YANG variable /ifm/damp/manual/suppress (uint32)

    YANG Description: 1000 times of suppress threshold.
    """
    return self.__suppress
      
  def _set_suppress(self, v, load=False):
    """
    Setter method for suppress, mapped from YANG variable /ifm/damp/manual/suppress (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_suppress is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_suppress() directly.

    YANG Description: 1000 times of suppress threshold.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..20000']}), is_leaf=True, yang_name="suppress", parent=self, choice=('level', 'manual'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """suppress must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..20000']}), is_leaf=True, yang_name="suppress", parent=self, choice=('level', 'manual'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)""",
        })

    self.__suppress = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_suppress(self):
    self.__suppress = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..20000']}), is_leaf=True, yang_name="suppress", parent=self, choice=('level', 'manual'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)


  def _get_reuse(self):
    """
    Getter method for reuse, mapped from YANG variable /ifm/damp/manual/reuse (uint32)

    YANG Description: 1000 times of reuse threshold.
    """
    return self.__reuse
      
  def _set_reuse(self, v, load=False):
    """
    Setter method for reuse, mapped from YANG variable /ifm/damp/manual/reuse (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_reuse is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_reuse() directly.

    YANG Description: 1000 times of reuse threshold.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..20000']}), is_leaf=True, yang_name="reuse", parent=self, choice=('level', 'manual'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """reuse must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..20000']}), is_leaf=True, yang_name="reuse", parent=self, choice=('level', 'manual'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)""",
        })

    self.__reuse = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_reuse(self):
    self.__reuse = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..20000']}), is_leaf=True, yang_name="reuse", parent=self, choice=('level', 'manual'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)


  def _get_max_suppress_time(self):
    """
    Getter method for max_suppress_time, mapped from YANG variable /ifm/damp/manual/max_suppress_time (uint16)

    YANG Description: Max suppress time.
    """
    return self.__max_suppress_time
      
  def _set_max_suppress_time(self, v, load=False):
    """
    Setter method for max_suppress_time, mapped from YANG variable /ifm/damp/manual/max_suppress_time (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_suppress_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_suppress_time() directly.

    YANG Description: Max suppress time.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="max-suppress-time", parent=self, choice=('level', 'manual'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_suppress_time must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="max-suppress-time", parent=self, choice=('level', 'manual'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint16', is_config=True)""",
        })

    self.__max_suppress_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_suppress_time(self):
    self.__max_suppress_time = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="max-suppress-time", parent=self, choice=('level', 'manual'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint16', is_config=True)


  def _get_half_life_period(self):
    """
    Getter method for half_life_period, mapped from YANG variable /ifm/damp/manual/half_life_period (uint16)

    YANG Description: Half life time.
    """
    return self.__half_life_period
      
  def _set_half_life_period(self, v, load=False):
    """
    Setter method for half_life_period, mapped from YANG variable /ifm/damp/manual/half_life_period (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_half_life_period is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_half_life_period() directly.

    YANG Description: Half life time.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..60']}), is_leaf=True, yang_name="half-life-period", parent=self, choice=('level', 'manual'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """half_life_period must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..60']}), is_leaf=True, yang_name="half-life-period", parent=self, choice=('level', 'manual'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint16', is_config=True)""",
        })

    self.__half_life_period = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_half_life_period(self):
    self.__half_life_period = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..60']}), is_leaf=True, yang_name="half-life-period", parent=self, choice=('level', 'manual'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint16', is_config=True)

  suppress = __builtin__.property(_get_suppress, _set_suppress)
  reuse = __builtin__.property(_get_reuse, _set_reuse)
  max_suppress_time = __builtin__.property(_get_max_suppress_time, _set_max_suppress_time)
  half_life_period = __builtin__.property(_get_half_life_period, _set_half_life_period)

  __choices__ = {'level': {'manual': ['suppress', 'reuse', 'max_suppress_time', 'half_life_period']}}
  _pyangbind_elements = OrderedDict([('suppress', suppress), ('reuse', reuse), ('max_suppress_time', max_suppress_time), ('half_life_period', half_life_period), ])


class yc_damp_huawei_ifm__ifm_damp(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-ifm - based on the path /ifm/damp. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enable/disable suppression on interfaces' physical status flappings.
  """
  __slots__ = ('_path_helper', '_extmethods', '__tx_off','__auto','__manual',)

  _yang_name = 'damp'
  _yang_namespace = 'urn:huawei:yang:huawei-ifm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__tx_off = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="tx-off", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=True)
    self.__auto = YANGDynClass(base=yc_auto_huawei_ifm__ifm_damp_auto, is_container='container', yang_name="auto", parent=self, choice=('level', 'auto'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)
    self.__manual = YANGDynClass(base=yc_manual_huawei_ifm__ifm_damp_manual, is_container='container', yang_name="manual", parent=self, choice=('level', 'manual'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ifm', 'damp']

  def _get_tx_off(self):
    """
    Getter method for tx_off, mapped from YANG variable /ifm/damp/tx_off (boolean)

    YANG Description: Enable/disable interfaces from sending signals if the interfaces' physical status flappings are suppressed.
    """
    return self.__tx_off
      
  def _set_tx_off(self, v, load=False):
    """
    Setter method for tx_off, mapped from YANG variable /ifm/damp/tx_off (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tx_off is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tx_off() directly.

    YANG Description: Enable/disable interfaces from sending signals if the interfaces' physical status flappings are suppressed.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="tx-off", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tx_off must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="tx-off", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=True)""",
        })

    self.__tx_off = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tx_off(self):
    self.__tx_off = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="tx-off", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=True)


  def _get_auto(self):
    """
    Getter method for auto, mapped from YANG variable /ifm/damp/auto (container)

    YANG Description: Configure an auto suppression level.
    """
    return self.__auto
      
  def _set_auto(self, v, load=False):
    """
    Setter method for auto, mapped from YANG variable /ifm/damp/auto (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_auto is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_auto() directly.

    YANG Description: Configure an auto suppression level.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_auto_huawei_ifm__ifm_damp_auto, is_container='container', yang_name="auto", parent=self, choice=('level', 'auto'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """auto must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_auto_huawei_ifm__ifm_damp_auto, is_container='container', yang_name="auto", parent=self, choice=('level', 'auto'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)""",
        })

    self.__auto = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_auto(self):
    self.__auto = YANGDynClass(base=yc_auto_huawei_ifm__ifm_damp_auto, is_container='container', yang_name="auto", parent=self, choice=('level', 'auto'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)


  def _get_manual(self):
    """
    Getter method for manual, mapped from YANG variable /ifm/damp/manual (container)

    YANG Description: Configure a manual suppression level.
    """
    return self.__manual
      
  def _set_manual(self, v, load=False):
    """
    Setter method for manual, mapped from YANG variable /ifm/damp/manual (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_manual is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_manual() directly.

    YANG Description: Configure a manual suppression level.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_manual_huawei_ifm__ifm_damp_manual, is_container='container', yang_name="manual", parent=self, choice=('level', 'manual'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """manual must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_manual_huawei_ifm__ifm_damp_manual, is_container='container', yang_name="manual", parent=self, choice=('level', 'manual'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)""",
        })

    self.__manual = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_manual(self):
    self.__manual = YANGDynClass(base=yc_manual_huawei_ifm__ifm_damp_manual, is_container='container', yang_name="manual", parent=self, choice=('level', 'manual'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)

  tx_off = __builtin__.property(_get_tx_off, _set_tx_off)
  auto = __builtin__.property(_get_auto, _set_auto) # type: yc_auto_huawei_ifm__ifm_damp_auto
  manual = __builtin__.property(_get_manual, _set_manual) # type: yc_manual_huawei_ifm__ifm_damp_manual

  __choices__ = {'level': {'auto': ['auto'], 'manual': ['manual']}}
  _pyangbind_elements = OrderedDict([('tx_off', tx_off), ('auto', auto), ('manual', manual), ])


class yc_auto_recovery_time_huawei_ifm__ifm_auto_recovery_times_auto_recovery_time(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-ifm - based on the path /ifm/auto-recovery-times/auto-recovery-time. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure automatic recovery time.
  """
  __slots__ = ('_path_helper', '_extmethods', '__error_down_type','__time_value',)

  _yang_name = 'auto-recovery-time'
  _yang_namespace = 'urn:huawei:yang:huawei-ifm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__error_down_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'bpdu-protection': {'value': 0}, 'auto-defend': {'value': 1}, 'monitor-link': {'value': 2}, 'portsec-reached-limit': {'value': 65}, 'storm-control': {'value': 66}, 'loopback-detect': {'value': 67}, 'dual-active': {'value': 68}, 'mac-address-flapping': {'value': 69}, 'no-stack-link': {'value': 70}, 'crc-statistics': {'value': 71}, 'transceiver-power-low': {'value': 72}, 'link-flap': {'value': 73}, 'l2-loop-occured': {'value': 74}, 'stack-member-exceed-limit': {'value': 75}, 'spine-member-exceed-limit': {'value': 76}, 'resource-mismatch': {'value': 77}, 'leaf-mstp': {'value': 78}, 'm-lag': {'value': 79}, 'fabric-uplink-threshold': {'value': 80}, 'stack-config-conflict': {'value': 81}, 'spine-type-unsupported': {'value': 82}, 'stack-packet-defensive': {'value': 83}, 'forward-engine-buffer-failed': {'value': 85}, 'forward-engine-interface-failed': {'value': 86}, 'fabric-link-failure': {'value': 87}, 'm-lag-consistency-check': {'value': 88}},), is_leaf=True, yang_name="error-down-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='error-down-type', is_config=True)
    self.__time_value = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['30..86400']}), is_leaf=True, yang_name="time-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ifm', 'auto-recovery-times', 'auto-recovery-time']

  def _get_error_down_type(self):
    """
    Getter method for error_down_type, mapped from YANG variable /ifm/auto_recovery_times/auto_recovery_time/error_down_type (error-down-type)

    YANG Description: Cause of the error-down event.
    """
    return self.__error_down_type
      
  def _set_error_down_type(self, v, load=False):
    """
    Setter method for error_down_type, mapped from YANG variable /ifm/auto_recovery_times/auto_recovery_time/error_down_type (error-down-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_error_down_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_error_down_type() directly.

    YANG Description: Cause of the error-down event.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'bpdu-protection': {'value': 0}, 'auto-defend': {'value': 1}, 'monitor-link': {'value': 2}, 'portsec-reached-limit': {'value': 65}, 'storm-control': {'value': 66}, 'loopback-detect': {'value': 67}, 'dual-active': {'value': 68}, 'mac-address-flapping': {'value': 69}, 'no-stack-link': {'value': 70}, 'crc-statistics': {'value': 71}, 'transceiver-power-low': {'value': 72}, 'link-flap': {'value': 73}, 'l2-loop-occured': {'value': 74}, 'stack-member-exceed-limit': {'value': 75}, 'spine-member-exceed-limit': {'value': 76}, 'resource-mismatch': {'value': 77}, 'leaf-mstp': {'value': 78}, 'm-lag': {'value': 79}, 'fabric-uplink-threshold': {'value': 80}, 'stack-config-conflict': {'value': 81}, 'spine-type-unsupported': {'value': 82}, 'stack-packet-defensive': {'value': 83}, 'forward-engine-buffer-failed': {'value': 85}, 'forward-engine-interface-failed': {'value': 86}, 'fabric-link-failure': {'value': 87}, 'm-lag-consistency-check': {'value': 88}},), is_leaf=True, yang_name="error-down-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='error-down-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """error_down_type must be of a type compatible with error-down-type""",
          'defined-type': "huawei-ifm:error-down-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'bpdu-protection': {'value': 0}, 'auto-defend': {'value': 1}, 'monitor-link': {'value': 2}, 'portsec-reached-limit': {'value': 65}, 'storm-control': {'value': 66}, 'loopback-detect': {'value': 67}, 'dual-active': {'value': 68}, 'mac-address-flapping': {'value': 69}, 'no-stack-link': {'value': 70}, 'crc-statistics': {'value': 71}, 'transceiver-power-low': {'value': 72}, 'link-flap': {'value': 73}, 'l2-loop-occured': {'value': 74}, 'stack-member-exceed-limit': {'value': 75}, 'spine-member-exceed-limit': {'value': 76}, 'resource-mismatch': {'value': 77}, 'leaf-mstp': {'value': 78}, 'm-lag': {'value': 79}, 'fabric-uplink-threshold': {'value': 80}, 'stack-config-conflict': {'value': 81}, 'spine-type-unsupported': {'value': 82}, 'stack-packet-defensive': {'value': 83}, 'forward-engine-buffer-failed': {'value': 85}, 'forward-engine-interface-failed': {'value': 86}, 'fabric-link-failure': {'value': 87}, 'm-lag-consistency-check': {'value': 88}},), is_leaf=True, yang_name="error-down-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='error-down-type', is_config=True)""",
        })

    self.__error_down_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_error_down_type(self):
    self.__error_down_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'bpdu-protection': {'value': 0}, 'auto-defend': {'value': 1}, 'monitor-link': {'value': 2}, 'portsec-reached-limit': {'value': 65}, 'storm-control': {'value': 66}, 'loopback-detect': {'value': 67}, 'dual-active': {'value': 68}, 'mac-address-flapping': {'value': 69}, 'no-stack-link': {'value': 70}, 'crc-statistics': {'value': 71}, 'transceiver-power-low': {'value': 72}, 'link-flap': {'value': 73}, 'l2-loop-occured': {'value': 74}, 'stack-member-exceed-limit': {'value': 75}, 'spine-member-exceed-limit': {'value': 76}, 'resource-mismatch': {'value': 77}, 'leaf-mstp': {'value': 78}, 'm-lag': {'value': 79}, 'fabric-uplink-threshold': {'value': 80}, 'stack-config-conflict': {'value': 81}, 'spine-type-unsupported': {'value': 82}, 'stack-packet-defensive': {'value': 83}, 'forward-engine-buffer-failed': {'value': 85}, 'forward-engine-interface-failed': {'value': 86}, 'fabric-link-failure': {'value': 87}, 'm-lag-consistency-check': {'value': 88}},), is_leaf=True, yang_name="error-down-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='error-down-type', is_config=True)


  def _get_time_value(self):
    """
    Getter method for time_value, mapped from YANG variable /ifm/auto_recovery_times/auto_recovery_time/time_value (uint32)

    YANG Description: Delay for the status transition from down to up.
    """
    return self.__time_value
      
  def _set_time_value(self, v, load=False):
    """
    Setter method for time_value, mapped from YANG variable /ifm/auto_recovery_times/auto_recovery_time/time_value (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_time_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_time_value() directly.

    YANG Description: Delay for the status transition from down to up.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['30..86400']}), is_leaf=True, yang_name="time-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """time_value must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['30..86400']}), is_leaf=True, yang_name="time-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)""",
        })

    self.__time_value = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_time_value(self):
    self.__time_value = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['30..86400']}), is_leaf=True, yang_name="time-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)

  error_down_type = __builtin__.property(_get_error_down_type, _set_error_down_type)
  time_value = __builtin__.property(_get_time_value, _set_time_value)


  _pyangbind_elements = OrderedDict([('error_down_type', error_down_type), ('time_value', time_value), ])


class yc_auto_recovery_times_huawei_ifm__ifm_auto_recovery_times(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-ifm - based on the path /ifm/auto-recovery-times. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of automatic recovery time configuration.
  """
  __slots__ = ('_path_helper', '_extmethods', '__auto_recovery_time',)

  _yang_name = 'auto-recovery-times'
  _yang_namespace = 'urn:huawei:yang:huawei-ifm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__auto_recovery_time = YANGDynClass(base=YANGListType("error_down_type",yc_auto_recovery_time_huawei_ifm__ifm_auto_recovery_times_auto_recovery_time, yang_name="auto-recovery-time", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='error-down-type', extensions=None), is_container='list', yang_name="auto-recovery-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ifm', 'auto-recovery-times']

  def _get_auto_recovery_time(self):
    """
    Getter method for auto_recovery_time, mapped from YANG variable /ifm/auto_recovery_times/auto_recovery_time (list)

    YANG Description: Configure automatic recovery time.
    """
    return self.__auto_recovery_time
      
  def _set_auto_recovery_time(self, v, load=False):
    """
    Setter method for auto_recovery_time, mapped from YANG variable /ifm/auto_recovery_times/auto_recovery_time (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_auto_recovery_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_auto_recovery_time() directly.

    YANG Description: Configure automatic recovery time.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("error_down_type",yc_auto_recovery_time_huawei_ifm__ifm_auto_recovery_times_auto_recovery_time, yang_name="auto-recovery-time", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='error-down-type', extensions=None), is_container='list', yang_name="auto-recovery-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """auto_recovery_time must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("error_down_type",yc_auto_recovery_time_huawei_ifm__ifm_auto_recovery_times_auto_recovery_time, yang_name="auto-recovery-time", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='error-down-type', extensions=None), is_container='list', yang_name="auto-recovery-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='list', is_config=True)""",
        })

    self.__auto_recovery_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_auto_recovery_time(self):
    self.__auto_recovery_time = YANGDynClass(base=YANGListType("error_down_type",yc_auto_recovery_time_huawei_ifm__ifm_auto_recovery_times_auto_recovery_time, yang_name="auto-recovery-time", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='error-down-type', extensions=None), is_container='list', yang_name="auto-recovery-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='list', is_config=True)

  auto_recovery_time = __builtin__.property(_get_auto_recovery_time, _set_auto_recovery_time) # type: yc_auto_recovery_time_huawei_ifm__ifm_auto_recovery_times_auto_recovery_time


  _pyangbind_elements = OrderedDict([('auto_recovery_time', auto_recovery_time), ])


class yc_control_flap_huawei_ifm__ifm_interfaces_interface_control_flap(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-ifm - based on the path /ifm/interfaces/interface/control-flap. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enable/disable flapping control on an interface.
  """
  __slots__ = ('_path_helper', '_extmethods', '__suppress','__reuse','__ceiling','__decay_ok','__decay_ng','__control_flap_count',)

  _yang_name = 'control-flap'
  _yang_namespace = 'urn:huawei:yang:huawei-ifm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__suppress = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..20000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(2000), is_leaf=True, yang_name="suppress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)
    self.__reuse = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..20000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(750), is_leaf=True, yang_name="reuse", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)
    self.__ceiling = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1001..20000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(6000), is_leaf=True, yang_name="ceiling", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)
    self.__decay_ok = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..900']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(54), is_leaf=True, yang_name="decay-ok", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)
    self.__decay_ng = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..900']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(54), is_leaf=True, yang_name="decay-ng", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)
    self.__control_flap_count = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="control-flap-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ifm', 'interfaces', 'interface', 'control-flap']

  def _get_suppress(self):
    """
    Getter method for suppress, mapped from YANG variable /ifm/interfaces/interface/control_flap/suppress (uint32)

    YANG Description: Suppression threshold on an interface. The value must be greater than the reusing threshold and smaller than the suppression upper limit.
    """
    return self.__suppress
      
  def _set_suppress(self, v, load=False):
    """
    Setter method for suppress, mapped from YANG variable /ifm/interfaces/interface/control_flap/suppress (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_suppress is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_suppress() directly.

    YANG Description: Suppression threshold on an interface. The value must be greater than the reusing threshold and smaller than the suppression upper limit.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..20000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(2000), is_leaf=True, yang_name="suppress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """suppress must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..20000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(2000), is_leaf=True, yang_name="suppress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)""",
        })

    self.__suppress = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_suppress(self):
    self.__suppress = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..20000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(2000), is_leaf=True, yang_name="suppress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)


  def _get_reuse(self):
    """
    Getter method for reuse, mapped from YANG variable /ifm/interfaces/interface/control_flap/reuse (uint32)

    YANG Description: Reusing threshold of an interface. The value must be smaller than the suppression threshold.
    """
    return self.__reuse
      
  def _set_reuse(self, v, load=False):
    """
    Setter method for reuse, mapped from YANG variable /ifm/interfaces/interface/control_flap/reuse (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_reuse is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_reuse() directly.

    YANG Description: Reusing threshold of an interface. The value must be smaller than the suppression threshold.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..20000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(750), is_leaf=True, yang_name="reuse", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """reuse must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..20000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(750), is_leaf=True, yang_name="reuse", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)""",
        })

    self.__reuse = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_reuse(self):
    self.__reuse = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..20000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(750), is_leaf=True, yang_name="reuse", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)


  def _get_ceiling(self):
    """
    Getter method for ceiling, mapped from YANG variable /ifm/interfaces/interface/control_flap/ceiling (uint32)

    YANG Description: Maximum suppression value on an interface. The value should be greater than the damping suppression threshold.
    """
    return self.__ceiling
      
  def _set_ceiling(self, v, load=False):
    """
    Setter method for ceiling, mapped from YANG variable /ifm/interfaces/interface/control_flap/ceiling (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ceiling is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ceiling() directly.

    YANG Description: Maximum suppression value on an interface. The value should be greater than the damping suppression threshold.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1001..20000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(6000), is_leaf=True, yang_name="ceiling", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ceiling must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1001..20000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(6000), is_leaf=True, yang_name="ceiling", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)""",
        })

    self.__ceiling = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ceiling(self):
    self.__ceiling = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1001..20000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(6000), is_leaf=True, yang_name="ceiling", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)


  def _get_decay_ok(self):
    """
    Getter method for decay_ok, mapped from YANG variable /ifm/interfaces/interface/control_flap/decay_ok (uint32)

    YANG Description: The penalty value of an Up interface attenuates to 1/2.
    """
    return self.__decay_ok
      
  def _set_decay_ok(self, v, load=False):
    """
    Setter method for decay_ok, mapped from YANG variable /ifm/interfaces/interface/control_flap/decay_ok (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_decay_ok is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_decay_ok() directly.

    YANG Description: The penalty value of an Up interface attenuates to 1/2.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..900']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(54), is_leaf=True, yang_name="decay-ok", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """decay_ok must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..900']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(54), is_leaf=True, yang_name="decay-ok", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)""",
        })

    self.__decay_ok = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_decay_ok(self):
    self.__decay_ok = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..900']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(54), is_leaf=True, yang_name="decay-ok", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)


  def _get_decay_ng(self):
    """
    Getter method for decay_ng, mapped from YANG variable /ifm/interfaces/interface/control_flap/decay_ng (uint32)

    YANG Description: The penalty value of a Down interface attenuates to 1/2.
    """
    return self.__decay_ng
      
  def _set_decay_ng(self, v, load=False):
    """
    Setter method for decay_ng, mapped from YANG variable /ifm/interfaces/interface/control_flap/decay_ng (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_decay_ng is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_decay_ng() directly.

    YANG Description: The penalty value of a Down interface attenuates to 1/2.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..900']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(54), is_leaf=True, yang_name="decay-ng", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """decay_ng must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..900']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(54), is_leaf=True, yang_name="decay-ng", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)""",
        })

    self.__decay_ng = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_decay_ng(self):
    self.__decay_ng = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..900']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(54), is_leaf=True, yang_name="decay-ng", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)


  def _get_control_flap_count(self):
    """
    Getter method for control_flap_count, mapped from YANG variable /ifm/interfaces/interface/control_flap/control_flap_count (uint32)

    YANG Description: Status suppression count of an interface.
    """
    return self.__control_flap_count
      
  def _set_control_flap_count(self, v, load=False):
    """
    Setter method for control_flap_count, mapped from YANG variable /ifm/interfaces/interface/control_flap/control_flap_count (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_control_flap_count is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_control_flap_count() directly.

    YANG Description: Status suppression count of an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="control-flap-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """control_flap_count must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="control-flap-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)""",
        })

    self.__control_flap_count = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_control_flap_count(self):
    self.__control_flap_count = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="control-flap-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)

  suppress = __builtin__.property(_get_suppress, _set_suppress)
  reuse = __builtin__.property(_get_reuse, _set_reuse)
  ceiling = __builtin__.property(_get_ceiling, _set_ceiling)
  decay_ok = __builtin__.property(_get_decay_ok, _set_decay_ok)
  decay_ng = __builtin__.property(_get_decay_ng, _set_decay_ng)
  control_flap_count = __builtin__.property(_get_control_flap_count)


  _pyangbind_elements = OrderedDict([('suppress', suppress), ('reuse', reuse), ('ceiling', ceiling), ('decay_ok', decay_ok), ('decay_ng', decay_ng), ('control_flap_count', control_flap_count), ])


class yc_trap_threshold_huawei_ifm__ifm_interfaces_interface_trap_threshold(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-ifm - based on the path /ifm/interfaces/interface/trap-threshold. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure the trap threshold.
  """
  __slots__ = ('_path_helper', '_extmethods', '__input_rising_rate','__input_resume_rate','__output_rising_rate','__output_resume_rate',)

  _yang_name = 'trap-threshold'
  _yang_namespace = 'urn:huawei:yang:huawei-ifm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__input_rising_rate = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..100']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(100), is_leaf=True, yang_name="input-rising-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)
    self.__input_resume_rate = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..100']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(100), is_leaf=True, yang_name="input-resume-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)
    self.__output_rising_rate = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..100']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(100), is_leaf=True, yang_name="output-rising-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)
    self.__output_resume_rate = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..100']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(100), is_leaf=True, yang_name="output-resume-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ifm', 'interfaces', 'interface', 'trap-threshold']

  def _get_input_rising_rate(self):
    """
    Getter method for input_rising_rate, mapped from YANG variable /ifm/interfaces/interface/trap_threshold/input_rising_rate (uint32)

    YANG Description: Input bandwidth usage trap threshold.
    """
    return self.__input_rising_rate
      
  def _set_input_rising_rate(self, v, load=False):
    """
    Setter method for input_rising_rate, mapped from YANG variable /ifm/interfaces/interface/trap_threshold/input_rising_rate (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_input_rising_rate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_input_rising_rate() directly.

    YANG Description: Input bandwidth usage trap threshold.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..100']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(100), is_leaf=True, yang_name="input-rising-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """input_rising_rate must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..100']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(100), is_leaf=True, yang_name="input-rising-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)""",
        })

    self.__input_rising_rate = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_input_rising_rate(self):
    self.__input_rising_rate = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..100']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(100), is_leaf=True, yang_name="input-rising-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)


  def _get_input_resume_rate(self):
    """
    Getter method for input_resume_rate, mapped from YANG variable /ifm/interfaces/interface/trap_threshold/input_resume_rate (uint32)

    YANG Description: Input bandwidth usage resume threshold.
    """
    return self.__input_resume_rate
      
  def _set_input_resume_rate(self, v, load=False):
    """
    Setter method for input_resume_rate, mapped from YANG variable /ifm/interfaces/interface/trap_threshold/input_resume_rate (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_input_resume_rate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_input_resume_rate() directly.

    YANG Description: Input bandwidth usage resume threshold.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..100']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(100), is_leaf=True, yang_name="input-resume-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """input_resume_rate must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..100']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(100), is_leaf=True, yang_name="input-resume-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)""",
        })

    self.__input_resume_rate = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_input_resume_rate(self):
    self.__input_resume_rate = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..100']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(100), is_leaf=True, yang_name="input-resume-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)


  def _get_output_rising_rate(self):
    """
    Getter method for output_rising_rate, mapped from YANG variable /ifm/interfaces/interface/trap_threshold/output_rising_rate (uint32)

    YANG Description: Output bandwidth usage trap threshold.
    """
    return self.__output_rising_rate
      
  def _set_output_rising_rate(self, v, load=False):
    """
    Setter method for output_rising_rate, mapped from YANG variable /ifm/interfaces/interface/trap_threshold/output_rising_rate (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_output_rising_rate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_output_rising_rate() directly.

    YANG Description: Output bandwidth usage trap threshold.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..100']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(100), is_leaf=True, yang_name="output-rising-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """output_rising_rate must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..100']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(100), is_leaf=True, yang_name="output-rising-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)""",
        })

    self.__output_rising_rate = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_output_rising_rate(self):
    self.__output_rising_rate = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..100']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(100), is_leaf=True, yang_name="output-rising-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)


  def _get_output_resume_rate(self):
    """
    Getter method for output_resume_rate, mapped from YANG variable /ifm/interfaces/interface/trap_threshold/output_resume_rate (uint32)

    YANG Description: Output bandwidth usage resume threshold.
    """
    return self.__output_resume_rate
      
  def _set_output_resume_rate(self, v, load=False):
    """
    Setter method for output_resume_rate, mapped from YANG variable /ifm/interfaces/interface/trap_threshold/output_resume_rate (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_output_resume_rate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_output_resume_rate() directly.

    YANG Description: Output bandwidth usage resume threshold.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..100']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(100), is_leaf=True, yang_name="output-resume-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """output_resume_rate must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..100']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(100), is_leaf=True, yang_name="output-resume-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)""",
        })

    self.__output_resume_rate = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_output_resume_rate(self):
    self.__output_resume_rate = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..100']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(100), is_leaf=True, yang_name="output-resume-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)

  input_rising_rate = __builtin__.property(_get_input_rising_rate, _set_input_rising_rate)
  input_resume_rate = __builtin__.property(_get_input_resume_rate, _set_input_resume_rate)
  output_rising_rate = __builtin__.property(_get_output_rising_rate, _set_output_rising_rate)
  output_resume_rate = __builtin__.property(_get_output_resume_rate, _set_output_resume_rate)


  _pyangbind_elements = OrderedDict([('input_rising_rate', input_rising_rate), ('input_resume_rate', input_resume_rate), ('output_rising_rate', output_rising_rate), ('output_resume_rate', output_resume_rate), ])


class yc_ignore_damp_huawei_ifm__ifm_interfaces_interface_ignore_damp(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-ifm - based on the path /ifm/interfaces/interface/ignore-damp. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure an interface to ignore the global damp-interface function.
  """
  __slots__ = ('_path_helper', '_extmethods', '__ignore_global_damp',)

  _yang_name = 'ignore-damp'
  _yang_namespace = 'urn:huawei:yang:huawei-ifm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ignore_global_damp = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ignore-global-damp", parent=self, choice=('damping', 'ignore-damp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ifm', 'interfaces', 'interface', 'ignore-damp']

  def _get_ignore_global_damp(self):
    """
    Getter method for ignore_global_damp, mapped from YANG variable /ifm/interfaces/interface/ignore_damp/ignore_global_damp (boolean)

    YANG Description: Enable/disable an interface to ignore the global damp-interface function.
    """
    return self.__ignore_global_damp
      
  def _set_ignore_global_damp(self, v, load=False):
    """
    Setter method for ignore_global_damp, mapped from YANG variable /ifm/interfaces/interface/ignore_damp/ignore_global_damp (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ignore_global_damp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ignore_global_damp() directly.

    YANG Description: Enable/disable an interface to ignore the global damp-interface function.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ignore-global-damp", parent=self, choice=('damping', 'ignore-damp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ignore_global_damp must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ignore-global-damp", parent=self, choice=('damping', 'ignore-damp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=True)""",
        })

    self.__ignore_global_damp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ignore_global_damp(self):
    self.__ignore_global_damp = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ignore-global-damp", parent=self, choice=('damping', 'ignore-damp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=True)

  ignore_global_damp = __builtin__.property(_get_ignore_global_damp, _set_ignore_global_damp)

  __choices__ = {'damping': {'ignore-damp': ['ignore_global_damp']}}
  _pyangbind_elements = OrderedDict([('ignore_global_damp', ignore_global_damp), ])


class yc_auto_huawei_ifm__ifm_interfaces_interface_damp_auto(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-ifm - based on the path /ifm/interfaces/interface/damp/auto. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure an auto suppression level.
  """
  __slots__ = ('_path_helper', '_extmethods', '__level',)

  _yang_name = 'auto'
  _yang_namespace = 'urn:huawei:yang:huawei-ifm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__level = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'light': {'value': 0}, 'middle': {'value': 1}, 'heavy': {'value': 2}},), default=six.text_type("light"), is_leaf=True, yang_name="level", parent=self, choice=('level', 'auto'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='damp-level-type', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ifm', 'interfaces', 'interface', 'damp', 'auto']

  def _get_level(self):
    """
    Getter method for level, mapped from YANG variable /ifm/interfaces/interface/damp/auto/level (damp-level-type)

    YANG Description: Auto damping level.
    """
    return self.__level
      
  def _set_level(self, v, load=False):
    """
    Setter method for level, mapped from YANG variable /ifm/interfaces/interface/damp/auto/level (damp-level-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_level is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_level() directly.

    YANG Description: Auto damping level.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'light': {'value': 0}, 'middle': {'value': 1}, 'heavy': {'value': 2}},), default=six.text_type("light"), is_leaf=True, yang_name="level", parent=self, choice=('level', 'auto'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='damp-level-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """level must be of a type compatible with damp-level-type""",
          'defined-type': "huawei-ifm:damp-level-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'light': {'value': 0}, 'middle': {'value': 1}, 'heavy': {'value': 2}},), default=six.text_type("light"), is_leaf=True, yang_name="level", parent=self, choice=('level', 'auto'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='damp-level-type', is_config=True)""",
        })

    self.__level = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_level(self):
    self.__level = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'light': {'value': 0}, 'middle': {'value': 1}, 'heavy': {'value': 2}},), default=six.text_type("light"), is_leaf=True, yang_name="level", parent=self, choice=('level', 'auto'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='damp-level-type', is_config=True)

  level = __builtin__.property(_get_level, _set_level)

  __choices__ = {'level': {'auto': ['level']}}
  _pyangbind_elements = OrderedDict([('level', level), ])


class yc_manual_huawei_ifm__ifm_interfaces_interface_damp_manual(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-ifm - based on the path /ifm/interfaces/interface/damp/manual. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure a manual suppression level.
  """
  __slots__ = ('_path_helper', '_extmethods', '__suppress','__reuse','__max_suppress_time','__half_life_period',)

  _yang_name = 'manual'
  _yang_namespace = 'urn:huawei:yang:huawei-ifm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__suppress = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..20000']}), is_leaf=True, yang_name="suppress", parent=self, choice=('level', 'manual'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)
    self.__reuse = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..20000']}), is_leaf=True, yang_name="reuse", parent=self, choice=('level', 'manual'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)
    self.__max_suppress_time = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="max-suppress-time", parent=self, choice=('level', 'manual'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint16', is_config=True)
    self.__half_life_period = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..60']}), is_leaf=True, yang_name="half-life-period", parent=self, choice=('level', 'manual'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint16', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ifm', 'interfaces', 'interface', 'damp', 'manual']

  def _get_suppress(self):
    """
    Getter method for suppress, mapped from YANG variable /ifm/interfaces/interface/damp/manual/suppress (uint32)

    YANG Description: 1000 times of suppress threshold.
    """
    return self.__suppress
      
  def _set_suppress(self, v, load=False):
    """
    Setter method for suppress, mapped from YANG variable /ifm/interfaces/interface/damp/manual/suppress (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_suppress is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_suppress() directly.

    YANG Description: 1000 times of suppress threshold.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..20000']}), is_leaf=True, yang_name="suppress", parent=self, choice=('level', 'manual'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """suppress must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..20000']}), is_leaf=True, yang_name="suppress", parent=self, choice=('level', 'manual'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)""",
        })

    self.__suppress = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_suppress(self):
    self.__suppress = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..20000']}), is_leaf=True, yang_name="suppress", parent=self, choice=('level', 'manual'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)


  def _get_reuse(self):
    """
    Getter method for reuse, mapped from YANG variable /ifm/interfaces/interface/damp/manual/reuse (uint32)

    YANG Description: 1000 times of reuse threshold.
    """
    return self.__reuse
      
  def _set_reuse(self, v, load=False):
    """
    Setter method for reuse, mapped from YANG variable /ifm/interfaces/interface/damp/manual/reuse (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_reuse is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_reuse() directly.

    YANG Description: 1000 times of reuse threshold.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..20000']}), is_leaf=True, yang_name="reuse", parent=self, choice=('level', 'manual'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """reuse must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..20000']}), is_leaf=True, yang_name="reuse", parent=self, choice=('level', 'manual'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)""",
        })

    self.__reuse = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_reuse(self):
    self.__reuse = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..20000']}), is_leaf=True, yang_name="reuse", parent=self, choice=('level', 'manual'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)


  def _get_max_suppress_time(self):
    """
    Getter method for max_suppress_time, mapped from YANG variable /ifm/interfaces/interface/damp/manual/max_suppress_time (uint16)

    YANG Description: Max suppress time.
    """
    return self.__max_suppress_time
      
  def _set_max_suppress_time(self, v, load=False):
    """
    Setter method for max_suppress_time, mapped from YANG variable /ifm/interfaces/interface/damp/manual/max_suppress_time (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_suppress_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_suppress_time() directly.

    YANG Description: Max suppress time.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="max-suppress-time", parent=self, choice=('level', 'manual'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_suppress_time must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="max-suppress-time", parent=self, choice=('level', 'manual'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint16', is_config=True)""",
        })

    self.__max_suppress_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_suppress_time(self):
    self.__max_suppress_time = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="max-suppress-time", parent=self, choice=('level', 'manual'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint16', is_config=True)


  def _get_half_life_period(self):
    """
    Getter method for half_life_period, mapped from YANG variable /ifm/interfaces/interface/damp/manual/half_life_period (uint16)

    YANG Description: Half life time.
    """
    return self.__half_life_period
      
  def _set_half_life_period(self, v, load=False):
    """
    Setter method for half_life_period, mapped from YANG variable /ifm/interfaces/interface/damp/manual/half_life_period (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_half_life_period is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_half_life_period() directly.

    YANG Description: Half life time.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..60']}), is_leaf=True, yang_name="half-life-period", parent=self, choice=('level', 'manual'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """half_life_period must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..60']}), is_leaf=True, yang_name="half-life-period", parent=self, choice=('level', 'manual'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint16', is_config=True)""",
        })

    self.__half_life_period = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_half_life_period(self):
    self.__half_life_period = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..60']}), is_leaf=True, yang_name="half-life-period", parent=self, choice=('level', 'manual'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint16', is_config=True)

  suppress = __builtin__.property(_get_suppress, _set_suppress)
  reuse = __builtin__.property(_get_reuse, _set_reuse)
  max_suppress_time = __builtin__.property(_get_max_suppress_time, _set_max_suppress_time)
  half_life_period = __builtin__.property(_get_half_life_period, _set_half_life_period)

  __choices__ = {'level': {'manual': ['suppress', 'reuse', 'max_suppress_time', 'half_life_period']}}
  _pyangbind_elements = OrderedDict([('suppress', suppress), ('reuse', reuse), ('max_suppress_time', max_suppress_time), ('half_life_period', half_life_period), ])


class yc_damp_huawei_ifm__ifm_interfaces_interface_damp(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-ifm - based on the path /ifm/interfaces/interface/damp. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enable/disable suppression on an interface's physical status flappings.
  """
  __slots__ = ('_path_helper', '_extmethods', '__tx_off','__auto','__manual',)

  _yang_name = 'damp'
  _yang_namespace = 'urn:huawei:yang:huawei-ifm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__tx_off = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="tx-off", parent=self, choice=('damping', 'damp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=True)
    self.__auto = YANGDynClass(base=yc_auto_huawei_ifm__ifm_interfaces_interface_damp_auto, is_container='container', yang_name="auto", parent=self, choice=('level', 'auto'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)
    self.__manual = YANGDynClass(base=yc_manual_huawei_ifm__ifm_interfaces_interface_damp_manual, is_container='container', yang_name="manual", parent=self, choice=('level', 'manual'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ifm', 'interfaces', 'interface', 'damp']

  def _get_tx_off(self):
    """
    Getter method for tx_off, mapped from YANG variable /ifm/interfaces/interface/damp/tx_off (boolean)

    YANG Description: Enable/disable an interface suppressed due to status flapping from sending signals.
    """
    return self.__tx_off
      
  def _set_tx_off(self, v, load=False):
    """
    Setter method for tx_off, mapped from YANG variable /ifm/interfaces/interface/damp/tx_off (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tx_off is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tx_off() directly.

    YANG Description: Enable/disable an interface suppressed due to status flapping from sending signals.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="tx-off", parent=self, choice=('damping', 'damp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tx_off must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="tx-off", parent=self, choice=('damping', 'damp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=True)""",
        })

    self.__tx_off = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tx_off(self):
    self.__tx_off = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="tx-off", parent=self, choice=('damping', 'damp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=True)


  def _get_auto(self):
    """
    Getter method for auto, mapped from YANG variable /ifm/interfaces/interface/damp/auto (container)

    YANG Description: Configure an auto suppression level.
    """
    return self.__auto
      
  def _set_auto(self, v, load=False):
    """
    Setter method for auto, mapped from YANG variable /ifm/interfaces/interface/damp/auto (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_auto is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_auto() directly.

    YANG Description: Configure an auto suppression level.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_auto_huawei_ifm__ifm_interfaces_interface_damp_auto, is_container='container', yang_name="auto", parent=self, choice=('level', 'auto'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """auto must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_auto_huawei_ifm__ifm_interfaces_interface_damp_auto, is_container='container', yang_name="auto", parent=self, choice=('level', 'auto'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)""",
        })

    self.__auto = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_auto(self):
    self.__auto = YANGDynClass(base=yc_auto_huawei_ifm__ifm_interfaces_interface_damp_auto, is_container='container', yang_name="auto", parent=self, choice=('level', 'auto'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)


  def _get_manual(self):
    """
    Getter method for manual, mapped from YANG variable /ifm/interfaces/interface/damp/manual (container)

    YANG Description: Configure a manual suppression level.
    """
    return self.__manual
      
  def _set_manual(self, v, load=False):
    """
    Setter method for manual, mapped from YANG variable /ifm/interfaces/interface/damp/manual (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_manual is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_manual() directly.

    YANG Description: Configure a manual suppression level.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_manual_huawei_ifm__ifm_interfaces_interface_damp_manual, is_container='container', yang_name="manual", parent=self, choice=('level', 'manual'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """manual must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_manual_huawei_ifm__ifm_interfaces_interface_damp_manual, is_container='container', yang_name="manual", parent=self, choice=('level', 'manual'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)""",
        })

    self.__manual = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_manual(self):
    self.__manual = YANGDynClass(base=yc_manual_huawei_ifm__ifm_interfaces_interface_damp_manual, is_container='container', yang_name="manual", parent=self, choice=('level', 'manual'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)

  tx_off = __builtin__.property(_get_tx_off, _set_tx_off)
  auto = __builtin__.property(_get_auto, _set_auto) # type: yc_auto_huawei_ifm__ifm_interfaces_interface_damp_auto
  manual = __builtin__.property(_get_manual, _set_manual) # type: yc_manual_huawei_ifm__ifm_interfaces_interface_damp_manual

  __choices__ = {'damping': {'damp': ['tx_off']}, 'level': {'auto': ['auto'], 'manual': ['manual']}}
  _pyangbind_elements = OrderedDict([('tx_off', tx_off), ('auto', auto), ('manual', manual), ])


class yc_damp_state_huawei_ifm__ifm_interfaces_interface_damp_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-ifm - based on the path /ifm/interfaces/interface/damp-state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state of interface suppression information.
  """
  __slots__ = ('_path_helper', '_extmethods', '__suppress_status','__suppress','__reuse','__max_suppress_time','__half_life_period','__damp_reuse_time','__current_penalty','__max_penalty',)

  _yang_name = 'damp-state'
  _yang_namespace = 'urn:huawei:yang:huawei-ifm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__suppress_status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'suppressed': {'value': 0}, 'unsuppressed': {'value': 1}},), is_leaf=True, yang_name="suppress-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='damp-status-type', is_config=False)
    self.__suppress = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..20000']}), is_leaf=True, yang_name="suppress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)
    self.__reuse = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..20000']}), is_leaf=True, yang_name="reuse", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)
    self.__max_suppress_time = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="max-suppress-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint16', is_config=False)
    self.__half_life_period = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..60']}), is_leaf=True, yang_name="half-life-period", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint16', is_config=False)
    self.__damp_reuse_time = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..255']}), is_leaf=True, yang_name="damp-reuse-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint16', is_config=False)
    self.__current_penalty = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="current-penalty", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)
    self.__max_penalty = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-penalty", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ifm', 'interfaces', 'interface', 'damp-state']

  def _get_suppress_status(self):
    """
    Getter method for suppress_status, mapped from YANG variable /ifm/interfaces/interface/damp_state/suppress_status (damp-status-type)

    YANG Description: Interface status suppression state.
    """
    return self.__suppress_status
      
  def _set_suppress_status(self, v, load=False):
    """
    Setter method for suppress_status, mapped from YANG variable /ifm/interfaces/interface/damp_state/suppress_status (damp-status-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_suppress_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_suppress_status() directly.

    YANG Description: Interface status suppression state.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'suppressed': {'value': 0}, 'unsuppressed': {'value': 1}},), is_leaf=True, yang_name="suppress-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='damp-status-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """suppress_status must be of a type compatible with damp-status-type""",
          'defined-type': "huawei-ifm:damp-status-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'suppressed': {'value': 0}, 'unsuppressed': {'value': 1}},), is_leaf=True, yang_name="suppress-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='damp-status-type', is_config=False)""",
        })

    self.__suppress_status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_suppress_status(self):
    self.__suppress_status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'suppressed': {'value': 0}, 'unsuppressed': {'value': 1}},), is_leaf=True, yang_name="suppress-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='damp-status-type', is_config=False)


  def _get_suppress(self):
    """
    Getter method for suppress, mapped from YANG variable /ifm/interfaces/interface/damp_state/suppress (uint32)

    YANG Description: 1000 times of suppress threshold.
    """
    return self.__suppress
      
  def _set_suppress(self, v, load=False):
    """
    Setter method for suppress, mapped from YANG variable /ifm/interfaces/interface/damp_state/suppress (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_suppress is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_suppress() directly.

    YANG Description: 1000 times of suppress threshold.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..20000']}), is_leaf=True, yang_name="suppress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """suppress must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..20000']}), is_leaf=True, yang_name="suppress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)""",
        })

    self.__suppress = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_suppress(self):
    self.__suppress = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..20000']}), is_leaf=True, yang_name="suppress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)


  def _get_reuse(self):
    """
    Getter method for reuse, mapped from YANG variable /ifm/interfaces/interface/damp_state/reuse (uint32)

    YANG Description: 1000 times of reuse threshold.
    """
    return self.__reuse
      
  def _set_reuse(self, v, load=False):
    """
    Setter method for reuse, mapped from YANG variable /ifm/interfaces/interface/damp_state/reuse (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_reuse is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_reuse() directly.

    YANG Description: 1000 times of reuse threshold.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..20000']}), is_leaf=True, yang_name="reuse", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """reuse must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..20000']}), is_leaf=True, yang_name="reuse", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)""",
        })

    self.__reuse = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_reuse(self):
    self.__reuse = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..20000']}), is_leaf=True, yang_name="reuse", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)


  def _get_max_suppress_time(self):
    """
    Getter method for max_suppress_time, mapped from YANG variable /ifm/interfaces/interface/damp_state/max_suppress_time (uint16)

    YANG Description: Max suppress time.
    """
    return self.__max_suppress_time
      
  def _set_max_suppress_time(self, v, load=False):
    """
    Setter method for max_suppress_time, mapped from YANG variable /ifm/interfaces/interface/damp_state/max_suppress_time (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_suppress_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_suppress_time() directly.

    YANG Description: Max suppress time.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="max-suppress-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_suppress_time must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="max-suppress-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint16', is_config=False)""",
        })

    self.__max_suppress_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_suppress_time(self):
    self.__max_suppress_time = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="max-suppress-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint16', is_config=False)


  def _get_half_life_period(self):
    """
    Getter method for half_life_period, mapped from YANG variable /ifm/interfaces/interface/damp_state/half_life_period (uint16)

    YANG Description: Half life time.
    """
    return self.__half_life_period
      
  def _set_half_life_period(self, v, load=False):
    """
    Setter method for half_life_period, mapped from YANG variable /ifm/interfaces/interface/damp_state/half_life_period (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_half_life_period is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_half_life_period() directly.

    YANG Description: Half life time.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..60']}), is_leaf=True, yang_name="half-life-period", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """half_life_period must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..60']}), is_leaf=True, yang_name="half-life-period", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint16', is_config=False)""",
        })

    self.__half_life_period = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_half_life_period(self):
    self.__half_life_period = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..60']}), is_leaf=True, yang_name="half-life-period", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint16', is_config=False)


  def _get_damp_reuse_time(self):
    """
    Getter method for damp_reuse_time, mapped from YANG variable /ifm/interfaces/interface/damp_state/damp_reuse_time (uint16)

    YANG Description: Damping reuse time.
    """
    return self.__damp_reuse_time
      
  def _set_damp_reuse_time(self, v, load=False):
    """
    Setter method for damp_reuse_time, mapped from YANG variable /ifm/interfaces/interface/damp_state/damp_reuse_time (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_damp_reuse_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_damp_reuse_time() directly.

    YANG Description: Damping reuse time.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..255']}), is_leaf=True, yang_name="damp-reuse-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """damp_reuse_time must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..255']}), is_leaf=True, yang_name="damp-reuse-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint16', is_config=False)""",
        })

    self.__damp_reuse_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_damp_reuse_time(self):
    self.__damp_reuse_time = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..255']}), is_leaf=True, yang_name="damp-reuse-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint16', is_config=False)


  def _get_current_penalty(self):
    """
    Getter method for current_penalty, mapped from YANG variable /ifm/interfaces/interface/damp_state/current_penalty (uint32)

    YANG Description: 1000 times of current penalty.
    """
    return self.__current_penalty
      
  def _set_current_penalty(self, v, load=False):
    """
    Setter method for current_penalty, mapped from YANG variable /ifm/interfaces/interface/damp_state/current_penalty (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_current_penalty is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_current_penalty() directly.

    YANG Description: 1000 times of current penalty.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="current-penalty", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """current_penalty must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="current-penalty", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)""",
        })

    self.__current_penalty = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_current_penalty(self):
    self.__current_penalty = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="current-penalty", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)


  def _get_max_penalty(self):
    """
    Getter method for max_penalty, mapped from YANG variable /ifm/interfaces/interface/damp_state/max_penalty (uint32)

    YANG Description: 1000 times of max penalty.
    """
    return self.__max_penalty
      
  def _set_max_penalty(self, v, load=False):
    """
    Setter method for max_penalty, mapped from YANG variable /ifm/interfaces/interface/damp_state/max_penalty (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_penalty is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_penalty() directly.

    YANG Description: 1000 times of max penalty.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-penalty", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_penalty must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-penalty", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)""",
        })

    self.__max_penalty = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_penalty(self):
    self.__max_penalty = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-penalty", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)

  suppress_status = __builtin__.property(_get_suppress_status)
  suppress = __builtin__.property(_get_suppress)
  reuse = __builtin__.property(_get_reuse)
  max_suppress_time = __builtin__.property(_get_max_suppress_time)
  half_life_period = __builtin__.property(_get_half_life_period)
  damp_reuse_time = __builtin__.property(_get_damp_reuse_time)
  current_penalty = __builtin__.property(_get_current_penalty)
  max_penalty = __builtin__.property(_get_max_penalty)


  _pyangbind_elements = OrderedDict([('suppress_status', suppress_status), ('suppress', suppress), ('reuse', reuse), ('max_suppress_time', max_suppress_time), ('half_life_period', half_life_period), ('damp_reuse_time', damp_reuse_time), ('current_penalty', current_penalty), ('max_penalty', max_penalty), ])


class yc_dynamic_huawei_ifm__ifm_interfaces_interface_dynamic(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-ifm - based on the path /ifm/interfaces/interface/dynamic. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state of interfaces.
  """
  __slots__ = ('_path_helper', '_extmethods', '__oper_status','__physical_status','__link_status','__mtu','__bandwidth','__ipv4_status','__ipv6_status','__is_control_flap_damp','__mac_address','__line_protocol_up_time','__is_offline','__link_quality_grade','__sub_if_counts',)

  _yang_name = 'dynamic'
  _yang_namespace = 'urn:huawei:yang:huawei-ifm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__oper_status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'down': {'value': 0}, 'up': {'value': 1}},), is_leaf=True, yang_name="oper-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='port-status', is_config=False)
    self.__physical_status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'down': {'value': 0}, 'up': {'value': 1}},), is_leaf=True, yang_name="physical-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='port-status', is_config=False)
    self.__link_status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'down': {'value': 0}, 'up': {'value': 1}},), is_leaf=True, yang_name="link-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='port-status', is_config=False)
    self.__mtu = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)
    self.__bandwidth = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='pub-type:band-width', is_config=False)
    self.__ipv4_status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'down': {'value': 0}, 'up': {'value': 1}},), is_leaf=True, yang_name="ipv4-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='port-status', is_config=False)
    self.__ipv6_status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'down': {'value': 0}, 'up': {'value': 1}},), is_leaf=True, yang_name="ipv6-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='port-status', is_config=False)
    self.__is_control_flap_damp = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is-control-flap-damp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=False)
    self.__mac_address = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9a-f]{4}(-[0-9a-f]{4}){2}', 'length': ['0..255']}), restriction_dict={'length': ['1..14']}), is_leaf=True, yang_name="mac-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='pub-type:mac-address', is_config=False)
    self.__line_protocol_up_time = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="line-protocol-up-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='yang:date-and-time', is_config=False)
    self.__is_offline = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is-offline", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=False)
    self.__link_quality_grade = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'good': {'value': 0}, 'high': {'value': 1}, 'middle': {'value': 2}, 'low': {'value': 4}},), is_leaf=True, yang_name="link-quality-grade", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='link-quality-grade-type', is_config=False)
    self.__sub_if_counts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="sub-if-counts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ifm', 'interfaces', 'interface', 'dynamic']

  def _get_oper_status(self):
    """
    Getter method for oper_status, mapped from YANG variable /ifm/interfaces/interface/dynamic/oper_status (port-status)

    YANG Description: Running status of an interface.
    """
    return self.__oper_status
      
  def _set_oper_status(self, v, load=False):
    """
    Setter method for oper_status, mapped from YANG variable /ifm/interfaces/interface/dynamic/oper_status (port-status)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_oper_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_oper_status() directly.

    YANG Description: Running status of an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'down': {'value': 0}, 'up': {'value': 1}},), is_leaf=True, yang_name="oper-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='port-status', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """oper_status must be of a type compatible with port-status""",
          'defined-type': "huawei-ifm:port-status",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'down': {'value': 0}, 'up': {'value': 1}},), is_leaf=True, yang_name="oper-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='port-status', is_config=False)""",
        })

    self.__oper_status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_oper_status(self):
    self.__oper_status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'down': {'value': 0}, 'up': {'value': 1}},), is_leaf=True, yang_name="oper-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='port-status', is_config=False)


  def _get_physical_status(self):
    """
    Getter method for physical_status, mapped from YANG variable /ifm/interfaces/interface/dynamic/physical_status (port-status)

    YANG Description: Physical status of an interface.
    """
    return self.__physical_status
      
  def _set_physical_status(self, v, load=False):
    """
    Setter method for physical_status, mapped from YANG variable /ifm/interfaces/interface/dynamic/physical_status (port-status)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_physical_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_physical_status() directly.

    YANG Description: Physical status of an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'down': {'value': 0}, 'up': {'value': 1}},), is_leaf=True, yang_name="physical-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='port-status', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """physical_status must be of a type compatible with port-status""",
          'defined-type': "huawei-ifm:port-status",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'down': {'value': 0}, 'up': {'value': 1}},), is_leaf=True, yang_name="physical-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='port-status', is_config=False)""",
        })

    self.__physical_status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_physical_status(self):
    self.__physical_status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'down': {'value': 0}, 'up': {'value': 1}},), is_leaf=True, yang_name="physical-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='port-status', is_config=False)


  def _get_link_status(self):
    """
    Getter method for link_status, mapped from YANG variable /ifm/interfaces/interface/dynamic/link_status (port-status)

    YANG Description: Link status of an interface.
    """
    return self.__link_status
      
  def _set_link_status(self, v, load=False):
    """
    Setter method for link_status, mapped from YANG variable /ifm/interfaces/interface/dynamic/link_status (port-status)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_link_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_link_status() directly.

    YANG Description: Link status of an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'down': {'value': 0}, 'up': {'value': 1}},), is_leaf=True, yang_name="link-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='port-status', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """link_status must be of a type compatible with port-status""",
          'defined-type': "huawei-ifm:port-status",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'down': {'value': 0}, 'up': {'value': 1}},), is_leaf=True, yang_name="link-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='port-status', is_config=False)""",
        })

    self.__link_status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_link_status(self):
    self.__link_status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'down': {'value': 0}, 'up': {'value': 1}},), is_leaf=True, yang_name="link-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='port-status', is_config=False)


  def _get_mtu(self):
    """
    Getter method for mtu, mapped from YANG variable /ifm/interfaces/interface/dynamic/mtu (uint32)

    YANG Description: Dynamic MTU of an interface.
    """
    return self.__mtu
      
  def _set_mtu(self, v, load=False):
    """
    Setter method for mtu, mapped from YANG variable /ifm/interfaces/interface/dynamic/mtu (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mtu is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mtu() directly.

    YANG Description: Dynamic MTU of an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mtu must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)""",
        })

    self.__mtu = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mtu(self):
    self.__mtu = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)


  def _get_bandwidth(self):
    """
    Getter method for bandwidth, mapped from YANG variable /ifm/interfaces/interface/dynamic/bandwidth (pub-type:band-width)

    YANG Description: Bandwidth of an interface.
    """
    return self.__bandwidth
      
  def _set_bandwidth(self, v, load=False):
    """
    Setter method for bandwidth, mapped from YANG variable /ifm/interfaces/interface/dynamic/bandwidth (pub-type:band-width)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bandwidth is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bandwidth() directly.

    YANG Description: Bandwidth of an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='pub-type:band-width', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bandwidth must be of a type compatible with pub-type:band-width""",
          'defined-type': "pub-type:band-width",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='pub-type:band-width', is_config=False)""",
        })

    self.__bandwidth = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bandwidth(self):
    self.__bandwidth = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='pub-type:band-width', is_config=False)


  def _get_ipv4_status(self):
    """
    Getter method for ipv4_status, mapped from YANG variable /ifm/interfaces/interface/dynamic/ipv4_status (port-status)

    YANG Description: IPv4 Protocol status of an interface.
    """
    return self.__ipv4_status
      
  def _set_ipv4_status(self, v, load=False):
    """
    Setter method for ipv4_status, mapped from YANG variable /ifm/interfaces/interface/dynamic/ipv4_status (port-status)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv4_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv4_status() directly.

    YANG Description: IPv4 Protocol status of an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'down': {'value': 0}, 'up': {'value': 1}},), is_leaf=True, yang_name="ipv4-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='port-status', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv4_status must be of a type compatible with port-status""",
          'defined-type': "huawei-ifm:port-status",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'down': {'value': 0}, 'up': {'value': 1}},), is_leaf=True, yang_name="ipv4-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='port-status', is_config=False)""",
        })

    self.__ipv4_status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv4_status(self):
    self.__ipv4_status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'down': {'value': 0}, 'up': {'value': 1}},), is_leaf=True, yang_name="ipv4-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='port-status', is_config=False)


  def _get_ipv6_status(self):
    """
    Getter method for ipv6_status, mapped from YANG variable /ifm/interfaces/interface/dynamic/ipv6_status (port-status)

    YANG Description: IPv6 protocol status of an interface.
    """
    return self.__ipv6_status
      
  def _set_ipv6_status(self, v, load=False):
    """
    Setter method for ipv6_status, mapped from YANG variable /ifm/interfaces/interface/dynamic/ipv6_status (port-status)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv6_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv6_status() directly.

    YANG Description: IPv6 protocol status of an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'down': {'value': 0}, 'up': {'value': 1}},), is_leaf=True, yang_name="ipv6-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='port-status', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv6_status must be of a type compatible with port-status""",
          'defined-type': "huawei-ifm:port-status",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'down': {'value': 0}, 'up': {'value': 1}},), is_leaf=True, yang_name="ipv6-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='port-status', is_config=False)""",
        })

    self.__ipv6_status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv6_status(self):
    self.__ipv6_status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'down': {'value': 0}, 'up': {'value': 1}},), is_leaf=True, yang_name="ipv6-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='port-status', is_config=False)


  def _get_is_control_flap_damp(self):
    """
    Getter method for is_control_flap_damp, mapped from YANG variable /ifm/interfaces/interface/dynamic/is_control_flap_damp (boolean)

    YANG Description: Status suppression of an interface.
    """
    return self.__is_control_flap_damp
      
  def _set_is_control_flap_damp(self, v, load=False):
    """
    Setter method for is_control_flap_damp, mapped from YANG variable /ifm/interfaces/interface/dynamic/is_control_flap_damp (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_is_control_flap_damp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_is_control_flap_damp() directly.

    YANG Description: Status suppression of an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="is-control-flap-damp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """is_control_flap_damp must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is-control-flap-damp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=False)""",
        })

    self.__is_control_flap_damp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_is_control_flap_damp(self):
    self.__is_control_flap_damp = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is-control-flap-damp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=False)


  def _get_mac_address(self):
    """
    Getter method for mac_address, mapped from YANG variable /ifm/interfaces/interface/dynamic/mac_address (pub-type:mac-address)

    YANG Description: MAC address of an interface.
    """
    return self.__mac_address
      
  def _set_mac_address(self, v, load=False):
    """
    Setter method for mac_address, mapped from YANG variable /ifm/interfaces/interface/dynamic/mac_address (pub-type:mac-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mac_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mac_address() directly.

    YANG Description: MAC address of an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9a-f]{4}(-[0-9a-f]{4}){2}', 'length': ['0..255']}), restriction_dict={'length': ['1..14']}), is_leaf=True, yang_name="mac-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='pub-type:mac-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mac_address must be of a type compatible with pub-type:mac-address""",
          'defined-type': "pub-type:mac-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9a-f]{4}(-[0-9a-f]{4}){2}', 'length': ['0..255']}), restriction_dict={'length': ['1..14']}), is_leaf=True, yang_name="mac-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='pub-type:mac-address', is_config=False)""",
        })

    self.__mac_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mac_address(self):
    self.__mac_address = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9a-f]{4}(-[0-9a-f]{4}){2}', 'length': ['0..255']}), restriction_dict={'length': ['1..14']}), is_leaf=True, yang_name="mac-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='pub-type:mac-address', is_config=False)


  def _get_line_protocol_up_time(self):
    """
    Getter method for line_protocol_up_time, mapped from YANG variable /ifm/interfaces/interface/dynamic/line_protocol_up_time (yang:date-and-time)

    YANG Description: Last line protocol up time.
    """
    return self.__line_protocol_up_time
      
  def _set_line_protocol_up_time(self, v, load=False):
    """
    Setter method for line_protocol_up_time, mapped from YANG variable /ifm/interfaces/interface/dynamic/line_protocol_up_time (yang:date-and-time)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_line_protocol_up_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_line_protocol_up_time() directly.

    YANG Description: Last line protocol up time.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="line-protocol-up-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='yang:date-and-time', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """line_protocol_up_time must be of a type compatible with yang:date-and-time""",
          'defined-type': "yang:date-and-time",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="line-protocol-up-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='yang:date-and-time', is_config=False)""",
        })

    self.__line_protocol_up_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_line_protocol_up_time(self):
    self.__line_protocol_up_time = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="line-protocol-up-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='yang:date-and-time', is_config=False)


  def _get_is_offline(self):
    """
    Getter method for is_offline, mapped from YANG variable /ifm/interfaces/interface/dynamic/is_offline (boolean)

    YANG Description: Whether an interface is offline.
    """
    return self.__is_offline
      
  def _set_is_offline(self, v, load=False):
    """
    Setter method for is_offline, mapped from YANG variable /ifm/interfaces/interface/dynamic/is_offline (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_is_offline is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_is_offline() directly.

    YANG Description: Whether an interface is offline.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="is-offline", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """is_offline must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is-offline", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=False)""",
        })

    self.__is_offline = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_is_offline(self):
    self.__is_offline = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is-offline", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=False)


  def _get_link_quality_grade(self):
    """
    Getter method for link_quality_grade, mapped from YANG variable /ifm/interfaces/interface/dynamic/link_quality_grade (link-quality-grade-type)

    YANG Description: Interface link quality grade.
    """
    return self.__link_quality_grade
      
  def _set_link_quality_grade(self, v, load=False):
    """
    Setter method for link_quality_grade, mapped from YANG variable /ifm/interfaces/interface/dynamic/link_quality_grade (link-quality-grade-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_link_quality_grade is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_link_quality_grade() directly.

    YANG Description: Interface link quality grade.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'good': {'value': 0}, 'high': {'value': 1}, 'middle': {'value': 2}, 'low': {'value': 4}},), is_leaf=True, yang_name="link-quality-grade", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='link-quality-grade-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """link_quality_grade must be of a type compatible with link-quality-grade-type""",
          'defined-type': "huawei-ifm:link-quality-grade-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'good': {'value': 0}, 'high': {'value': 1}, 'middle': {'value': 2}, 'low': {'value': 4}},), is_leaf=True, yang_name="link-quality-grade", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='link-quality-grade-type', is_config=False)""",
        })

    self.__link_quality_grade = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_link_quality_grade(self):
    self.__link_quality_grade = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'good': {'value': 0}, 'high': {'value': 1}, 'middle': {'value': 2}, 'low': {'value': 4}},), is_leaf=True, yang_name="link-quality-grade", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='link-quality-grade-type', is_config=False)


  def _get_sub_if_counts(self):
    """
    Getter method for sub_if_counts, mapped from YANG variable /ifm/interfaces/interface/dynamic/sub_if_counts (uint32)

    YANG Description: Number of sub-interfaces on this interface.
    """
    return self.__sub_if_counts
      
  def _set_sub_if_counts(self, v, load=False):
    """
    Setter method for sub_if_counts, mapped from YANG variable /ifm/interfaces/interface/dynamic/sub_if_counts (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_sub_if_counts is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_sub_if_counts() directly.

    YANG Description: Number of sub-interfaces on this interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="sub-if-counts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """sub_if_counts must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="sub-if-counts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)""",
        })

    self.__sub_if_counts = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_sub_if_counts(self):
    self.__sub_if_counts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="sub-if-counts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)

  oper_status = __builtin__.property(_get_oper_status)
  physical_status = __builtin__.property(_get_physical_status)
  link_status = __builtin__.property(_get_link_status)
  mtu = __builtin__.property(_get_mtu)
  bandwidth = __builtin__.property(_get_bandwidth)
  ipv4_status = __builtin__.property(_get_ipv4_status)
  ipv6_status = __builtin__.property(_get_ipv6_status)
  is_control_flap_damp = __builtin__.property(_get_is_control_flap_damp)
  mac_address = __builtin__.property(_get_mac_address)
  line_protocol_up_time = __builtin__.property(_get_line_protocol_up_time)
  is_offline = __builtin__.property(_get_is_offline)
  link_quality_grade = __builtin__.property(_get_link_quality_grade)
  sub_if_counts = __builtin__.property(_get_sub_if_counts)


  _pyangbind_elements = OrderedDict([('oper_status', oper_status), ('physical_status', physical_status), ('link_status', link_status), ('mtu', mtu), ('bandwidth', bandwidth), ('ipv4_status', ipv4_status), ('ipv6_status', ipv6_status), ('is_control_flap_damp', is_control_flap_damp), ('mac_address', mac_address), ('line_protocol_up_time', line_protocol_up_time), ('is_offline', is_offline), ('link_quality_grade', link_quality_grade), ('sub_if_counts', sub_if_counts), ])


class yc_mib_statistics_huawei_ifm__ifm_interfaces_interface_mib_statistics(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-ifm - based on the path /ifm/interfaces/interface/mib-statistics. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Interface statistics.
  """
  __slots__ = ('_path_helper', '_extmethods', '__receive_byte','__send_byte','__receive_packet','__send_packet','__receive_unicast_packet','__receive_multicast_packet','__receive_broad_packet','__send_unicast_packet','__send_multicast_packet','__send_broad_packet','__receive_error_packet','__receive_drop_packet','__send_error_packet','__send_drop_packet',)

  _yang_name = 'mib-statistics'
  _yang_namespace = 'urn:huawei:yang:huawei-ifm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__receive_byte = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-byte", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    self.__send_byte = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-byte", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    self.__receive_packet = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    self.__send_packet = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    self.__receive_unicast_packet = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-unicast-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    self.__receive_multicast_packet = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-multicast-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    self.__receive_broad_packet = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-broad-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    self.__send_unicast_packet = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-unicast-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    self.__send_multicast_packet = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-multicast-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    self.__send_broad_packet = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-broad-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    self.__receive_error_packet = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-error-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    self.__receive_drop_packet = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-drop-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    self.__send_error_packet = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-error-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    self.__send_drop_packet = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-drop-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ifm', 'interfaces', 'interface', 'mib-statistics']

  def _get_receive_byte(self):
    """
    Getter method for receive_byte, mapped from YANG variable /ifm/interfaces/interface/mib_statistics/receive_byte (uint64)

    YANG Description: Number of bytes received on an interface.
    """
    return self.__receive_byte
      
  def _set_receive_byte(self, v, load=False):
    """
    Setter method for receive_byte, mapped from YANG variable /ifm/interfaces/interface/mib_statistics/receive_byte (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_receive_byte is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_receive_byte() directly.

    YANG Description: Number of bytes received on an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-byte", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """receive_byte must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-byte", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__receive_byte = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_receive_byte(self):
    self.__receive_byte = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-byte", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)


  def _get_send_byte(self):
    """
    Getter method for send_byte, mapped from YANG variable /ifm/interfaces/interface/mib_statistics/send_byte (uint64)

    YANG Description: Number of bytes sent on an interface.
    """
    return self.__send_byte
      
  def _set_send_byte(self, v, load=False):
    """
    Setter method for send_byte, mapped from YANG variable /ifm/interfaces/interface/mib_statistics/send_byte (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_send_byte is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_send_byte() directly.

    YANG Description: Number of bytes sent on an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-byte", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """send_byte must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-byte", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__send_byte = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_send_byte(self):
    self.__send_byte = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-byte", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)


  def _get_receive_packet(self):
    """
    Getter method for receive_packet, mapped from YANG variable /ifm/interfaces/interface/mib_statistics/receive_packet (uint64)

    YANG Description: Number of packets received on an interface.
    """
    return self.__receive_packet
      
  def _set_receive_packet(self, v, load=False):
    """
    Setter method for receive_packet, mapped from YANG variable /ifm/interfaces/interface/mib_statistics/receive_packet (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_receive_packet is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_receive_packet() directly.

    YANG Description: Number of packets received on an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """receive_packet must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__receive_packet = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_receive_packet(self):
    self.__receive_packet = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)


  def _get_send_packet(self):
    """
    Getter method for send_packet, mapped from YANG variable /ifm/interfaces/interface/mib_statistics/send_packet (uint64)

    YANG Description: Number of packets sent on an interface.
    """
    return self.__send_packet
      
  def _set_send_packet(self, v, load=False):
    """
    Setter method for send_packet, mapped from YANG variable /ifm/interfaces/interface/mib_statistics/send_packet (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_send_packet is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_send_packet() directly.

    YANG Description: Number of packets sent on an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """send_packet must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__send_packet = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_send_packet(self):
    self.__send_packet = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)


  def _get_receive_unicast_packet(self):
    """
    Getter method for receive_unicast_packet, mapped from YANG variable /ifm/interfaces/interface/mib_statistics/receive_unicast_packet (uint64)

    YANG Description: Number of unicast packets received on an interface.
    """
    return self.__receive_unicast_packet
      
  def _set_receive_unicast_packet(self, v, load=False):
    """
    Setter method for receive_unicast_packet, mapped from YANG variable /ifm/interfaces/interface/mib_statistics/receive_unicast_packet (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_receive_unicast_packet is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_receive_unicast_packet() directly.

    YANG Description: Number of unicast packets received on an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-unicast-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """receive_unicast_packet must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-unicast-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__receive_unicast_packet = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_receive_unicast_packet(self):
    self.__receive_unicast_packet = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-unicast-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)


  def _get_receive_multicast_packet(self):
    """
    Getter method for receive_multicast_packet, mapped from YANG variable /ifm/interfaces/interface/mib_statistics/receive_multicast_packet (uint64)

    YANG Description: Number of multicast packets received on an interface.
    """
    return self.__receive_multicast_packet
      
  def _set_receive_multicast_packet(self, v, load=False):
    """
    Setter method for receive_multicast_packet, mapped from YANG variable /ifm/interfaces/interface/mib_statistics/receive_multicast_packet (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_receive_multicast_packet is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_receive_multicast_packet() directly.

    YANG Description: Number of multicast packets received on an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-multicast-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """receive_multicast_packet must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-multicast-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__receive_multicast_packet = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_receive_multicast_packet(self):
    self.__receive_multicast_packet = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-multicast-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)


  def _get_receive_broad_packet(self):
    """
    Getter method for receive_broad_packet, mapped from YANG variable /ifm/interfaces/interface/mib_statistics/receive_broad_packet (uint64)

    YANG Description: Number of broadcast packets received on an interface.
    """
    return self.__receive_broad_packet
      
  def _set_receive_broad_packet(self, v, load=False):
    """
    Setter method for receive_broad_packet, mapped from YANG variable /ifm/interfaces/interface/mib_statistics/receive_broad_packet (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_receive_broad_packet is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_receive_broad_packet() directly.

    YANG Description: Number of broadcast packets received on an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-broad-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """receive_broad_packet must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-broad-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__receive_broad_packet = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_receive_broad_packet(self):
    self.__receive_broad_packet = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-broad-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)


  def _get_send_unicast_packet(self):
    """
    Getter method for send_unicast_packet, mapped from YANG variable /ifm/interfaces/interface/mib_statistics/send_unicast_packet (uint64)

    YANG Description: Number of unicast packets sent on an interface.
    """
    return self.__send_unicast_packet
      
  def _set_send_unicast_packet(self, v, load=False):
    """
    Setter method for send_unicast_packet, mapped from YANG variable /ifm/interfaces/interface/mib_statistics/send_unicast_packet (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_send_unicast_packet is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_send_unicast_packet() directly.

    YANG Description: Number of unicast packets sent on an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-unicast-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """send_unicast_packet must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-unicast-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__send_unicast_packet = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_send_unicast_packet(self):
    self.__send_unicast_packet = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-unicast-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)


  def _get_send_multicast_packet(self):
    """
    Getter method for send_multicast_packet, mapped from YANG variable /ifm/interfaces/interface/mib_statistics/send_multicast_packet (uint64)

    YANG Description: Number of multicast packets sent on an interface.
    """
    return self.__send_multicast_packet
      
  def _set_send_multicast_packet(self, v, load=False):
    """
    Setter method for send_multicast_packet, mapped from YANG variable /ifm/interfaces/interface/mib_statistics/send_multicast_packet (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_send_multicast_packet is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_send_multicast_packet() directly.

    YANG Description: Number of multicast packets sent on an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-multicast-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """send_multicast_packet must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-multicast-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__send_multicast_packet = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_send_multicast_packet(self):
    self.__send_multicast_packet = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-multicast-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)


  def _get_send_broad_packet(self):
    """
    Getter method for send_broad_packet, mapped from YANG variable /ifm/interfaces/interface/mib_statistics/send_broad_packet (uint64)

    YANG Description: Number of broadcast packets sent on an interface.
    """
    return self.__send_broad_packet
      
  def _set_send_broad_packet(self, v, load=False):
    """
    Setter method for send_broad_packet, mapped from YANG variable /ifm/interfaces/interface/mib_statistics/send_broad_packet (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_send_broad_packet is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_send_broad_packet() directly.

    YANG Description: Number of broadcast packets sent on an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-broad-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """send_broad_packet must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-broad-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__send_broad_packet = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_send_broad_packet(self):
    self.__send_broad_packet = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-broad-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)


  def _get_receive_error_packet(self):
    """
    Getter method for receive_error_packet, mapped from YANG variable /ifm/interfaces/interface/mib_statistics/receive_error_packet (uint64)

    YANG Description: Number of error packets received on an interface.
    """
    return self.__receive_error_packet
      
  def _set_receive_error_packet(self, v, load=False):
    """
    Setter method for receive_error_packet, mapped from YANG variable /ifm/interfaces/interface/mib_statistics/receive_error_packet (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_receive_error_packet is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_receive_error_packet() directly.

    YANG Description: Number of error packets received on an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-error-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """receive_error_packet must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-error-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__receive_error_packet = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_receive_error_packet(self):
    self.__receive_error_packet = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-error-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)


  def _get_receive_drop_packet(self):
    """
    Getter method for receive_drop_packet, mapped from YANG variable /ifm/interfaces/interface/mib_statistics/receive_drop_packet (uint64)

    YANG Description: Number of received packets discarded on an interface.
    """
    return self.__receive_drop_packet
      
  def _set_receive_drop_packet(self, v, load=False):
    """
    Setter method for receive_drop_packet, mapped from YANG variable /ifm/interfaces/interface/mib_statistics/receive_drop_packet (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_receive_drop_packet is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_receive_drop_packet() directly.

    YANG Description: Number of received packets discarded on an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-drop-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """receive_drop_packet must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-drop-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__receive_drop_packet = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_receive_drop_packet(self):
    self.__receive_drop_packet = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-drop-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)


  def _get_send_error_packet(self):
    """
    Getter method for send_error_packet, mapped from YANG variable /ifm/interfaces/interface/mib_statistics/send_error_packet (uint64)

    YANG Description: Number of error packets sent on an interface.
    """
    return self.__send_error_packet
      
  def _set_send_error_packet(self, v, load=False):
    """
    Setter method for send_error_packet, mapped from YANG variable /ifm/interfaces/interface/mib_statistics/send_error_packet (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_send_error_packet is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_send_error_packet() directly.

    YANG Description: Number of error packets sent on an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-error-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """send_error_packet must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-error-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__send_error_packet = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_send_error_packet(self):
    self.__send_error_packet = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-error-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)


  def _get_send_drop_packet(self):
    """
    Getter method for send_drop_packet, mapped from YANG variable /ifm/interfaces/interface/mib_statistics/send_drop_packet (uint64)

    YANG Description: Number of sent packets discarded on an interface.
    """
    return self.__send_drop_packet
      
  def _set_send_drop_packet(self, v, load=False):
    """
    Setter method for send_drop_packet, mapped from YANG variable /ifm/interfaces/interface/mib_statistics/send_drop_packet (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_send_drop_packet is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_send_drop_packet() directly.

    YANG Description: Number of sent packets discarded on an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-drop-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """send_drop_packet must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-drop-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__send_drop_packet = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_send_drop_packet(self):
    self.__send_drop_packet = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-drop-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)

  receive_byte = __builtin__.property(_get_receive_byte)
  send_byte = __builtin__.property(_get_send_byte)
  receive_packet = __builtin__.property(_get_receive_packet)
  send_packet = __builtin__.property(_get_send_packet)
  receive_unicast_packet = __builtin__.property(_get_receive_unicast_packet)
  receive_multicast_packet = __builtin__.property(_get_receive_multicast_packet)
  receive_broad_packet = __builtin__.property(_get_receive_broad_packet)
  send_unicast_packet = __builtin__.property(_get_send_unicast_packet)
  send_multicast_packet = __builtin__.property(_get_send_multicast_packet)
  send_broad_packet = __builtin__.property(_get_send_broad_packet)
  receive_error_packet = __builtin__.property(_get_receive_error_packet)
  receive_drop_packet = __builtin__.property(_get_receive_drop_packet)
  send_error_packet = __builtin__.property(_get_send_error_packet)
  send_drop_packet = __builtin__.property(_get_send_drop_packet)


  _pyangbind_elements = OrderedDict([('receive_byte', receive_byte), ('send_byte', send_byte), ('receive_packet', receive_packet), ('send_packet', send_packet), ('receive_unicast_packet', receive_unicast_packet), ('receive_multicast_packet', receive_multicast_packet), ('receive_broad_packet', receive_broad_packet), ('send_unicast_packet', send_unicast_packet), ('send_multicast_packet', send_multicast_packet), ('send_broad_packet', send_broad_packet), ('receive_error_packet', receive_error_packet), ('receive_drop_packet', receive_drop_packet), ('send_error_packet', send_error_packet), ('send_drop_packet', send_drop_packet), ])


class yc_common_statistics_huawei_ifm__ifm_interfaces_interface_common_statistics(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-ifm - based on the path /ifm/interfaces/interface/common-statistics. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Interface statistics.
  """
  __slots__ = ('_path_helper', '_extmethods', '__stati_interval','__in_byte_rate','__in_bit_rate','__in_packet_rate','__in_use_rate','__out_byte_rate','__out_bit_rate','__out_packet_rate','__out_use_rate','__receive_byte','__send_byte','__receive_packet','__send_packet','__receive_unicast_packet','__receive_multicast_packet','__receive_broad_packet','__send_unicast_packet','__send_multicast_packet','__send_broad_packet','__receive_error_packet','__receive_drop_packet','__send_error_packet','__send_drop_packet','__send_unicast_bit','__receive_unicast_bit','__send_multicast_bit','__receive_multicast_bit','__send_broad_bit','__receive_broad_bit','__send_unicast_bit_rate','__receive_unicast_bit_rate','__send_multicast_bit_rate','__receive_multicast_bit_rate','__send_broad_bit_rate','__receive_broad_bit_rate','__send_unicast_packet_rate','__receive_unicast_packet_rate','__send_multicast_packet_rate','__receive_multicast_packet_rate','__send_broadcast_packet_rate','__receive_broadcast_packet_rate',)

  _yang_name = 'common-statistics'
  _yang_namespace = 'urn:huawei:yang:huawei-ifm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__stati_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['10..600']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(300), is_leaf=True, yang_name="stati-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)
    self.__in_byte_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-byte-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    self.__in_bit_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-bit-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    self.__in_packet_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-packet-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    self.__in_use_rate = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..50']}), is_leaf=True, yang_name="in-use-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='string', is_config=False)
    self.__out_byte_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-byte-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    self.__out_bit_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-bit-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    self.__out_packet_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-packet-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    self.__out_use_rate = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..50']}), is_leaf=True, yang_name="out-use-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='string', is_config=False)
    self.__receive_byte = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-byte", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    self.__send_byte = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-byte", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    self.__receive_packet = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    self.__send_packet = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    self.__receive_unicast_packet = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-unicast-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    self.__receive_multicast_packet = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-multicast-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    self.__receive_broad_packet = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-broad-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    self.__send_unicast_packet = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-unicast-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    self.__send_multicast_packet = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-multicast-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    self.__send_broad_packet = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-broad-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    self.__receive_error_packet = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-error-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    self.__receive_drop_packet = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-drop-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    self.__send_error_packet = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-error-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    self.__send_drop_packet = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-drop-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    self.__send_unicast_bit = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-unicast-bit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    self.__receive_unicast_bit = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-unicast-bit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    self.__send_multicast_bit = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-multicast-bit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    self.__receive_multicast_bit = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-multicast-bit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    self.__send_broad_bit = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-broad-bit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    self.__receive_broad_bit = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-broad-bit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    self.__send_unicast_bit_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-unicast-bit-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    self.__receive_unicast_bit_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-unicast-bit-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    self.__send_multicast_bit_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-multicast-bit-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    self.__receive_multicast_bit_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-multicast-bit-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    self.__send_broad_bit_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-broad-bit-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    self.__receive_broad_bit_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-broad-bit-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    self.__send_unicast_packet_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-unicast-packet-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    self.__receive_unicast_packet_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-unicast-packet-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    self.__send_multicast_packet_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-multicast-packet-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    self.__receive_multicast_packet_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-multicast-packet-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    self.__send_broadcast_packet_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-broadcast-packet-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    self.__receive_broadcast_packet_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-broadcast-packet-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ifm', 'interfaces', 'interface', 'common-statistics']

  def _get_stati_interval(self):
    """
    Getter method for stati_interval, mapped from YANG variable /ifm/interfaces/interface/common_statistics/stati_interval (uint32)

    YANG Description: Current interval at which interface flow statistics are collected.
    """
    return self.__stati_interval
      
  def _set_stati_interval(self, v, load=False):
    """
    Setter method for stati_interval, mapped from YANG variable /ifm/interfaces/interface/common_statistics/stati_interval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_stati_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_stati_interval() directly.

    YANG Description: Current interval at which interface flow statistics are collected.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['10..600']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(300), is_leaf=True, yang_name="stati-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """stati_interval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['10..600']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(300), is_leaf=True, yang_name="stati-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)""",
        })

    self.__stati_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_stati_interval(self):
    self.__stati_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['10..600']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(300), is_leaf=True, yang_name="stati-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)


  def _get_in_byte_rate(self):
    """
    Getter method for in_byte_rate, mapped from YANG variable /ifm/interfaces/interface/common_statistics/in_byte_rate (uint64)

    YANG Description: Rate at which bytes are received within the interval.
    """
    return self.__in_byte_rate
      
  def _set_in_byte_rate(self, v, load=False):
    """
    Setter method for in_byte_rate, mapped from YANG variable /ifm/interfaces/interface/common_statistics/in_byte_rate (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_byte_rate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_byte_rate() directly.

    YANG Description: Rate at which bytes are received within the interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-byte-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_byte_rate must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-byte-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__in_byte_rate = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_byte_rate(self):
    self.__in_byte_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-byte-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)


  def _get_in_bit_rate(self):
    """
    Getter method for in_bit_rate, mapped from YANG variable /ifm/interfaces/interface/common_statistics/in_bit_rate (uint64)

    YANG Description: Rate at which bits are received within the interval.
    """
    return self.__in_bit_rate
      
  def _set_in_bit_rate(self, v, load=False):
    """
    Setter method for in_bit_rate, mapped from YANG variable /ifm/interfaces/interface/common_statistics/in_bit_rate (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_bit_rate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_bit_rate() directly.

    YANG Description: Rate at which bits are received within the interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-bit-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_bit_rate must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-bit-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__in_bit_rate = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_bit_rate(self):
    self.__in_bit_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-bit-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)


  def _get_in_packet_rate(self):
    """
    Getter method for in_packet_rate, mapped from YANG variable /ifm/interfaces/interface/common_statistics/in_packet_rate (uint64)

    YANG Description: Rate at which packets are received within the interval.
    """
    return self.__in_packet_rate
      
  def _set_in_packet_rate(self, v, load=False):
    """
    Setter method for in_packet_rate, mapped from YANG variable /ifm/interfaces/interface/common_statistics/in_packet_rate (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_packet_rate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_packet_rate() directly.

    YANG Description: Rate at which packets are received within the interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-packet-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_packet_rate must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-packet-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__in_packet_rate = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_packet_rate(self):
    self.__in_packet_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-packet-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)


  def _get_in_use_rate(self):
    """
    Getter method for in_use_rate, mapped from YANG variable /ifm/interfaces/interface/common_statistics/in_use_rate (string)

    YANG Description: Input bandwidth usage within the interval.
    """
    return self.__in_use_rate
      
  def _set_in_use_rate(self, v, load=False):
    """
    Setter method for in_use_rate, mapped from YANG variable /ifm/interfaces/interface/common_statistics/in_use_rate (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_use_rate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_use_rate() directly.

    YANG Description: Input bandwidth usage within the interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..50']}), is_leaf=True, yang_name="in-use-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_use_rate must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..50']}), is_leaf=True, yang_name="in-use-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='string', is_config=False)""",
        })

    self.__in_use_rate = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_use_rate(self):
    self.__in_use_rate = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..50']}), is_leaf=True, yang_name="in-use-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='string', is_config=False)


  def _get_out_byte_rate(self):
    """
    Getter method for out_byte_rate, mapped from YANG variable /ifm/interfaces/interface/common_statistics/out_byte_rate (uint64)

    YANG Description: Rate at which bytes are sent within the interval.
    """
    return self.__out_byte_rate
      
  def _set_out_byte_rate(self, v, load=False):
    """
    Setter method for out_byte_rate, mapped from YANG variable /ifm/interfaces/interface/common_statistics/out_byte_rate (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_byte_rate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_byte_rate() directly.

    YANG Description: Rate at which bytes are sent within the interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-byte-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_byte_rate must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-byte-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__out_byte_rate = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_byte_rate(self):
    self.__out_byte_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-byte-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)


  def _get_out_bit_rate(self):
    """
    Getter method for out_bit_rate, mapped from YANG variable /ifm/interfaces/interface/common_statistics/out_bit_rate (uint64)

    YANG Description: Rate at which bits are sent within the interval.
    """
    return self.__out_bit_rate
      
  def _set_out_bit_rate(self, v, load=False):
    """
    Setter method for out_bit_rate, mapped from YANG variable /ifm/interfaces/interface/common_statistics/out_bit_rate (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_bit_rate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_bit_rate() directly.

    YANG Description: Rate at which bits are sent within the interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-bit-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_bit_rate must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-bit-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__out_bit_rate = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_bit_rate(self):
    self.__out_bit_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-bit-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)


  def _get_out_packet_rate(self):
    """
    Getter method for out_packet_rate, mapped from YANG variable /ifm/interfaces/interface/common_statistics/out_packet_rate (uint64)

    YANG Description: Rate at which packets are sent within the interval.
    """
    return self.__out_packet_rate
      
  def _set_out_packet_rate(self, v, load=False):
    """
    Setter method for out_packet_rate, mapped from YANG variable /ifm/interfaces/interface/common_statistics/out_packet_rate (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_packet_rate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_packet_rate() directly.

    YANG Description: Rate at which packets are sent within the interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-packet-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_packet_rate must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-packet-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__out_packet_rate = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_packet_rate(self):
    self.__out_packet_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-packet-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)


  def _get_out_use_rate(self):
    """
    Getter method for out_use_rate, mapped from YANG variable /ifm/interfaces/interface/common_statistics/out_use_rate (string)

    YANG Description: Output bandwidth usage within the interval.
    """
    return self.__out_use_rate
      
  def _set_out_use_rate(self, v, load=False):
    """
    Setter method for out_use_rate, mapped from YANG variable /ifm/interfaces/interface/common_statistics/out_use_rate (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_use_rate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_use_rate() directly.

    YANG Description: Output bandwidth usage within the interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..50']}), is_leaf=True, yang_name="out-use-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_use_rate must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..50']}), is_leaf=True, yang_name="out-use-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='string', is_config=False)""",
        })

    self.__out_use_rate = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_use_rate(self):
    self.__out_use_rate = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..50']}), is_leaf=True, yang_name="out-use-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='string', is_config=False)


  def _get_receive_byte(self):
    """
    Getter method for receive_byte, mapped from YANG variable /ifm/interfaces/interface/common_statistics/receive_byte (uint64)

    YANG Description: Number of received bytes, which can be cleared.
    """
    return self.__receive_byte
      
  def _set_receive_byte(self, v, load=False):
    """
    Setter method for receive_byte, mapped from YANG variable /ifm/interfaces/interface/common_statistics/receive_byte (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_receive_byte is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_receive_byte() directly.

    YANG Description: Number of received bytes, which can be cleared.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-byte", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """receive_byte must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-byte", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__receive_byte = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_receive_byte(self):
    self.__receive_byte = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-byte", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)


  def _get_send_byte(self):
    """
    Getter method for send_byte, mapped from YANG variable /ifm/interfaces/interface/common_statistics/send_byte (uint64)

    YANG Description: Number of sent bytes, which can be cleared.
    """
    return self.__send_byte
      
  def _set_send_byte(self, v, load=False):
    """
    Setter method for send_byte, mapped from YANG variable /ifm/interfaces/interface/common_statistics/send_byte (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_send_byte is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_send_byte() directly.

    YANG Description: Number of sent bytes, which can be cleared.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-byte", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """send_byte must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-byte", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__send_byte = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_send_byte(self):
    self.__send_byte = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-byte", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)


  def _get_receive_packet(self):
    """
    Getter method for receive_packet, mapped from YANG variable /ifm/interfaces/interface/common_statistics/receive_packet (uint64)

    YANG Description: Number of received packets, which can be cleared.
    """
    return self.__receive_packet
      
  def _set_receive_packet(self, v, load=False):
    """
    Setter method for receive_packet, mapped from YANG variable /ifm/interfaces/interface/common_statistics/receive_packet (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_receive_packet is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_receive_packet() directly.

    YANG Description: Number of received packets, which can be cleared.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """receive_packet must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__receive_packet = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_receive_packet(self):
    self.__receive_packet = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)


  def _get_send_packet(self):
    """
    Getter method for send_packet, mapped from YANG variable /ifm/interfaces/interface/common_statistics/send_packet (uint64)

    YANG Description: Number of sent packets, which can be cleared.
    """
    return self.__send_packet
      
  def _set_send_packet(self, v, load=False):
    """
    Setter method for send_packet, mapped from YANG variable /ifm/interfaces/interface/common_statistics/send_packet (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_send_packet is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_send_packet() directly.

    YANG Description: Number of sent packets, which can be cleared.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """send_packet must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__send_packet = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_send_packet(self):
    self.__send_packet = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)


  def _get_receive_unicast_packet(self):
    """
    Getter method for receive_unicast_packet, mapped from YANG variable /ifm/interfaces/interface/common_statistics/receive_unicast_packet (uint64)

    YANG Description: Number of received unicast packets, which can be cleared.
    """
    return self.__receive_unicast_packet
      
  def _set_receive_unicast_packet(self, v, load=False):
    """
    Setter method for receive_unicast_packet, mapped from YANG variable /ifm/interfaces/interface/common_statistics/receive_unicast_packet (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_receive_unicast_packet is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_receive_unicast_packet() directly.

    YANG Description: Number of received unicast packets, which can be cleared.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-unicast-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """receive_unicast_packet must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-unicast-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__receive_unicast_packet = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_receive_unicast_packet(self):
    self.__receive_unicast_packet = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-unicast-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)


  def _get_receive_multicast_packet(self):
    """
    Getter method for receive_multicast_packet, mapped from YANG variable /ifm/interfaces/interface/common_statistics/receive_multicast_packet (uint64)

    YANG Description: Number of received multicast packets, which can be cleared.
    """
    return self.__receive_multicast_packet
      
  def _set_receive_multicast_packet(self, v, load=False):
    """
    Setter method for receive_multicast_packet, mapped from YANG variable /ifm/interfaces/interface/common_statistics/receive_multicast_packet (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_receive_multicast_packet is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_receive_multicast_packet() directly.

    YANG Description: Number of received multicast packets, which can be cleared.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-multicast-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """receive_multicast_packet must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-multicast-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__receive_multicast_packet = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_receive_multicast_packet(self):
    self.__receive_multicast_packet = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-multicast-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)


  def _get_receive_broad_packet(self):
    """
    Getter method for receive_broad_packet, mapped from YANG variable /ifm/interfaces/interface/common_statistics/receive_broad_packet (uint64)

    YANG Description: Number of received broadcast packets, which can be cleared.
    """
    return self.__receive_broad_packet
      
  def _set_receive_broad_packet(self, v, load=False):
    """
    Setter method for receive_broad_packet, mapped from YANG variable /ifm/interfaces/interface/common_statistics/receive_broad_packet (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_receive_broad_packet is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_receive_broad_packet() directly.

    YANG Description: Number of received broadcast packets, which can be cleared.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-broad-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """receive_broad_packet must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-broad-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__receive_broad_packet = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_receive_broad_packet(self):
    self.__receive_broad_packet = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-broad-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)


  def _get_send_unicast_packet(self):
    """
    Getter method for send_unicast_packet, mapped from YANG variable /ifm/interfaces/interface/common_statistics/send_unicast_packet (uint64)

    YANG Description: Number of sent unicast packets, which can be cleared.
    """
    return self.__send_unicast_packet
      
  def _set_send_unicast_packet(self, v, load=False):
    """
    Setter method for send_unicast_packet, mapped from YANG variable /ifm/interfaces/interface/common_statistics/send_unicast_packet (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_send_unicast_packet is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_send_unicast_packet() directly.

    YANG Description: Number of sent unicast packets, which can be cleared.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-unicast-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """send_unicast_packet must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-unicast-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__send_unicast_packet = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_send_unicast_packet(self):
    self.__send_unicast_packet = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-unicast-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)


  def _get_send_multicast_packet(self):
    """
    Getter method for send_multicast_packet, mapped from YANG variable /ifm/interfaces/interface/common_statistics/send_multicast_packet (uint64)

    YANG Description: Number of sent multicast packets, which can be cleared.
    """
    return self.__send_multicast_packet
      
  def _set_send_multicast_packet(self, v, load=False):
    """
    Setter method for send_multicast_packet, mapped from YANG variable /ifm/interfaces/interface/common_statistics/send_multicast_packet (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_send_multicast_packet is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_send_multicast_packet() directly.

    YANG Description: Number of sent multicast packets, which can be cleared.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-multicast-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """send_multicast_packet must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-multicast-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__send_multicast_packet = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_send_multicast_packet(self):
    self.__send_multicast_packet = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-multicast-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)


  def _get_send_broad_packet(self):
    """
    Getter method for send_broad_packet, mapped from YANG variable /ifm/interfaces/interface/common_statistics/send_broad_packet (uint64)

    YANG Description: Number of sent broadcast packets, which can be cleared.
    """
    return self.__send_broad_packet
      
  def _set_send_broad_packet(self, v, load=False):
    """
    Setter method for send_broad_packet, mapped from YANG variable /ifm/interfaces/interface/common_statistics/send_broad_packet (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_send_broad_packet is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_send_broad_packet() directly.

    YANG Description: Number of sent broadcast packets, which can be cleared.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-broad-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """send_broad_packet must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-broad-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__send_broad_packet = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_send_broad_packet(self):
    self.__send_broad_packet = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-broad-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)


  def _get_receive_error_packet(self):
    """
    Getter method for receive_error_packet, mapped from YANG variable /ifm/interfaces/interface/common_statistics/receive_error_packet (uint64)

    YANG Description: Number of received error packets, which can be cleared.
    """
    return self.__receive_error_packet
      
  def _set_receive_error_packet(self, v, load=False):
    """
    Setter method for receive_error_packet, mapped from YANG variable /ifm/interfaces/interface/common_statistics/receive_error_packet (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_receive_error_packet is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_receive_error_packet() directly.

    YANG Description: Number of received error packets, which can be cleared.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-error-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """receive_error_packet must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-error-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__receive_error_packet = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_receive_error_packet(self):
    self.__receive_error_packet = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-error-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)


  def _get_receive_drop_packet(self):
    """
    Getter method for receive_drop_packet, mapped from YANG variable /ifm/interfaces/interface/common_statistics/receive_drop_packet (uint64)

    YANG Description: Number of received discarded packets, which can be cleared.
    """
    return self.__receive_drop_packet
      
  def _set_receive_drop_packet(self, v, load=False):
    """
    Setter method for receive_drop_packet, mapped from YANG variable /ifm/interfaces/interface/common_statistics/receive_drop_packet (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_receive_drop_packet is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_receive_drop_packet() directly.

    YANG Description: Number of received discarded packets, which can be cleared.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-drop-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """receive_drop_packet must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-drop-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__receive_drop_packet = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_receive_drop_packet(self):
    self.__receive_drop_packet = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-drop-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)


  def _get_send_error_packet(self):
    """
    Getter method for send_error_packet, mapped from YANG variable /ifm/interfaces/interface/common_statistics/send_error_packet (uint64)

    YANG Description: Number of sent error packets, which can be cleared.
    """
    return self.__send_error_packet
      
  def _set_send_error_packet(self, v, load=False):
    """
    Setter method for send_error_packet, mapped from YANG variable /ifm/interfaces/interface/common_statistics/send_error_packet (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_send_error_packet is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_send_error_packet() directly.

    YANG Description: Number of sent error packets, which can be cleared.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-error-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """send_error_packet must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-error-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__send_error_packet = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_send_error_packet(self):
    self.__send_error_packet = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-error-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)


  def _get_send_drop_packet(self):
    """
    Getter method for send_drop_packet, mapped from YANG variable /ifm/interfaces/interface/common_statistics/send_drop_packet (uint64)

    YANG Description: Number of sent discarded packets, which can be cleared.
    """
    return self.__send_drop_packet
      
  def _set_send_drop_packet(self, v, load=False):
    """
    Setter method for send_drop_packet, mapped from YANG variable /ifm/interfaces/interface/common_statistics/send_drop_packet (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_send_drop_packet is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_send_drop_packet() directly.

    YANG Description: Number of sent discarded packets, which can be cleared.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-drop-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """send_drop_packet must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-drop-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__send_drop_packet = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_send_drop_packet(self):
    self.__send_drop_packet = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-drop-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)


  def _get_send_unicast_bit(self):
    """
    Getter method for send_unicast_bit, mapped from YANG variable /ifm/interfaces/interface/common_statistics/send_unicast_bit (uint64)

    YANG Description: Number of unicast bits sent on an interface.
    """
    return self.__send_unicast_bit
      
  def _set_send_unicast_bit(self, v, load=False):
    """
    Setter method for send_unicast_bit, mapped from YANG variable /ifm/interfaces/interface/common_statistics/send_unicast_bit (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_send_unicast_bit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_send_unicast_bit() directly.

    YANG Description: Number of unicast bits sent on an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-unicast-bit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """send_unicast_bit must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-unicast-bit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__send_unicast_bit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_send_unicast_bit(self):
    self.__send_unicast_bit = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-unicast-bit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)


  def _get_receive_unicast_bit(self):
    """
    Getter method for receive_unicast_bit, mapped from YANG variable /ifm/interfaces/interface/common_statistics/receive_unicast_bit (uint64)

    YANG Description: Number of unicast bits received on an interface.
    """
    return self.__receive_unicast_bit
      
  def _set_receive_unicast_bit(self, v, load=False):
    """
    Setter method for receive_unicast_bit, mapped from YANG variable /ifm/interfaces/interface/common_statistics/receive_unicast_bit (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_receive_unicast_bit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_receive_unicast_bit() directly.

    YANG Description: Number of unicast bits received on an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-unicast-bit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """receive_unicast_bit must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-unicast-bit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__receive_unicast_bit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_receive_unicast_bit(self):
    self.__receive_unicast_bit = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-unicast-bit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)


  def _get_send_multicast_bit(self):
    """
    Getter method for send_multicast_bit, mapped from YANG variable /ifm/interfaces/interface/common_statistics/send_multicast_bit (uint64)

    YANG Description: Number of multicast bits sent on an interface.
    """
    return self.__send_multicast_bit
      
  def _set_send_multicast_bit(self, v, load=False):
    """
    Setter method for send_multicast_bit, mapped from YANG variable /ifm/interfaces/interface/common_statistics/send_multicast_bit (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_send_multicast_bit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_send_multicast_bit() directly.

    YANG Description: Number of multicast bits sent on an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-multicast-bit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """send_multicast_bit must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-multicast-bit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__send_multicast_bit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_send_multicast_bit(self):
    self.__send_multicast_bit = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-multicast-bit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)


  def _get_receive_multicast_bit(self):
    """
    Getter method for receive_multicast_bit, mapped from YANG variable /ifm/interfaces/interface/common_statistics/receive_multicast_bit (uint64)

    YANG Description: Number of multicast bits received on an interface.
    """
    return self.__receive_multicast_bit
      
  def _set_receive_multicast_bit(self, v, load=False):
    """
    Setter method for receive_multicast_bit, mapped from YANG variable /ifm/interfaces/interface/common_statistics/receive_multicast_bit (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_receive_multicast_bit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_receive_multicast_bit() directly.

    YANG Description: Number of multicast bits received on an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-multicast-bit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """receive_multicast_bit must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-multicast-bit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__receive_multicast_bit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_receive_multicast_bit(self):
    self.__receive_multicast_bit = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-multicast-bit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)


  def _get_send_broad_bit(self):
    """
    Getter method for send_broad_bit, mapped from YANG variable /ifm/interfaces/interface/common_statistics/send_broad_bit (uint64)

    YANG Description: Number of broadcast bits sent on an interface.
    """
    return self.__send_broad_bit
      
  def _set_send_broad_bit(self, v, load=False):
    """
    Setter method for send_broad_bit, mapped from YANG variable /ifm/interfaces/interface/common_statistics/send_broad_bit (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_send_broad_bit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_send_broad_bit() directly.

    YANG Description: Number of broadcast bits sent on an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-broad-bit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """send_broad_bit must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-broad-bit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__send_broad_bit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_send_broad_bit(self):
    self.__send_broad_bit = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-broad-bit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)


  def _get_receive_broad_bit(self):
    """
    Getter method for receive_broad_bit, mapped from YANG variable /ifm/interfaces/interface/common_statistics/receive_broad_bit (uint64)

    YANG Description: Number of broadcast bits received on an interface.
    """
    return self.__receive_broad_bit
      
  def _set_receive_broad_bit(self, v, load=False):
    """
    Setter method for receive_broad_bit, mapped from YANG variable /ifm/interfaces/interface/common_statistics/receive_broad_bit (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_receive_broad_bit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_receive_broad_bit() directly.

    YANG Description: Number of broadcast bits received on an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-broad-bit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """receive_broad_bit must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-broad-bit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__receive_broad_bit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_receive_broad_bit(self):
    self.__receive_broad_bit = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-broad-bit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)


  def _get_send_unicast_bit_rate(self):
    """
    Getter method for send_unicast_bit_rate, mapped from YANG variable /ifm/interfaces/interface/common_statistics/send_unicast_bit_rate (uint64)

    YANG Description: Rate of unicast bits sent on an interface.
    """
    return self.__send_unicast_bit_rate
      
  def _set_send_unicast_bit_rate(self, v, load=False):
    """
    Setter method for send_unicast_bit_rate, mapped from YANG variable /ifm/interfaces/interface/common_statistics/send_unicast_bit_rate (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_send_unicast_bit_rate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_send_unicast_bit_rate() directly.

    YANG Description: Rate of unicast bits sent on an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-unicast-bit-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """send_unicast_bit_rate must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-unicast-bit-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__send_unicast_bit_rate = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_send_unicast_bit_rate(self):
    self.__send_unicast_bit_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-unicast-bit-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)


  def _get_receive_unicast_bit_rate(self):
    """
    Getter method for receive_unicast_bit_rate, mapped from YANG variable /ifm/interfaces/interface/common_statistics/receive_unicast_bit_rate (uint64)

    YANG Description: Rate of unicast bits received on an interface.
    """
    return self.__receive_unicast_bit_rate
      
  def _set_receive_unicast_bit_rate(self, v, load=False):
    """
    Setter method for receive_unicast_bit_rate, mapped from YANG variable /ifm/interfaces/interface/common_statistics/receive_unicast_bit_rate (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_receive_unicast_bit_rate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_receive_unicast_bit_rate() directly.

    YANG Description: Rate of unicast bits received on an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-unicast-bit-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """receive_unicast_bit_rate must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-unicast-bit-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__receive_unicast_bit_rate = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_receive_unicast_bit_rate(self):
    self.__receive_unicast_bit_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-unicast-bit-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)


  def _get_send_multicast_bit_rate(self):
    """
    Getter method for send_multicast_bit_rate, mapped from YANG variable /ifm/interfaces/interface/common_statistics/send_multicast_bit_rate (uint64)

    YANG Description: Rate of multicast bits sent on an interface.
    """
    return self.__send_multicast_bit_rate
      
  def _set_send_multicast_bit_rate(self, v, load=False):
    """
    Setter method for send_multicast_bit_rate, mapped from YANG variable /ifm/interfaces/interface/common_statistics/send_multicast_bit_rate (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_send_multicast_bit_rate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_send_multicast_bit_rate() directly.

    YANG Description: Rate of multicast bits sent on an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-multicast-bit-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """send_multicast_bit_rate must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-multicast-bit-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__send_multicast_bit_rate = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_send_multicast_bit_rate(self):
    self.__send_multicast_bit_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-multicast-bit-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)


  def _get_receive_multicast_bit_rate(self):
    """
    Getter method for receive_multicast_bit_rate, mapped from YANG variable /ifm/interfaces/interface/common_statistics/receive_multicast_bit_rate (uint64)

    YANG Description: Rate of multicast bits received on an interface.
    """
    return self.__receive_multicast_bit_rate
      
  def _set_receive_multicast_bit_rate(self, v, load=False):
    """
    Setter method for receive_multicast_bit_rate, mapped from YANG variable /ifm/interfaces/interface/common_statistics/receive_multicast_bit_rate (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_receive_multicast_bit_rate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_receive_multicast_bit_rate() directly.

    YANG Description: Rate of multicast bits received on an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-multicast-bit-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """receive_multicast_bit_rate must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-multicast-bit-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__receive_multicast_bit_rate = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_receive_multicast_bit_rate(self):
    self.__receive_multicast_bit_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-multicast-bit-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)


  def _get_send_broad_bit_rate(self):
    """
    Getter method for send_broad_bit_rate, mapped from YANG variable /ifm/interfaces/interface/common_statistics/send_broad_bit_rate (uint64)

    YANG Description: Rate of broadcast bits sent on an interface.
    """
    return self.__send_broad_bit_rate
      
  def _set_send_broad_bit_rate(self, v, load=False):
    """
    Setter method for send_broad_bit_rate, mapped from YANG variable /ifm/interfaces/interface/common_statistics/send_broad_bit_rate (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_send_broad_bit_rate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_send_broad_bit_rate() directly.

    YANG Description: Rate of broadcast bits sent on an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-broad-bit-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """send_broad_bit_rate must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-broad-bit-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__send_broad_bit_rate = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_send_broad_bit_rate(self):
    self.__send_broad_bit_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-broad-bit-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)


  def _get_receive_broad_bit_rate(self):
    """
    Getter method for receive_broad_bit_rate, mapped from YANG variable /ifm/interfaces/interface/common_statistics/receive_broad_bit_rate (uint64)

    YANG Description: Rate of broadcast bits received on an interface.
    """
    return self.__receive_broad_bit_rate
      
  def _set_receive_broad_bit_rate(self, v, load=False):
    """
    Setter method for receive_broad_bit_rate, mapped from YANG variable /ifm/interfaces/interface/common_statistics/receive_broad_bit_rate (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_receive_broad_bit_rate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_receive_broad_bit_rate() directly.

    YANG Description: Rate of broadcast bits received on an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-broad-bit-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """receive_broad_bit_rate must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-broad-bit-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__receive_broad_bit_rate = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_receive_broad_bit_rate(self):
    self.__receive_broad_bit_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-broad-bit-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)


  def _get_send_unicast_packet_rate(self):
    """
    Getter method for send_unicast_packet_rate, mapped from YANG variable /ifm/interfaces/interface/common_statistics/send_unicast_packet_rate (uint64)

    YANG Description: Rate of unicast packets sent on an interface.
    """
    return self.__send_unicast_packet_rate
      
  def _set_send_unicast_packet_rate(self, v, load=False):
    """
    Setter method for send_unicast_packet_rate, mapped from YANG variable /ifm/interfaces/interface/common_statistics/send_unicast_packet_rate (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_send_unicast_packet_rate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_send_unicast_packet_rate() directly.

    YANG Description: Rate of unicast packets sent on an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-unicast-packet-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """send_unicast_packet_rate must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-unicast-packet-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__send_unicast_packet_rate = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_send_unicast_packet_rate(self):
    self.__send_unicast_packet_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-unicast-packet-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)


  def _get_receive_unicast_packet_rate(self):
    """
    Getter method for receive_unicast_packet_rate, mapped from YANG variable /ifm/interfaces/interface/common_statistics/receive_unicast_packet_rate (uint64)

    YANG Description: Rate of unicast packets received on an interface.
    """
    return self.__receive_unicast_packet_rate
      
  def _set_receive_unicast_packet_rate(self, v, load=False):
    """
    Setter method for receive_unicast_packet_rate, mapped from YANG variable /ifm/interfaces/interface/common_statistics/receive_unicast_packet_rate (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_receive_unicast_packet_rate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_receive_unicast_packet_rate() directly.

    YANG Description: Rate of unicast packets received on an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-unicast-packet-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """receive_unicast_packet_rate must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-unicast-packet-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__receive_unicast_packet_rate = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_receive_unicast_packet_rate(self):
    self.__receive_unicast_packet_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-unicast-packet-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)


  def _get_send_multicast_packet_rate(self):
    """
    Getter method for send_multicast_packet_rate, mapped from YANG variable /ifm/interfaces/interface/common_statistics/send_multicast_packet_rate (uint64)

    YANG Description: Rate of multicast packets sent on an interface.
    """
    return self.__send_multicast_packet_rate
      
  def _set_send_multicast_packet_rate(self, v, load=False):
    """
    Setter method for send_multicast_packet_rate, mapped from YANG variable /ifm/interfaces/interface/common_statistics/send_multicast_packet_rate (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_send_multicast_packet_rate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_send_multicast_packet_rate() directly.

    YANG Description: Rate of multicast packets sent on an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-multicast-packet-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """send_multicast_packet_rate must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-multicast-packet-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__send_multicast_packet_rate = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_send_multicast_packet_rate(self):
    self.__send_multicast_packet_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-multicast-packet-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)


  def _get_receive_multicast_packet_rate(self):
    """
    Getter method for receive_multicast_packet_rate, mapped from YANG variable /ifm/interfaces/interface/common_statistics/receive_multicast_packet_rate (uint64)

    YANG Description: Rate of multicast packets received on an interface.
    """
    return self.__receive_multicast_packet_rate
      
  def _set_receive_multicast_packet_rate(self, v, load=False):
    """
    Setter method for receive_multicast_packet_rate, mapped from YANG variable /ifm/interfaces/interface/common_statistics/receive_multicast_packet_rate (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_receive_multicast_packet_rate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_receive_multicast_packet_rate() directly.

    YANG Description: Rate of multicast packets received on an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-multicast-packet-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """receive_multicast_packet_rate must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-multicast-packet-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__receive_multicast_packet_rate = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_receive_multicast_packet_rate(self):
    self.__receive_multicast_packet_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-multicast-packet-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)


  def _get_send_broadcast_packet_rate(self):
    """
    Getter method for send_broadcast_packet_rate, mapped from YANG variable /ifm/interfaces/interface/common_statistics/send_broadcast_packet_rate (uint64)

    YANG Description: Rate of broadcast packets sent on an interface.
    """
    return self.__send_broadcast_packet_rate
      
  def _set_send_broadcast_packet_rate(self, v, load=False):
    """
    Setter method for send_broadcast_packet_rate, mapped from YANG variable /ifm/interfaces/interface/common_statistics/send_broadcast_packet_rate (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_send_broadcast_packet_rate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_send_broadcast_packet_rate() directly.

    YANG Description: Rate of broadcast packets sent on an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-broadcast-packet-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """send_broadcast_packet_rate must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-broadcast-packet-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__send_broadcast_packet_rate = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_send_broadcast_packet_rate(self):
    self.__send_broadcast_packet_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-broadcast-packet-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)


  def _get_receive_broadcast_packet_rate(self):
    """
    Getter method for receive_broadcast_packet_rate, mapped from YANG variable /ifm/interfaces/interface/common_statistics/receive_broadcast_packet_rate (uint64)

    YANG Description: Rate of broadcast packets received on an interface.
    """
    return self.__receive_broadcast_packet_rate
      
  def _set_receive_broadcast_packet_rate(self, v, load=False):
    """
    Setter method for receive_broadcast_packet_rate, mapped from YANG variable /ifm/interfaces/interface/common_statistics/receive_broadcast_packet_rate (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_receive_broadcast_packet_rate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_receive_broadcast_packet_rate() directly.

    YANG Description: Rate of broadcast packets received on an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-broadcast-packet-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """receive_broadcast_packet_rate must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-broadcast-packet-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__receive_broadcast_packet_rate = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_receive_broadcast_packet_rate(self):
    self.__receive_broadcast_packet_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-broadcast-packet-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)

  stati_interval = __builtin__.property(_get_stati_interval)
  in_byte_rate = __builtin__.property(_get_in_byte_rate)
  in_bit_rate = __builtin__.property(_get_in_bit_rate)
  in_packet_rate = __builtin__.property(_get_in_packet_rate)
  in_use_rate = __builtin__.property(_get_in_use_rate)
  out_byte_rate = __builtin__.property(_get_out_byte_rate)
  out_bit_rate = __builtin__.property(_get_out_bit_rate)
  out_packet_rate = __builtin__.property(_get_out_packet_rate)
  out_use_rate = __builtin__.property(_get_out_use_rate)
  receive_byte = __builtin__.property(_get_receive_byte)
  send_byte = __builtin__.property(_get_send_byte)
  receive_packet = __builtin__.property(_get_receive_packet)
  send_packet = __builtin__.property(_get_send_packet)
  receive_unicast_packet = __builtin__.property(_get_receive_unicast_packet)
  receive_multicast_packet = __builtin__.property(_get_receive_multicast_packet)
  receive_broad_packet = __builtin__.property(_get_receive_broad_packet)
  send_unicast_packet = __builtin__.property(_get_send_unicast_packet)
  send_multicast_packet = __builtin__.property(_get_send_multicast_packet)
  send_broad_packet = __builtin__.property(_get_send_broad_packet)
  receive_error_packet = __builtin__.property(_get_receive_error_packet)
  receive_drop_packet = __builtin__.property(_get_receive_drop_packet)
  send_error_packet = __builtin__.property(_get_send_error_packet)
  send_drop_packet = __builtin__.property(_get_send_drop_packet)
  send_unicast_bit = __builtin__.property(_get_send_unicast_bit)
  receive_unicast_bit = __builtin__.property(_get_receive_unicast_bit)
  send_multicast_bit = __builtin__.property(_get_send_multicast_bit)
  receive_multicast_bit = __builtin__.property(_get_receive_multicast_bit)
  send_broad_bit = __builtin__.property(_get_send_broad_bit)
  receive_broad_bit = __builtin__.property(_get_receive_broad_bit)
  send_unicast_bit_rate = __builtin__.property(_get_send_unicast_bit_rate)
  receive_unicast_bit_rate = __builtin__.property(_get_receive_unicast_bit_rate)
  send_multicast_bit_rate = __builtin__.property(_get_send_multicast_bit_rate)
  receive_multicast_bit_rate = __builtin__.property(_get_receive_multicast_bit_rate)
  send_broad_bit_rate = __builtin__.property(_get_send_broad_bit_rate)
  receive_broad_bit_rate = __builtin__.property(_get_receive_broad_bit_rate)
  send_unicast_packet_rate = __builtin__.property(_get_send_unicast_packet_rate)
  receive_unicast_packet_rate = __builtin__.property(_get_receive_unicast_packet_rate)
  send_multicast_packet_rate = __builtin__.property(_get_send_multicast_packet_rate)
  receive_multicast_packet_rate = __builtin__.property(_get_receive_multicast_packet_rate)
  send_broadcast_packet_rate = __builtin__.property(_get_send_broadcast_packet_rate)
  receive_broadcast_packet_rate = __builtin__.property(_get_receive_broadcast_packet_rate)


  _pyangbind_elements = OrderedDict([('stati_interval', stati_interval), ('in_byte_rate', in_byte_rate), ('in_bit_rate', in_bit_rate), ('in_packet_rate', in_packet_rate), ('in_use_rate', in_use_rate), ('out_byte_rate', out_byte_rate), ('out_bit_rate', out_bit_rate), ('out_packet_rate', out_packet_rate), ('out_use_rate', out_use_rate), ('receive_byte', receive_byte), ('send_byte', send_byte), ('receive_packet', receive_packet), ('send_packet', send_packet), ('receive_unicast_packet', receive_unicast_packet), ('receive_multicast_packet', receive_multicast_packet), ('receive_broad_packet', receive_broad_packet), ('send_unicast_packet', send_unicast_packet), ('send_multicast_packet', send_multicast_packet), ('send_broad_packet', send_broad_packet), ('receive_error_packet', receive_error_packet), ('receive_drop_packet', receive_drop_packet), ('send_error_packet', send_error_packet), ('send_drop_packet', send_drop_packet), ('send_unicast_bit', send_unicast_bit), ('receive_unicast_bit', receive_unicast_bit), ('send_multicast_bit', send_multicast_bit), ('receive_multicast_bit', receive_multicast_bit), ('send_broad_bit', send_broad_bit), ('receive_broad_bit', receive_broad_bit), ('send_unicast_bit_rate', send_unicast_bit_rate), ('receive_unicast_bit_rate', receive_unicast_bit_rate), ('send_multicast_bit_rate', send_multicast_bit_rate), ('receive_multicast_bit_rate', receive_multicast_bit_rate), ('send_broad_bit_rate', send_broad_bit_rate), ('receive_broad_bit_rate', receive_broad_bit_rate), ('send_unicast_packet_rate', send_unicast_packet_rate), ('receive_unicast_packet_rate', receive_unicast_packet_rate), ('send_multicast_packet_rate', send_multicast_packet_rate), ('receive_multicast_packet_rate', receive_multicast_packet_rate), ('send_broadcast_packet_rate', send_broadcast_packet_rate), ('receive_broadcast_packet_rate', receive_broadcast_packet_rate), ])


class yc_error_down_huawei_ifm__ifm_interfaces_interface_error_down(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-ifm - based on the path /ifm/interfaces/interface/error-down. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Information about the interface in the error-down state, including the interface name, cause of the error-down event, delay for the transition from down to up, and remaining time for the up state.
  """
  __slots__ = ('_path_helper', '_extmethods', '__cause','__recovery_time','__remainder_time',)

  _yang_name = 'error-down'
  _yang_namespace = 'urn:huawei:yang:huawei-ifm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__cause = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'bpdu-protection': {'value': 0}, 'auto-defend': {'value': 1}, 'monitor-link': {'value': 2}, 'portsec-reached-limit': {'value': 65}, 'storm-control': {'value': 66}, 'loopback-detect': {'value': 67}, 'dual-active': {'value': 68}, 'mac-address-flapping': {'value': 69}, 'no-stack-link': {'value': 70}, 'crc-statistics': {'value': 71}, 'transceiver-power-low': {'value': 72}, 'link-flap': {'value': 73}, 'l2-loop-occured': {'value': 74}, 'stack-member-exceed-limit': {'value': 75}, 'spine-member-exceed-limit': {'value': 76}, 'resource-mismatch': {'value': 77}, 'leaf-mstp': {'value': 78}, 'm-lag': {'value': 79}, 'fabric-uplink-threshold': {'value': 80}, 'stack-config-conflict': {'value': 81}, 'spine-type-unsupported': {'value': 82}, 'stack-packet-defensive': {'value': 83}, 'forward-engine-buffer-failed': {'value': 85}, 'forward-engine-interface-failed': {'value': 86}, 'fabric-link-failure': {'value': 87}, 'm-lag-consistency-check': {'value': 88}},), is_leaf=True, yang_name="cause", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='error-down-type', is_config=False)
    self.__recovery_time = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..86400']}), is_leaf=True, yang_name="recovery-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)
    self.__remainder_time = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..86400']}), is_leaf=True, yang_name="remainder-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ifm', 'interfaces', 'interface', 'error-down']

  def _get_cause(self):
    """
    Getter method for cause, mapped from YANG variable /ifm/interfaces/interface/error_down/cause (error-down-type)

    YANG Description: Cause of the error-down event.
    """
    return self.__cause
      
  def _set_cause(self, v, load=False):
    """
    Setter method for cause, mapped from YANG variable /ifm/interfaces/interface/error_down/cause (error-down-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cause is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cause() directly.

    YANG Description: Cause of the error-down event.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'bpdu-protection': {'value': 0}, 'auto-defend': {'value': 1}, 'monitor-link': {'value': 2}, 'portsec-reached-limit': {'value': 65}, 'storm-control': {'value': 66}, 'loopback-detect': {'value': 67}, 'dual-active': {'value': 68}, 'mac-address-flapping': {'value': 69}, 'no-stack-link': {'value': 70}, 'crc-statistics': {'value': 71}, 'transceiver-power-low': {'value': 72}, 'link-flap': {'value': 73}, 'l2-loop-occured': {'value': 74}, 'stack-member-exceed-limit': {'value': 75}, 'spine-member-exceed-limit': {'value': 76}, 'resource-mismatch': {'value': 77}, 'leaf-mstp': {'value': 78}, 'm-lag': {'value': 79}, 'fabric-uplink-threshold': {'value': 80}, 'stack-config-conflict': {'value': 81}, 'spine-type-unsupported': {'value': 82}, 'stack-packet-defensive': {'value': 83}, 'forward-engine-buffer-failed': {'value': 85}, 'forward-engine-interface-failed': {'value': 86}, 'fabric-link-failure': {'value': 87}, 'm-lag-consistency-check': {'value': 88}},), is_leaf=True, yang_name="cause", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='error-down-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cause must be of a type compatible with error-down-type""",
          'defined-type': "huawei-ifm:error-down-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'bpdu-protection': {'value': 0}, 'auto-defend': {'value': 1}, 'monitor-link': {'value': 2}, 'portsec-reached-limit': {'value': 65}, 'storm-control': {'value': 66}, 'loopback-detect': {'value': 67}, 'dual-active': {'value': 68}, 'mac-address-flapping': {'value': 69}, 'no-stack-link': {'value': 70}, 'crc-statistics': {'value': 71}, 'transceiver-power-low': {'value': 72}, 'link-flap': {'value': 73}, 'l2-loop-occured': {'value': 74}, 'stack-member-exceed-limit': {'value': 75}, 'spine-member-exceed-limit': {'value': 76}, 'resource-mismatch': {'value': 77}, 'leaf-mstp': {'value': 78}, 'm-lag': {'value': 79}, 'fabric-uplink-threshold': {'value': 80}, 'stack-config-conflict': {'value': 81}, 'spine-type-unsupported': {'value': 82}, 'stack-packet-defensive': {'value': 83}, 'forward-engine-buffer-failed': {'value': 85}, 'forward-engine-interface-failed': {'value': 86}, 'fabric-link-failure': {'value': 87}, 'm-lag-consistency-check': {'value': 88}},), is_leaf=True, yang_name="cause", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='error-down-type', is_config=False)""",
        })

    self.__cause = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cause(self):
    self.__cause = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'bpdu-protection': {'value': 0}, 'auto-defend': {'value': 1}, 'monitor-link': {'value': 2}, 'portsec-reached-limit': {'value': 65}, 'storm-control': {'value': 66}, 'loopback-detect': {'value': 67}, 'dual-active': {'value': 68}, 'mac-address-flapping': {'value': 69}, 'no-stack-link': {'value': 70}, 'crc-statistics': {'value': 71}, 'transceiver-power-low': {'value': 72}, 'link-flap': {'value': 73}, 'l2-loop-occured': {'value': 74}, 'stack-member-exceed-limit': {'value': 75}, 'spine-member-exceed-limit': {'value': 76}, 'resource-mismatch': {'value': 77}, 'leaf-mstp': {'value': 78}, 'm-lag': {'value': 79}, 'fabric-uplink-threshold': {'value': 80}, 'stack-config-conflict': {'value': 81}, 'spine-type-unsupported': {'value': 82}, 'stack-packet-defensive': {'value': 83}, 'forward-engine-buffer-failed': {'value': 85}, 'forward-engine-interface-failed': {'value': 86}, 'fabric-link-failure': {'value': 87}, 'm-lag-consistency-check': {'value': 88}},), is_leaf=True, yang_name="cause", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='error-down-type', is_config=False)


  def _get_recovery_time(self):
    """
    Getter method for recovery_time, mapped from YANG variable /ifm/interfaces/interface/error_down/recovery_time (uint32)

    YANG Description: Delay for the transition from down to up.
    """
    return self.__recovery_time
      
  def _set_recovery_time(self, v, load=False):
    """
    Setter method for recovery_time, mapped from YANG variable /ifm/interfaces/interface/error_down/recovery_time (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_recovery_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_recovery_time() directly.

    YANG Description: Delay for the transition from down to up.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..86400']}), is_leaf=True, yang_name="recovery-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """recovery_time must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..86400']}), is_leaf=True, yang_name="recovery-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)""",
        })

    self.__recovery_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_recovery_time(self):
    self.__recovery_time = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..86400']}), is_leaf=True, yang_name="recovery-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)


  def _get_remainder_time(self):
    """
    Getter method for remainder_time, mapped from YANG variable /ifm/interfaces/interface/error_down/remainder_time (uint32)

    YANG Description: The remaining time for the up event.
    """
    return self.__remainder_time
      
  def _set_remainder_time(self, v, load=False):
    """
    Setter method for remainder_time, mapped from YANG variable /ifm/interfaces/interface/error_down/remainder_time (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_remainder_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_remainder_time() directly.

    YANG Description: The remaining time for the up event.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..86400']}), is_leaf=True, yang_name="remainder-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """remainder_time must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..86400']}), is_leaf=True, yang_name="remainder-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)""",
        })

    self.__remainder_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_remainder_time(self):
    self.__remainder_time = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..86400']}), is_leaf=True, yang_name="remainder-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)

  cause = __builtin__.property(_get_cause)
  recovery_time = __builtin__.property(_get_recovery_time)
  remainder_time = __builtin__.property(_get_remainder_time)


  _pyangbind_elements = OrderedDict([('cause', cause), ('recovery_time', recovery_time), ('remainder_time', remainder_time), ])


class yc_interface_huawei_ifm__ifm_interfaces_interface(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-ifm - based on the path /ifm/interfaces/interface. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure information on an interface. Physical, NULL, Virtual-if, and Virtual-Template0 interfaces cannot be created or deleted.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__class_','__type','__parent_name','__number','__description','__admin_status','__link_protocol','__router_type','__clear_ip_df','__link_up_down_trap_enable','__statistic_enable','__statistic_mode','__bandwidth','__bandwidth_kbps','__mtu','__spread_mtu_flag','__statistic_interval','__vrf_name','__l2_mode_enable','__down_delay_time','__mac_address','__index','__position','__aggregation_name','__is_l2_switch','__vs_name','__l2_switch_port_index','__service_type','__encapsulation_type','__network_layer_status','__protocol_up_delay_time','__control_flap','__trap_threshold','__ignore_damp','__damp','__damp_state','__dynamic','__mib_statistics','__common_statistics','__error_down',)

  _yang_name = 'interface'
  _yang_namespace = 'urn:huawei:yang:huawei-ifm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..63']}), is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='pub-type:if-name', is_config=True)
    self.__class_ = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'main-interface': {'value': 0}, 'sub-interface': {'value': 1}},), is_leaf=True, yang_name="class", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='class-type', is_config=True)
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'Ethernet': {'value': 0}, 'GigabitEthernet': {'value': 2}, 'Eth-Trunk': {'value': 4}, 'Ip-Trunk': {'value': 5}, 'Pos': {'value': 9}, 'Tunnel': {'value': 14}, 'NULL': {'value': 18}, 'LoopBack': {'value': 19}, 'Vlanif': {'value': 15}, '100GE': {'value': 20}, '200GE': {'value': 92}, '40GE': {'value': 23}, 'MTunnel': {'value': 22}, '10GE': {'value': 24}, 'GEBrief': {'value': 25}, 'MEth': {'value': 26}, 'IMEth': {'value': 79}, 'Stack-Port': {'value': 27}, 'Sip': {'value': 28}, 'Cpos': {'value': 10}, 'E1': {'value': 30}, 'Serial': {'value': 8}, 'Mp-group': {'value': 31}, 'Virtual-Ethernet': {'value': 6}, 'VMEth': {'value': 33}, 'Ima-group': {'value': 32}, 'Remote-Ap': {'value': 35}, 'VBridge': {'value': 36}, 'Atm-Bundle': {'value': 37}, 'Fiber-Channel': {'value': 38}, 'Infiniband': {'value': 39}, 'Lmpif': {'value': 21}, 'T1': {'value': 41}, 'T3': {'value': 42}, 'Global-VE': {'value': 45}, 'VC4': {'value': 43}, 'VC12': {'value': 44}, 'Vbdif': {'value': 40}, 'Fabric-Port': {'value': 46}, 'E3': {'value': 48}, 'Otn': {'value': 55}, 'Vp': {'value': 49}, 'DcnInterface': {'value': 50}, 'Cpos-Trunk': {'value': 51}, 'Pos-Trunk': {'value': 59}, 'Trunk-Serial': {'value': 52}, 'Global-Ima-Group': {'value': 57}, 'Global-Mp-Group': {'value': 53}, 'Gmpls-Uni': {'value': 63}, 'Wdm': {'value': 64}, 'Nve': {'value': 65}, 'FCoE-Port': {'value': 67}, 'Virtual-Template': {'value': 68}, 'FC': {'value': 70}, '4x10GE': {'value': 71}, '10x10GE': {'value': 72}, '3x40GE': {'value': 73}, '4x25GE': {'value': 74}, '25GE': {'value': 75}, 'ATM': {'value': 11}, 'XGigabitEthernet': {'value': 91}, 'ServiceIf': {'value': 90}, 'Virtual-ODUk': {'value': 94}, 'FlexE': {'value': 95}, 'FlexE-200GE': {'value': 96}, '50|100GE': {'value': 101}, '50GE': {'value': 102}, 'FlexE-50G': {'value': 103}, 'FlexE-100G': {'value': 104}, 'FlexE-50|100G': {'value': 105}, 'PW-VE': {'value': 88}, 'Virtual-Serial': {'value': 107}, '400GE': {'value': 108}, 'VX-Tunnel': {'value': 89}, 'HPGE': {'value': 114}, 'Virtual-if': {'value': 116}, 'Cellular': {'value': 117}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='port-type', is_config=True)
    self.__parent_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="parent-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='leafref', is_config=True)
    self.__number = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(\\d+/\\d+/\\d+/\\d+)|(\\d+/\\d+/\\d+)|(\\d+/\\d+)|(\\d+)|(\\d+/\\d+/\\d+[:]\\d+)|(\\d+/\\d+/\\d+[:]\\d+[:]\\d+[:]\\d+)|(\\d+/\\d+/\\d+/\\d+[:]\\d+)|(\\d+/\\d+/\\d+/\\d+[:]\\d+[:]\\d+[:]\\d+)|(\\d+/\\d+/\\d+/\\d+/\\d+[:]\\d+)|(\\d+/\\d+[:]\\d+)', 'length': ['1..63']}), is_leaf=True, yang_name="number", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='string', is_config=True)
    self.__description = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..242']}), is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='string', is_config=True)
    self.__admin_status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'down': {'value': 0}, 'up': {'value': 1}},), is_leaf=True, yang_name="admin-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='port-status', is_config=True)
    self.__link_protocol = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ethernet': {'value': 0}, 'ppp': {'value': 1}, 'hdlc': {'value': 2}, 'fr': {'value': 3}, 'atm': {'value': 6}, 'tdm': {'value': 7}},), is_leaf=True, yang_name="link-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='link-protocol', is_config=True)
    self.__router_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'PtoP': {'value': 0}, 'PtoMP': {'value': 1}, 'broadcast': {'value': 2}, 'NBMA': {'value': 3}, 'invalid': {'value': 255}},), is_leaf=True, yang_name="router-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='router-type', is_config=True)
    self.__clear_ip_df = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="clear-ip-df", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=True)
    self.__link_up_down_trap_enable = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="link-up-down-trap-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=True)
    self.__statistic_enable = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="statistic-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=True)
    self.__statistic_mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'interface-based': {'value': 1}, 'vlan-group-based': {'value': 2}},), default=six.text_type("interface-based"), is_leaf=True, yang_name="statistic-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='statistic-mode', is_config=True)
    self.__bandwidth = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..1000000']}), is_leaf=True, yang_name="bandwidth", parent=self, choice=('bandwidth-type', 'bandwidth-mbps'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)
    self.__bandwidth_kbps = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..1000000']}), is_leaf=True, yang_name="bandwidth-kbps", parent=self, choice=('bandwidth-type', 'bandwidth-kbps'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)
    self.__mtu = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..64000']}), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)
    self.__spread_mtu_flag = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="spread-mtu-flag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=True)
    self.__statistic_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['10..600']}), is_leaf=True, yang_name="statistic-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)
    self.__vrf_name = YANGDynClass(base=six.text_type, default=six.text_type("_public_"), is_leaf=True, yang_name="vrf-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='leafref', is_config=True)
    self.__l2_mode_enable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="l2-mode-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=True)
    self.__down_delay_time = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..1000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="down-delay-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)
    self.__mac_address = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9a-f]{4}(-[0-9a-f]{4}){2}', 'length': ['0..255']}), restriction_dict={'length': ['0..255']}), is_leaf=True, yang_name="mac-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='pub-type:mac-address', is_config=True)
    self.__index = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)
    self.__position = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..256']}), is_leaf=True, yang_name="position", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='string', is_config=False)
    self.__aggregation_name = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..63']}), is_leaf=True, yang_name="aggregation-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='pub-type:if-name', is_config=False)
    self.__is_l2_switch = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="is-l2-switch", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=False)
    self.__vs_name = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..50']}), is_leaf=True, yang_name="vs-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='string', is_config=False)
    self.__l2_switch_port_index = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="l2-switch-port-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)
    self.__service_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'none': {'value': 0}, 'trunk-member': {'value': 2}, 'stack-member': {'value': 6}, 'mp-member': {'value': 7}, 'vbridge-member': {'value': 8}, 'ima-member': {'value': 9}, 'bundle-member': {'value': 10}, 'fabric-member': {'value': 11}, 'lag-master-member': {'value': 12}, 'lag-slave-member': {'value': 13}, 'cpos-trunk-member': {'value': 15}, 'pos-trunk-member': {'value': 16}, 'global-mp-member': {'value': 17}, 'global-ima-member': {'value': 18}},), is_leaf=True, yang_name="service-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='service-type', is_config=False)
    self.__encapsulation_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'vlan-type': {'value': 0}, 'dot1q': {'value': 1}, 'qinq': {'value': 2}, 'p2p': {'value': 3}, 'p2mp': {'value': 4}, 'l2ve': {'value': 5}, 'l3ve': {'value': 6}, 'vlan-type-policy': {'value': 7}, 'dot1q-policy': {'value': 8}, 'stacking-policy': {'value': 9}, 'untag-policy': {'value': 10}, 'qinq-mapping': {'value': 11}, 'l2vc': {'value': 12}, 'l3vc': {'value': 13}, 'evc-untag': {'value': 14}, 'evc-dot1q': {'value': 15}, 'evc-qinq': {'value': 16}, 'evc-default': {'value': 17}, 'evc-dot1q-policy': {'value': 18}, 'ietf': {'value': 19}, 'nonstandard': {'value': 20}, 'user-vlan': {'value': 21}, 'user-vlan-anyother': {'value': 22}, 'qin-link': {'value': 23}, 'soft-gre-ve': {'value': 24}, 'l3ve-ter': {'value': 25}, 'l3ve-acc': {'value': 26}, 'invalid': {'value': 255}},), is_leaf=True, yang_name="encapsulation-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='encapsulation-type', is_config=False)
    self.__network_layer_status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ipv4-ipv6-up': {'value': 0}, 'ipv4-ipv6-down': {'value': 196608}},), default=six.text_type("ipv4-ipv6-up"), is_leaf=True, yang_name="network-layer-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='network-layer-state', is_config=True)
    self.__protocol_up_delay_time = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..7200']}), is_leaf=True, yang_name="protocol-up-delay-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)
    self.__control_flap = YANGDynClass(base=yc_control_flap_huawei_ifm__ifm_interfaces_interface_control_flap, is_container='container', yang_name="control-flap", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)
    self.__trap_threshold = YANGDynClass(base=yc_trap_threshold_huawei_ifm__ifm_interfaces_interface_trap_threshold, is_container='container', yang_name="trap-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)
    self.__ignore_damp = YANGDynClass(base=yc_ignore_damp_huawei_ifm__ifm_interfaces_interface_ignore_damp, is_container='container', yang_name="ignore-damp", parent=self, choice=('damping', 'ignore-damp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)
    self.__damp = YANGDynClass(base=yc_damp_huawei_ifm__ifm_interfaces_interface_damp, is_container='container', yang_name="damp", parent=self, choice=('damping', 'damp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)
    self.__damp_state = YANGDynClass(base=yc_damp_state_huawei_ifm__ifm_interfaces_interface_damp_state, is_container='container', yang_name="damp-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)
    self.__dynamic = YANGDynClass(base=yc_dynamic_huawei_ifm__ifm_interfaces_interface_dynamic, is_container='container', yang_name="dynamic", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)
    self.__mib_statistics = YANGDynClass(base=yc_mib_statistics_huawei_ifm__ifm_interfaces_interface_mib_statistics, is_container='container', yang_name="mib-statistics", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)
    self.__common_statistics = YANGDynClass(base=yc_common_statistics_huawei_ifm__ifm_interfaces_interface_common_statistics, is_container='container', yang_name="common-statistics", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)
    self.__error_down = YANGDynClass(base=yc_error_down_huawei_ifm__ifm_interfaces_interface_error_down, is_container='container', yang_name="error-down", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ifm', 'interfaces', 'interface']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /ifm/interfaces/interface/name (pub-type:if-name)

    YANG Description: The textual name of the interface. It should be the name of the interface as assigned by the local device. It should be suitable for use in commands which entered at the device's 'console'. This might be a text name, such as 'NULL0', depending on the interface naming syntax of the device.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /ifm/interfaces/interface/name (pub-type:if-name)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: The textual name of the interface. It should be the name of the interface as assigned by the local device. It should be suitable for use in commands which entered at the device's 'console'. This might be a text name, such as 'NULL0', depending on the interface naming syntax of the device.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..63']}), is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='pub-type:if-name', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with pub-type:if-name""",
          'defined-type': "pub-type:if-name",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..63']}), is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='pub-type:if-name', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..63']}), is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='pub-type:if-name', is_config=True)


  def _get_class_(self):
    """
    Getter method for class_, mapped from YANG variable /ifm/interfaces/interface/class (class-type)

    YANG Description: Identify a main interface or a sub-interface.
    """
    return self.__class_
      
  def _set_class_(self, v, load=False):
    """
    Setter method for class_, mapped from YANG variable /ifm/interfaces/interface/class (class-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_class_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_class_() directly.

    YANG Description: Identify a main interface or a sub-interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'main-interface': {'value': 0}, 'sub-interface': {'value': 1}},), is_leaf=True, yang_name="class", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='class-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """class_ must be of a type compatible with class-type""",
          'defined-type': "huawei-ifm:class-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'main-interface': {'value': 0}, 'sub-interface': {'value': 1}},), is_leaf=True, yang_name="class", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='class-type', is_config=True)""",
        })

    self.__class_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_class_(self):
    self.__class_ = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'main-interface': {'value': 0}, 'sub-interface': {'value': 1}},), is_leaf=True, yang_name="class", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='class-type', is_config=True)


  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /ifm/interfaces/interface/type (port-type)

    YANG Description: Type of an interface. Interfaces include physical and logical interfaces.
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /ifm/interfaces/interface/type (port-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: Type of an interface. Interfaces include physical and logical interfaces.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'Ethernet': {'value': 0}, 'GigabitEthernet': {'value': 2}, 'Eth-Trunk': {'value': 4}, 'Ip-Trunk': {'value': 5}, 'Pos': {'value': 9}, 'Tunnel': {'value': 14}, 'NULL': {'value': 18}, 'LoopBack': {'value': 19}, 'Vlanif': {'value': 15}, '100GE': {'value': 20}, '200GE': {'value': 92}, '40GE': {'value': 23}, 'MTunnel': {'value': 22}, '10GE': {'value': 24}, 'GEBrief': {'value': 25}, 'MEth': {'value': 26}, 'IMEth': {'value': 79}, 'Stack-Port': {'value': 27}, 'Sip': {'value': 28}, 'Cpos': {'value': 10}, 'E1': {'value': 30}, 'Serial': {'value': 8}, 'Mp-group': {'value': 31}, 'Virtual-Ethernet': {'value': 6}, 'VMEth': {'value': 33}, 'Ima-group': {'value': 32}, 'Remote-Ap': {'value': 35}, 'VBridge': {'value': 36}, 'Atm-Bundle': {'value': 37}, 'Fiber-Channel': {'value': 38}, 'Infiniband': {'value': 39}, 'Lmpif': {'value': 21}, 'T1': {'value': 41}, 'T3': {'value': 42}, 'Global-VE': {'value': 45}, 'VC4': {'value': 43}, 'VC12': {'value': 44}, 'Vbdif': {'value': 40}, 'Fabric-Port': {'value': 46}, 'E3': {'value': 48}, 'Otn': {'value': 55}, 'Vp': {'value': 49}, 'DcnInterface': {'value': 50}, 'Cpos-Trunk': {'value': 51}, 'Pos-Trunk': {'value': 59}, 'Trunk-Serial': {'value': 52}, 'Global-Ima-Group': {'value': 57}, 'Global-Mp-Group': {'value': 53}, 'Gmpls-Uni': {'value': 63}, 'Wdm': {'value': 64}, 'Nve': {'value': 65}, 'FCoE-Port': {'value': 67}, 'Virtual-Template': {'value': 68}, 'FC': {'value': 70}, '4x10GE': {'value': 71}, '10x10GE': {'value': 72}, '3x40GE': {'value': 73}, '4x25GE': {'value': 74}, '25GE': {'value': 75}, 'ATM': {'value': 11}, 'XGigabitEthernet': {'value': 91}, 'ServiceIf': {'value': 90}, 'Virtual-ODUk': {'value': 94}, 'FlexE': {'value': 95}, 'FlexE-200GE': {'value': 96}, '50|100GE': {'value': 101}, '50GE': {'value': 102}, 'FlexE-50G': {'value': 103}, 'FlexE-100G': {'value': 104}, 'FlexE-50|100G': {'value': 105}, 'PW-VE': {'value': 88}, 'Virtual-Serial': {'value': 107}, '400GE': {'value': 108}, 'VX-Tunnel': {'value': 89}, 'HPGE': {'value': 114}, 'Virtual-if': {'value': 116}, 'Cellular': {'value': 117}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='port-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with port-type""",
          'defined-type': "huawei-ifm:port-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'Ethernet': {'value': 0}, 'GigabitEthernet': {'value': 2}, 'Eth-Trunk': {'value': 4}, 'Ip-Trunk': {'value': 5}, 'Pos': {'value': 9}, 'Tunnel': {'value': 14}, 'NULL': {'value': 18}, 'LoopBack': {'value': 19}, 'Vlanif': {'value': 15}, '100GE': {'value': 20}, '200GE': {'value': 92}, '40GE': {'value': 23}, 'MTunnel': {'value': 22}, '10GE': {'value': 24}, 'GEBrief': {'value': 25}, 'MEth': {'value': 26}, 'IMEth': {'value': 79}, 'Stack-Port': {'value': 27}, 'Sip': {'value': 28}, 'Cpos': {'value': 10}, 'E1': {'value': 30}, 'Serial': {'value': 8}, 'Mp-group': {'value': 31}, 'Virtual-Ethernet': {'value': 6}, 'VMEth': {'value': 33}, 'Ima-group': {'value': 32}, 'Remote-Ap': {'value': 35}, 'VBridge': {'value': 36}, 'Atm-Bundle': {'value': 37}, 'Fiber-Channel': {'value': 38}, 'Infiniband': {'value': 39}, 'Lmpif': {'value': 21}, 'T1': {'value': 41}, 'T3': {'value': 42}, 'Global-VE': {'value': 45}, 'VC4': {'value': 43}, 'VC12': {'value': 44}, 'Vbdif': {'value': 40}, 'Fabric-Port': {'value': 46}, 'E3': {'value': 48}, 'Otn': {'value': 55}, 'Vp': {'value': 49}, 'DcnInterface': {'value': 50}, 'Cpos-Trunk': {'value': 51}, 'Pos-Trunk': {'value': 59}, 'Trunk-Serial': {'value': 52}, 'Global-Ima-Group': {'value': 57}, 'Global-Mp-Group': {'value': 53}, 'Gmpls-Uni': {'value': 63}, 'Wdm': {'value': 64}, 'Nve': {'value': 65}, 'FCoE-Port': {'value': 67}, 'Virtual-Template': {'value': 68}, 'FC': {'value': 70}, '4x10GE': {'value': 71}, '10x10GE': {'value': 72}, '3x40GE': {'value': 73}, '4x25GE': {'value': 74}, '25GE': {'value': 75}, 'ATM': {'value': 11}, 'XGigabitEthernet': {'value': 91}, 'ServiceIf': {'value': 90}, 'Virtual-ODUk': {'value': 94}, 'FlexE': {'value': 95}, 'FlexE-200GE': {'value': 96}, '50|100GE': {'value': 101}, '50GE': {'value': 102}, 'FlexE-50G': {'value': 103}, 'FlexE-100G': {'value': 104}, 'FlexE-50|100G': {'value': 105}, 'PW-VE': {'value': 88}, 'Virtual-Serial': {'value': 107}, '400GE': {'value': 108}, 'VX-Tunnel': {'value': 89}, 'HPGE': {'value': 114}, 'Virtual-if': {'value': 116}, 'Cellular': {'value': 117}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='port-type', is_config=True)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'Ethernet': {'value': 0}, 'GigabitEthernet': {'value': 2}, 'Eth-Trunk': {'value': 4}, 'Ip-Trunk': {'value': 5}, 'Pos': {'value': 9}, 'Tunnel': {'value': 14}, 'NULL': {'value': 18}, 'LoopBack': {'value': 19}, 'Vlanif': {'value': 15}, '100GE': {'value': 20}, '200GE': {'value': 92}, '40GE': {'value': 23}, 'MTunnel': {'value': 22}, '10GE': {'value': 24}, 'GEBrief': {'value': 25}, 'MEth': {'value': 26}, 'IMEth': {'value': 79}, 'Stack-Port': {'value': 27}, 'Sip': {'value': 28}, 'Cpos': {'value': 10}, 'E1': {'value': 30}, 'Serial': {'value': 8}, 'Mp-group': {'value': 31}, 'Virtual-Ethernet': {'value': 6}, 'VMEth': {'value': 33}, 'Ima-group': {'value': 32}, 'Remote-Ap': {'value': 35}, 'VBridge': {'value': 36}, 'Atm-Bundle': {'value': 37}, 'Fiber-Channel': {'value': 38}, 'Infiniband': {'value': 39}, 'Lmpif': {'value': 21}, 'T1': {'value': 41}, 'T3': {'value': 42}, 'Global-VE': {'value': 45}, 'VC4': {'value': 43}, 'VC12': {'value': 44}, 'Vbdif': {'value': 40}, 'Fabric-Port': {'value': 46}, 'E3': {'value': 48}, 'Otn': {'value': 55}, 'Vp': {'value': 49}, 'DcnInterface': {'value': 50}, 'Cpos-Trunk': {'value': 51}, 'Pos-Trunk': {'value': 59}, 'Trunk-Serial': {'value': 52}, 'Global-Ima-Group': {'value': 57}, 'Global-Mp-Group': {'value': 53}, 'Gmpls-Uni': {'value': 63}, 'Wdm': {'value': 64}, 'Nve': {'value': 65}, 'FCoE-Port': {'value': 67}, 'Virtual-Template': {'value': 68}, 'FC': {'value': 70}, '4x10GE': {'value': 71}, '10x10GE': {'value': 72}, '3x40GE': {'value': 73}, '4x25GE': {'value': 74}, '25GE': {'value': 75}, 'ATM': {'value': 11}, 'XGigabitEthernet': {'value': 91}, 'ServiceIf': {'value': 90}, 'Virtual-ODUk': {'value': 94}, 'FlexE': {'value': 95}, 'FlexE-200GE': {'value': 96}, '50|100GE': {'value': 101}, '50GE': {'value': 102}, 'FlexE-50G': {'value': 103}, 'FlexE-100G': {'value': 104}, 'FlexE-50|100G': {'value': 105}, 'PW-VE': {'value': 88}, 'Virtual-Serial': {'value': 107}, '400GE': {'value': 108}, 'VX-Tunnel': {'value': 89}, 'HPGE': {'value': 114}, 'Virtual-if': {'value': 116}, 'Cellular': {'value': 117}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='port-type', is_config=True)


  def _get_parent_name(self):
    """
    Getter method for parent_name, mapped from YANG variable /ifm/interfaces/interface/parent_name (leafref)

    YANG Description: Name of the main interface. For example, Ethernet0/1/0.
    """
    return self.__parent_name
      
  def _set_parent_name(self, v, load=False):
    """
    Setter method for parent_name, mapped from YANG variable /ifm/interfaces/interface/parent_name (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_parent_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_parent_name() directly.

    YANG Description: Name of the main interface. For example, Ethernet0/1/0.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="parent-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """parent_name must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="parent-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='leafref', is_config=True)""",
        })

    self.__parent_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_parent_name(self):
    self.__parent_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="parent-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='leafref', is_config=True)


  def _get_number(self):
    """
    Getter method for number, mapped from YANG variable /ifm/interfaces/interface/number (string)

    YANG Description: Number of an interface. For example,1, 0/1/0, or 2:1.
    """
    return self.__number
      
  def _set_number(self, v, load=False):
    """
    Setter method for number, mapped from YANG variable /ifm/interfaces/interface/number (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_number is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_number() directly.

    YANG Description: Number of an interface. For example,1, 0/1/0, or 2:1.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(\\d+/\\d+/\\d+/\\d+)|(\\d+/\\d+/\\d+)|(\\d+/\\d+)|(\\d+)|(\\d+/\\d+/\\d+[:]\\d+)|(\\d+/\\d+/\\d+[:]\\d+[:]\\d+[:]\\d+)|(\\d+/\\d+/\\d+/\\d+[:]\\d+)|(\\d+/\\d+/\\d+/\\d+[:]\\d+[:]\\d+[:]\\d+)|(\\d+/\\d+/\\d+/\\d+/\\d+[:]\\d+)|(\\d+/\\d+[:]\\d+)', 'length': ['1..63']}), is_leaf=True, yang_name="number", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """number must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(\\d+/\\d+/\\d+/\\d+)|(\\d+/\\d+/\\d+)|(\\d+/\\d+)|(\\d+)|(\\d+/\\d+/\\d+[:]\\d+)|(\\d+/\\d+/\\d+[:]\\d+[:]\\d+[:]\\d+)|(\\d+/\\d+/\\d+/\\d+[:]\\d+)|(\\d+/\\d+/\\d+/\\d+[:]\\d+[:]\\d+[:]\\d+)|(\\d+/\\d+/\\d+/\\d+/\\d+[:]\\d+)|(\\d+/\\d+[:]\\d+)', 'length': ['1..63']}), is_leaf=True, yang_name="number", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='string', is_config=True)""",
        })

    self.__number = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_number(self):
    self.__number = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(\\d+/\\d+/\\d+/\\d+)|(\\d+/\\d+/\\d+)|(\\d+/\\d+)|(\\d+)|(\\d+/\\d+/\\d+[:]\\d+)|(\\d+/\\d+/\\d+[:]\\d+[:]\\d+[:]\\d+)|(\\d+/\\d+/\\d+/\\d+[:]\\d+)|(\\d+/\\d+/\\d+/\\d+[:]\\d+[:]\\d+[:]\\d+)|(\\d+/\\d+/\\d+/\\d+/\\d+[:]\\d+)|(\\d+/\\d+[:]\\d+)', 'length': ['1..63']}), is_leaf=True, yang_name="number", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='string', is_config=True)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /ifm/interfaces/interface/description (string)

    YANG Description: Description of an interface.
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /ifm/interfaces/interface/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Description of an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..242']}), is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..242']}), is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..242']}), is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='string', is_config=True)


  def _get_admin_status(self):
    """
    Getter method for admin_status, mapped from YANG variable /ifm/interfaces/interface/admin_status (port-status)

    YANG Description: Administrative status of an interface. Capabilities supported by this node vary according to interface types.
    """
    return self.__admin_status
      
  def _set_admin_status(self, v, load=False):
    """
    Setter method for admin_status, mapped from YANG variable /ifm/interfaces/interface/admin_status (port-status)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_admin_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_admin_status() directly.

    YANG Description: Administrative status of an interface. Capabilities supported by this node vary according to interface types.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'down': {'value': 0}, 'up': {'value': 1}},), is_leaf=True, yang_name="admin-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='port-status', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """admin_status must be of a type compatible with port-status""",
          'defined-type': "huawei-ifm:port-status",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'down': {'value': 0}, 'up': {'value': 1}},), is_leaf=True, yang_name="admin-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='port-status', is_config=True)""",
        })

    self.__admin_status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_admin_status(self):
    self.__admin_status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'down': {'value': 0}, 'up': {'value': 1}},), is_leaf=True, yang_name="admin-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='port-status', is_config=True)


  def _get_link_protocol(self):
    """
    Getter method for link_protocol, mapped from YANG variable /ifm/interfaces/interface/link_protocol (link-protocol)

    YANG Description: Link protocol. Capabilities supported by this node vary according to interface types.
    """
    return self.__link_protocol
      
  def _set_link_protocol(self, v, load=False):
    """
    Setter method for link_protocol, mapped from YANG variable /ifm/interfaces/interface/link_protocol (link-protocol)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_link_protocol is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_link_protocol() directly.

    YANG Description: Link protocol. Capabilities supported by this node vary according to interface types.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ethernet': {'value': 0}, 'ppp': {'value': 1}, 'hdlc': {'value': 2}, 'fr': {'value': 3}, 'atm': {'value': 6}, 'tdm': {'value': 7}},), is_leaf=True, yang_name="link-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='link-protocol', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """link_protocol must be of a type compatible with link-protocol""",
          'defined-type': "huawei-ifm:link-protocol",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ethernet': {'value': 0}, 'ppp': {'value': 1}, 'hdlc': {'value': 2}, 'fr': {'value': 3}, 'atm': {'value': 6}, 'tdm': {'value': 7}},), is_leaf=True, yang_name="link-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='link-protocol', is_config=True)""",
        })

    self.__link_protocol = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_link_protocol(self):
    self.__link_protocol = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ethernet': {'value': 0}, 'ppp': {'value': 1}, 'hdlc': {'value': 2}, 'fr': {'value': 3}, 'atm': {'value': 6}, 'tdm': {'value': 7}},), is_leaf=True, yang_name="link-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='link-protocol', is_config=True)


  def _get_router_type(self):
    """
    Getter method for router_type, mapped from YANG variable /ifm/interfaces/interface/router_type (router-type)

    YANG Description: Route attribute of an interface. Capabilities supported by this node vary according to interface types.
    """
    return self.__router_type
      
  def _set_router_type(self, v, load=False):
    """
    Setter method for router_type, mapped from YANG variable /ifm/interfaces/interface/router_type (router-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_router_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_router_type() directly.

    YANG Description: Route attribute of an interface. Capabilities supported by this node vary according to interface types.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'PtoP': {'value': 0}, 'PtoMP': {'value': 1}, 'broadcast': {'value': 2}, 'NBMA': {'value': 3}, 'invalid': {'value': 255}},), is_leaf=True, yang_name="router-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='router-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """router_type must be of a type compatible with router-type""",
          'defined-type': "huawei-ifm:router-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'PtoP': {'value': 0}, 'PtoMP': {'value': 1}, 'broadcast': {'value': 2}, 'NBMA': {'value': 3}, 'invalid': {'value': 255}},), is_leaf=True, yang_name="router-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='router-type', is_config=True)""",
        })

    self.__router_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_router_type(self):
    self.__router_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'PtoP': {'value': 0}, 'PtoMP': {'value': 1}, 'broadcast': {'value': 2}, 'NBMA': {'value': 3}, 'invalid': {'value': 255}},), is_leaf=True, yang_name="router-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='router-type', is_config=True)


  def _get_clear_ip_df(self):
    """
    Getter method for clear_ip_df, mapped from YANG variable /ifm/interfaces/interface/clear_ip_df (boolean)

    YANG Description: Enable/disable a device to forcibly fragment IP packets on an outbound interface. Capabilities supported by this node vary according to interface types.
    """
    return self.__clear_ip_df
      
  def _set_clear_ip_df(self, v, load=False):
    """
    Setter method for clear_ip_df, mapped from YANG variable /ifm/interfaces/interface/clear_ip_df (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_clear_ip_df is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_clear_ip_df() directly.

    YANG Description: Enable/disable a device to forcibly fragment IP packets on an outbound interface. Capabilities supported by this node vary according to interface types.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="clear-ip-df", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """clear_ip_df must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="clear-ip-df", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=True)""",
        })

    self.__clear_ip_df = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_clear_ip_df(self):
    self.__clear_ip_df = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="clear-ip-df", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=True)


  def _get_link_up_down_trap_enable(self):
    """
    Getter method for link_up_down_trap_enable, mapped from YANG variable /ifm/interfaces/interface/link_up_down_trap_enable (boolean)

    YANG Description: Enable/disable the trap function on an interface. Capabilities supported by this node vary according to interface types.
    """
    return self.__link_up_down_trap_enable
      
  def _set_link_up_down_trap_enable(self, v, load=False):
    """
    Setter method for link_up_down_trap_enable, mapped from YANG variable /ifm/interfaces/interface/link_up_down_trap_enable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_link_up_down_trap_enable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_link_up_down_trap_enable() directly.

    YANG Description: Enable/disable the trap function on an interface. Capabilities supported by this node vary according to interface types.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="link-up-down-trap-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """link_up_down_trap_enable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="link-up-down-trap-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=True)""",
        })

    self.__link_up_down_trap_enable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_link_up_down_trap_enable(self):
    self.__link_up_down_trap_enable = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="link-up-down-trap-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=True)


  def _get_statistic_enable(self):
    """
    Getter method for statistic_enable, mapped from YANG variable /ifm/interfaces/interface/statistic_enable (boolean)

    YANG Description: Enable/disable the statistics function on an interface. The default value of this node varies according to different interface types. Capabilities supported by this node vary according to interface types.
    """
    return self.__statistic_enable
      
  def _set_statistic_enable(self, v, load=False):
    """
    Setter method for statistic_enable, mapped from YANG variable /ifm/interfaces/interface/statistic_enable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_statistic_enable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_statistic_enable() directly.

    YANG Description: Enable/disable the statistics function on an interface. The default value of this node varies according to different interface types. Capabilities supported by this node vary according to interface types.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="statistic-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """statistic_enable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="statistic-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=True)""",
        })

    self.__statistic_enable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_statistic_enable(self):
    self.__statistic_enable = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="statistic-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=True)


  def _get_statistic_mode(self):
    """
    Getter method for statistic_mode, mapped from YANG variable /ifm/interfaces/interface/statistic_mode (statistic-mode)

    YANG Description: Mode of statistics collection. Capabilities supported by this node vary according to interface types.
    """
    return self.__statistic_mode
      
  def _set_statistic_mode(self, v, load=False):
    """
    Setter method for statistic_mode, mapped from YANG variable /ifm/interfaces/interface/statistic_mode (statistic-mode)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_statistic_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_statistic_mode() directly.

    YANG Description: Mode of statistics collection. Capabilities supported by this node vary according to interface types.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'interface-based': {'value': 1}, 'vlan-group-based': {'value': 2}},), default=six.text_type("interface-based"), is_leaf=True, yang_name="statistic-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='statistic-mode', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """statistic_mode must be of a type compatible with statistic-mode""",
          'defined-type': "huawei-ifm:statistic-mode",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'interface-based': {'value': 1}, 'vlan-group-based': {'value': 2}},), default=six.text_type("interface-based"), is_leaf=True, yang_name="statistic-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='statistic-mode', is_config=True)""",
        })

    self.__statistic_mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_statistic_mode(self):
    self.__statistic_mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'interface-based': {'value': 1}, 'vlan-group-based': {'value': 2}},), default=six.text_type("interface-based"), is_leaf=True, yang_name="statistic-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='statistic-mode', is_config=True)


  def _get_bandwidth(self):
    """
    Getter method for bandwidth, mapped from YANG variable /ifm/interfaces/interface/bandwidth (uint32)

    YANG Description: Configure the bandwidth of an interface. Capabilities supported by this node vary according to interface types.
    """
    return self.__bandwidth
      
  def _set_bandwidth(self, v, load=False):
    """
    Setter method for bandwidth, mapped from YANG variable /ifm/interfaces/interface/bandwidth (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bandwidth is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bandwidth() directly.

    YANG Description: Configure the bandwidth of an interface. Capabilities supported by this node vary according to interface types.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..1000000']}), is_leaf=True, yang_name="bandwidth", parent=self, choice=('bandwidth-type', 'bandwidth-mbps'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bandwidth must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..1000000']}), is_leaf=True, yang_name="bandwidth", parent=self, choice=('bandwidth-type', 'bandwidth-mbps'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)""",
        })

    self.__bandwidth = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bandwidth(self):
    self.__bandwidth = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..1000000']}), is_leaf=True, yang_name="bandwidth", parent=self, choice=('bandwidth-type', 'bandwidth-mbps'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)


  def _get_bandwidth_kbps(self):
    """
    Getter method for bandwidth_kbps, mapped from YANG variable /ifm/interfaces/interface/bandwidth_kbps (uint32)

    YANG Description: Configure the bandwidth of an interface. Capabilities supported by this node vary according to interface types.
    """
    return self.__bandwidth_kbps
      
  def _set_bandwidth_kbps(self, v, load=False):
    """
    Setter method for bandwidth_kbps, mapped from YANG variable /ifm/interfaces/interface/bandwidth_kbps (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bandwidth_kbps is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bandwidth_kbps() directly.

    YANG Description: Configure the bandwidth of an interface. Capabilities supported by this node vary according to interface types.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..1000000']}), is_leaf=True, yang_name="bandwidth-kbps", parent=self, choice=('bandwidth-type', 'bandwidth-kbps'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bandwidth_kbps must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..1000000']}), is_leaf=True, yang_name="bandwidth-kbps", parent=self, choice=('bandwidth-type', 'bandwidth-kbps'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)""",
        })

    self.__bandwidth_kbps = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bandwidth_kbps(self):
    self.__bandwidth_kbps = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..1000000']}), is_leaf=True, yang_name="bandwidth-kbps", parent=self, choice=('bandwidth-type', 'bandwidth-kbps'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)


  def _get_mtu(self):
    """
    Getter method for mtu, mapped from YANG variable /ifm/interfaces/interface/mtu (uint32)

    YANG Description: Maximum transmission unit of an interface.
Special explanation:
Range: The server may restrict the allowed values for this leaf, depending on the interface types.
Capabilities supported by this node vary according to interface types.
    """
    return self.__mtu
      
  def _set_mtu(self, v, load=False):
    """
    Setter method for mtu, mapped from YANG variable /ifm/interfaces/interface/mtu (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mtu is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mtu() directly.

    YANG Description: Maximum transmission unit of an interface.
Special explanation:
Range: The server may restrict the allowed values for this leaf, depending on the interface types.
Capabilities supported by this node vary according to interface types.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..64000']}), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mtu must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..64000']}), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)""",
        })

    self.__mtu = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mtu(self):
    self.__mtu = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..64000']}), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)


  def _get_spread_mtu_flag(self):
    """
    Getter method for spread_mtu_flag, mapped from YANG variable /ifm/interfaces/interface/spread_mtu_flag (boolean)

    YANG Description: Enable/disable the function of spreading the MTU value of main interface to subinterface. Capabilities supported by this node vary according to interface types.
    """
    return self.__spread_mtu_flag
      
  def _set_spread_mtu_flag(self, v, load=False):
    """
    Setter method for spread_mtu_flag, mapped from YANG variable /ifm/interfaces/interface/spread_mtu_flag (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_spread_mtu_flag is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_spread_mtu_flag() directly.

    YANG Description: Enable/disable the function of spreading the MTU value of main interface to subinterface. Capabilities supported by this node vary according to interface types.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="spread-mtu-flag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """spread_mtu_flag must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="spread-mtu-flag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=True)""",
        })

    self.__spread_mtu_flag = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_spread_mtu_flag(self):
    self.__spread_mtu_flag = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="spread-mtu-flag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=True)


  def _get_statistic_interval(self):
    """
    Getter method for statistic_interval, mapped from YANG variable /ifm/interfaces/interface/statistic_interval (uint32)

    YANG Description: Interval at which flow statistics are collected on an interface. Capabilities supported by this node vary according to interface types.
    """
    return self.__statistic_interval
      
  def _set_statistic_interval(self, v, load=False):
    """
    Setter method for statistic_interval, mapped from YANG variable /ifm/interfaces/interface/statistic_interval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_statistic_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_statistic_interval() directly.

    YANG Description: Interval at which flow statistics are collected on an interface. Capabilities supported by this node vary according to interface types.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['10..600']}), is_leaf=True, yang_name="statistic-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """statistic_interval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['10..600']}), is_leaf=True, yang_name="statistic-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)""",
        })

    self.__statistic_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_statistic_interval(self):
    self.__statistic_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['10..600']}), is_leaf=True, yang_name="statistic-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)


  def _get_vrf_name(self):
    """
    Getter method for vrf_name, mapped from YANG variable /ifm/interfaces/interface/vrf_name (leafref)

    YANG Description: Name of a VPN instance. It uniquely identifies a VPN instance. The VRF name of the DCN interface cannot be created, modified, or deleted.
    """
    return self.__vrf_name
      
  def _set_vrf_name(self, v, load=False):
    """
    Setter method for vrf_name, mapped from YANG variable /ifm/interfaces/interface/vrf_name (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vrf_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vrf_name() directly.

    YANG Description: Name of a VPN instance. It uniquely identifies a VPN instance. The VRF name of the DCN interface cannot be created, modified, or deleted.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, default=six.text_type("_public_"), is_leaf=True, yang_name="vrf-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vrf_name must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, default=six.text_type("_public_"), is_leaf=True, yang_name="vrf-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='leafref', is_config=True)""",
        })

    self.__vrf_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vrf_name(self):
    self.__vrf_name = YANGDynClass(base=six.text_type, default=six.text_type("_public_"), is_leaf=True, yang_name="vrf-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='leafref', is_config=True)


  def _get_l2_mode_enable(self):
    """
    Getter method for l2_mode_enable, mapped from YANG variable /ifm/interfaces/interface/l2_mode_enable (boolean)

    YANG Description: Enable/disable the function of creating an L2 Sub-interface. Capabilities supported by this node vary according to interface types.
    """
    return self.__l2_mode_enable
      
  def _set_l2_mode_enable(self, v, load=False):
    """
    Setter method for l2_mode_enable, mapped from YANG variable /ifm/interfaces/interface/l2_mode_enable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_l2_mode_enable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_l2_mode_enable() directly.

    YANG Description: Enable/disable the function of creating an L2 Sub-interface. Capabilities supported by this node vary according to interface types.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="l2-mode-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """l2_mode_enable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="l2-mode-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=True)""",
        })

    self.__l2_mode_enable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_l2_mode_enable(self):
    self.__l2_mode_enable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="l2-mode-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=True)


  def _get_down_delay_time(self):
    """
    Getter method for down_delay_time, mapped from YANG variable /ifm/interfaces/interface/down_delay_time (uint32)

    YANG Description: Specify down-delay-time value in milliseconds.
    """
    return self.__down_delay_time
      
  def _set_down_delay_time(self, v, load=False):
    """
    Setter method for down_delay_time, mapped from YANG variable /ifm/interfaces/interface/down_delay_time (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_down_delay_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_down_delay_time() directly.

    YANG Description: Specify down-delay-time value in milliseconds.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..1000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="down-delay-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """down_delay_time must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..1000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="down-delay-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)""",
        })

    self.__down_delay_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_down_delay_time(self):
    self.__down_delay_time = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..1000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="down-delay-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)


  def _get_mac_address(self):
    """
    Getter method for mac_address, mapped from YANG variable /ifm/interfaces/interface/mac_address (pub-type:mac-address)

    YANG Description: Config MAC Address. Constraints on MAC address configuration varies according to interfaces. Capabilities supported by this node vary according to interface types.
    """
    return self.__mac_address
      
  def _set_mac_address(self, v, load=False):
    """
    Setter method for mac_address, mapped from YANG variable /ifm/interfaces/interface/mac_address (pub-type:mac-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mac_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mac_address() directly.

    YANG Description: Config MAC Address. Constraints on MAC address configuration varies according to interfaces. Capabilities supported by this node vary according to interface types.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9a-f]{4}(-[0-9a-f]{4}){2}', 'length': ['0..255']}), restriction_dict={'length': ['0..255']}), is_leaf=True, yang_name="mac-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='pub-type:mac-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mac_address must be of a type compatible with pub-type:mac-address""",
          'defined-type': "pub-type:mac-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9a-f]{4}(-[0-9a-f]{4}){2}', 'length': ['0..255']}), restriction_dict={'length': ['0..255']}), is_leaf=True, yang_name="mac-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='pub-type:mac-address', is_config=True)""",
        })

    self.__mac_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mac_address(self):
    self.__mac_address = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9a-f]{4}(-[0-9a-f]{4}){2}', 'length': ['0..255']}), restriction_dict={'length': ['0..255']}), is_leaf=True, yang_name="mac-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='pub-type:mac-address', is_config=True)


  def _get_index(self):
    """
    Getter method for index, mapped from YANG variable /ifm/interfaces/interface/index (uint32)

    YANG Description: Index of an interface.
    """
    return self.__index
      
  def _set_index(self, v, load=False):
    """
    Setter method for index, mapped from YANG variable /ifm/interfaces/interface/index (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_index is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_index() directly.

    YANG Description: Index of an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """index must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)""",
        })

    self.__index = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_index(self):
    self.__index = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)


  def _get_position(self):
    """
    Getter method for position, mapped from YANG variable /ifm/interfaces/interface/position (string)

    YANG Description: Position of an interface. For example, 0/1/0. Data can be queried only on physical interfaces.
    """
    return self.__position
      
  def _set_position(self, v, load=False):
    """
    Setter method for position, mapped from YANG variable /ifm/interfaces/interface/position (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_position is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_position() directly.

    YANG Description: Position of an interface. For example, 0/1/0. Data can be queried only on physical interfaces.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..256']}), is_leaf=True, yang_name="position", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """position must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..256']}), is_leaf=True, yang_name="position", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='string', is_config=False)""",
        })

    self.__position = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_position(self):
    self.__position = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..256']}), is_leaf=True, yang_name="position", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='string', is_config=False)


  def _get_aggregation_name(self):
    """
    Getter method for aggregation_name, mapped from YANG variable /ifm/interfaces/interface/aggregation_name (pub-type:if-name)

    YANG Description: Name of an aggregation interface.
    """
    return self.__aggregation_name
      
  def _set_aggregation_name(self, v, load=False):
    """
    Setter method for aggregation_name, mapped from YANG variable /ifm/interfaces/interface/aggregation_name (pub-type:if-name)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_aggregation_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_aggregation_name() directly.

    YANG Description: Name of an aggregation interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..63']}), is_leaf=True, yang_name="aggregation-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='pub-type:if-name', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """aggregation_name must be of a type compatible with pub-type:if-name""",
          'defined-type': "pub-type:if-name",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..63']}), is_leaf=True, yang_name="aggregation-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='pub-type:if-name', is_config=False)""",
        })

    self.__aggregation_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_aggregation_name(self):
    self.__aggregation_name = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..63']}), is_leaf=True, yang_name="aggregation-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='pub-type:if-name', is_config=False)


  def _get_is_l2_switch(self):
    """
    Getter method for is_l2_switch, mapped from YANG variable /ifm/interfaces/interface/is_l2_switch (boolean)

    YANG Description: To identify a layer2 switch port.
    """
    return self.__is_l2_switch
      
  def _set_is_l2_switch(self, v, load=False):
    """
    Setter method for is_l2_switch, mapped from YANG variable /ifm/interfaces/interface/is_l2_switch (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_is_l2_switch is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_is_l2_switch() directly.

    YANG Description: To identify a layer2 switch port.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="is-l2-switch", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """is_l2_switch must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="is-l2-switch", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=False)""",
        })

    self.__is_l2_switch = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_is_l2_switch(self):
    self.__is_l2_switch = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="is-l2-switch", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=False)


  def _get_vs_name(self):
    """
    Getter method for vs_name, mapped from YANG variable /ifm/interfaces/interface/vs_name (string)

    YANG Description: Name of a VS to which an interface belongs.
    """
    return self.__vs_name
      
  def _set_vs_name(self, v, load=False):
    """
    Setter method for vs_name, mapped from YANG variable /ifm/interfaces/interface/vs_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vs_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vs_name() directly.

    YANG Description: Name of a VS to which an interface belongs.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..50']}), is_leaf=True, yang_name="vs-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vs_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..50']}), is_leaf=True, yang_name="vs-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='string', is_config=False)""",
        })

    self.__vs_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vs_name(self):
    self.__vs_name = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..50']}), is_leaf=True, yang_name="vs-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='string', is_config=False)


  def _get_l2_switch_port_index(self):
    """
    Getter method for l2_switch_port_index, mapped from YANG variable /ifm/interfaces/interface/l2_switch_port_index (uint32)

    YANG Description: L2 switch port index of an interface.
    """
    return self.__l2_switch_port_index
      
  def _set_l2_switch_port_index(self, v, load=False):
    """
    Setter method for l2_switch_port_index, mapped from YANG variable /ifm/interfaces/interface/l2_switch_port_index (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_l2_switch_port_index is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_l2_switch_port_index() directly.

    YANG Description: L2 switch port index of an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="l2-switch-port-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """l2_switch_port_index must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="l2-switch-port-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)""",
        })

    self.__l2_switch_port_index = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_l2_switch_port_index(self):
    self.__l2_switch_port_index = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="l2-switch-port-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)


  def _get_service_type(self):
    """
    Getter method for service_type, mapped from YANG variable /ifm/interfaces/interface/service_type (service-type)

    YANG Description: Type of a member interface.
    """
    return self.__service_type
      
  def _set_service_type(self, v, load=False):
    """
    Setter method for service_type, mapped from YANG variable /ifm/interfaces/interface/service_type (service-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_service_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_service_type() directly.

    YANG Description: Type of a member interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'none': {'value': 0}, 'trunk-member': {'value': 2}, 'stack-member': {'value': 6}, 'mp-member': {'value': 7}, 'vbridge-member': {'value': 8}, 'ima-member': {'value': 9}, 'bundle-member': {'value': 10}, 'fabric-member': {'value': 11}, 'lag-master-member': {'value': 12}, 'lag-slave-member': {'value': 13}, 'cpos-trunk-member': {'value': 15}, 'pos-trunk-member': {'value': 16}, 'global-mp-member': {'value': 17}, 'global-ima-member': {'value': 18}},), is_leaf=True, yang_name="service-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='service-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """service_type must be of a type compatible with service-type""",
          'defined-type': "huawei-ifm:service-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'none': {'value': 0}, 'trunk-member': {'value': 2}, 'stack-member': {'value': 6}, 'mp-member': {'value': 7}, 'vbridge-member': {'value': 8}, 'ima-member': {'value': 9}, 'bundle-member': {'value': 10}, 'fabric-member': {'value': 11}, 'lag-master-member': {'value': 12}, 'lag-slave-member': {'value': 13}, 'cpos-trunk-member': {'value': 15}, 'pos-trunk-member': {'value': 16}, 'global-mp-member': {'value': 17}, 'global-ima-member': {'value': 18}},), is_leaf=True, yang_name="service-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='service-type', is_config=False)""",
        })

    self.__service_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_service_type(self):
    self.__service_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'none': {'value': 0}, 'trunk-member': {'value': 2}, 'stack-member': {'value': 6}, 'mp-member': {'value': 7}, 'vbridge-member': {'value': 8}, 'ima-member': {'value': 9}, 'bundle-member': {'value': 10}, 'fabric-member': {'value': 11}, 'lag-master-member': {'value': 12}, 'lag-slave-member': {'value': 13}, 'cpos-trunk-member': {'value': 15}, 'pos-trunk-member': {'value': 16}, 'global-mp-member': {'value': 17}, 'global-ima-member': {'value': 18}},), is_leaf=True, yang_name="service-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='service-type', is_config=False)


  def _get_encapsulation_type(self):
    """
    Getter method for encapsulation_type, mapped from YANG variable /ifm/interfaces/interface/encapsulation_type (encapsulation-type)

    YANG Description: Effective encapsulation type.
    """
    return self.__encapsulation_type
      
  def _set_encapsulation_type(self, v, load=False):
    """
    Setter method for encapsulation_type, mapped from YANG variable /ifm/interfaces/interface/encapsulation_type (encapsulation-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_encapsulation_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_encapsulation_type() directly.

    YANG Description: Effective encapsulation type.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'vlan-type': {'value': 0}, 'dot1q': {'value': 1}, 'qinq': {'value': 2}, 'p2p': {'value': 3}, 'p2mp': {'value': 4}, 'l2ve': {'value': 5}, 'l3ve': {'value': 6}, 'vlan-type-policy': {'value': 7}, 'dot1q-policy': {'value': 8}, 'stacking-policy': {'value': 9}, 'untag-policy': {'value': 10}, 'qinq-mapping': {'value': 11}, 'l2vc': {'value': 12}, 'l3vc': {'value': 13}, 'evc-untag': {'value': 14}, 'evc-dot1q': {'value': 15}, 'evc-qinq': {'value': 16}, 'evc-default': {'value': 17}, 'evc-dot1q-policy': {'value': 18}, 'ietf': {'value': 19}, 'nonstandard': {'value': 20}, 'user-vlan': {'value': 21}, 'user-vlan-anyother': {'value': 22}, 'qin-link': {'value': 23}, 'soft-gre-ve': {'value': 24}, 'l3ve-ter': {'value': 25}, 'l3ve-acc': {'value': 26}, 'invalid': {'value': 255}},), is_leaf=True, yang_name="encapsulation-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='encapsulation-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """encapsulation_type must be of a type compatible with encapsulation-type""",
          'defined-type': "huawei-ifm:encapsulation-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'vlan-type': {'value': 0}, 'dot1q': {'value': 1}, 'qinq': {'value': 2}, 'p2p': {'value': 3}, 'p2mp': {'value': 4}, 'l2ve': {'value': 5}, 'l3ve': {'value': 6}, 'vlan-type-policy': {'value': 7}, 'dot1q-policy': {'value': 8}, 'stacking-policy': {'value': 9}, 'untag-policy': {'value': 10}, 'qinq-mapping': {'value': 11}, 'l2vc': {'value': 12}, 'l3vc': {'value': 13}, 'evc-untag': {'value': 14}, 'evc-dot1q': {'value': 15}, 'evc-qinq': {'value': 16}, 'evc-default': {'value': 17}, 'evc-dot1q-policy': {'value': 18}, 'ietf': {'value': 19}, 'nonstandard': {'value': 20}, 'user-vlan': {'value': 21}, 'user-vlan-anyother': {'value': 22}, 'qin-link': {'value': 23}, 'soft-gre-ve': {'value': 24}, 'l3ve-ter': {'value': 25}, 'l3ve-acc': {'value': 26}, 'invalid': {'value': 255}},), is_leaf=True, yang_name="encapsulation-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='encapsulation-type', is_config=False)""",
        })

    self.__encapsulation_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_encapsulation_type(self):
    self.__encapsulation_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'vlan-type': {'value': 0}, 'dot1q': {'value': 1}, 'qinq': {'value': 2}, 'p2p': {'value': 3}, 'p2mp': {'value': 4}, 'l2ve': {'value': 5}, 'l3ve': {'value': 6}, 'vlan-type-policy': {'value': 7}, 'dot1q-policy': {'value': 8}, 'stacking-policy': {'value': 9}, 'untag-policy': {'value': 10}, 'qinq-mapping': {'value': 11}, 'l2vc': {'value': 12}, 'l3vc': {'value': 13}, 'evc-untag': {'value': 14}, 'evc-dot1q': {'value': 15}, 'evc-qinq': {'value': 16}, 'evc-default': {'value': 17}, 'evc-dot1q-policy': {'value': 18}, 'ietf': {'value': 19}, 'nonstandard': {'value': 20}, 'user-vlan': {'value': 21}, 'user-vlan-anyother': {'value': 22}, 'qin-link': {'value': 23}, 'soft-gre-ve': {'value': 24}, 'l3ve-ter': {'value': 25}, 'l3ve-acc': {'value': 26}, 'invalid': {'value': 255}},), is_leaf=True, yang_name="encapsulation-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='encapsulation-type', is_config=False)


  def _get_network_layer_status(self):
    """
    Getter method for network_layer_status, mapped from YANG variable /ifm/interfaces/interface/network_layer_status (network-layer-state)

    YANG Description: Network-layer status of an interface.
    """
    return self.__network_layer_status
      
  def _set_network_layer_status(self, v, load=False):
    """
    Setter method for network_layer_status, mapped from YANG variable /ifm/interfaces/interface/network_layer_status (network-layer-state)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_network_layer_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_network_layer_status() directly.

    YANG Description: Network-layer status of an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ipv4-ipv6-up': {'value': 0}, 'ipv4-ipv6-down': {'value': 196608}},), default=six.text_type("ipv4-ipv6-up"), is_leaf=True, yang_name="network-layer-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='network-layer-state', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """network_layer_status must be of a type compatible with network-layer-state""",
          'defined-type': "huawei-ifm:network-layer-state",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ipv4-ipv6-up': {'value': 0}, 'ipv4-ipv6-down': {'value': 196608}},), default=six.text_type("ipv4-ipv6-up"), is_leaf=True, yang_name="network-layer-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='network-layer-state', is_config=True)""",
        })

    self.__network_layer_status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_network_layer_status(self):
    self.__network_layer_status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ipv4-ipv6-up': {'value': 0}, 'ipv4-ipv6-down': {'value': 196608}},), default=six.text_type("ipv4-ipv6-up"), is_leaf=True, yang_name="network-layer-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='network-layer-state', is_config=True)


  def _get_protocol_up_delay_time(self):
    """
    Getter method for protocol_up_delay_time, mapped from YANG variable /ifm/interfaces/interface/protocol_up_delay_time (uint32)

    YANG Description: Specify the protocol up-delay-time value in seconds.
    """
    return self.__protocol_up_delay_time
      
  def _set_protocol_up_delay_time(self, v, load=False):
    """
    Setter method for protocol_up_delay_time, mapped from YANG variable /ifm/interfaces/interface/protocol_up_delay_time (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_protocol_up_delay_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_protocol_up_delay_time() directly.

    YANG Description: Specify the protocol up-delay-time value in seconds.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..7200']}), is_leaf=True, yang_name="protocol-up-delay-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """protocol_up_delay_time must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..7200']}), is_leaf=True, yang_name="protocol-up-delay-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)""",
        })

    self.__protocol_up_delay_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_protocol_up_delay_time(self):
    self.__protocol_up_delay_time = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..7200']}), is_leaf=True, yang_name="protocol-up-delay-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)


  def _get_control_flap(self):
    """
    Getter method for control_flap, mapped from YANG variable /ifm/interfaces/interface/control_flap (container)

    YANG Description: Enable/disable flapping control on an interface.
    """
    return self.__control_flap
      
  def _set_control_flap(self, v, load=False):
    """
    Setter method for control_flap, mapped from YANG variable /ifm/interfaces/interface/control_flap (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_control_flap is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_control_flap() directly.

    YANG Description: Enable/disable flapping control on an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_control_flap_huawei_ifm__ifm_interfaces_interface_control_flap, is_container='container', yang_name="control-flap", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """control_flap must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_control_flap_huawei_ifm__ifm_interfaces_interface_control_flap, is_container='container', yang_name="control-flap", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)""",
        })

    self.__control_flap = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_control_flap(self):
    self.__control_flap = YANGDynClass(base=yc_control_flap_huawei_ifm__ifm_interfaces_interface_control_flap, is_container='container', yang_name="control-flap", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)


  def _get_trap_threshold(self):
    """
    Getter method for trap_threshold, mapped from YANG variable /ifm/interfaces/interface/trap_threshold (container)

    YANG Description: Configure the trap threshold.
    """
    return self.__trap_threshold
      
  def _set_trap_threshold(self, v, load=False):
    """
    Setter method for trap_threshold, mapped from YANG variable /ifm/interfaces/interface/trap_threshold (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_trap_threshold is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_trap_threshold() directly.

    YANG Description: Configure the trap threshold.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_trap_threshold_huawei_ifm__ifm_interfaces_interface_trap_threshold, is_container='container', yang_name="trap-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """trap_threshold must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_trap_threshold_huawei_ifm__ifm_interfaces_interface_trap_threshold, is_container='container', yang_name="trap-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)""",
        })

    self.__trap_threshold = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_trap_threshold(self):
    self.__trap_threshold = YANGDynClass(base=yc_trap_threshold_huawei_ifm__ifm_interfaces_interface_trap_threshold, is_container='container', yang_name="trap-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)


  def _get_ignore_damp(self):
    """
    Getter method for ignore_damp, mapped from YANG variable /ifm/interfaces/interface/ignore_damp (container)

    YANG Description: Configure an interface to ignore the global damp-interface function.
    """
    return self.__ignore_damp
      
  def _set_ignore_damp(self, v, load=False):
    """
    Setter method for ignore_damp, mapped from YANG variable /ifm/interfaces/interface/ignore_damp (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ignore_damp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ignore_damp() directly.

    YANG Description: Configure an interface to ignore the global damp-interface function.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ignore_damp_huawei_ifm__ifm_interfaces_interface_ignore_damp, is_container='container', yang_name="ignore-damp", parent=self, choice=('damping', 'ignore-damp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ignore_damp must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ignore_damp_huawei_ifm__ifm_interfaces_interface_ignore_damp, is_container='container', yang_name="ignore-damp", parent=self, choice=('damping', 'ignore-damp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)""",
        })

    self.__ignore_damp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ignore_damp(self):
    self.__ignore_damp = YANGDynClass(base=yc_ignore_damp_huawei_ifm__ifm_interfaces_interface_ignore_damp, is_container='container', yang_name="ignore-damp", parent=self, choice=('damping', 'ignore-damp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)


  def _get_damp(self):
    """
    Getter method for damp, mapped from YANG variable /ifm/interfaces/interface/damp (container)

    YANG Description: Enable/disable suppression on an interface's physical status flappings.
    """
    return self.__damp
      
  def _set_damp(self, v, load=False):
    """
    Setter method for damp, mapped from YANG variable /ifm/interfaces/interface/damp (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_damp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_damp() directly.

    YANG Description: Enable/disable suppression on an interface's physical status flappings.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_damp_huawei_ifm__ifm_interfaces_interface_damp, is_container='container', yang_name="damp", parent=self, choice=('damping', 'damp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """damp must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_damp_huawei_ifm__ifm_interfaces_interface_damp, is_container='container', yang_name="damp", parent=self, choice=('damping', 'damp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)""",
        })

    self.__damp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_damp(self):
    self.__damp = YANGDynClass(base=yc_damp_huawei_ifm__ifm_interfaces_interface_damp, is_container='container', yang_name="damp", parent=self, choice=('damping', 'damp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)


  def _get_damp_state(self):
    """
    Getter method for damp_state, mapped from YANG variable /ifm/interfaces/interface/damp_state (container)

    YANG Description: Operational state of interface suppression information.
    """
    return self.__damp_state
      
  def _set_damp_state(self, v, load=False):
    """
    Setter method for damp_state, mapped from YANG variable /ifm/interfaces/interface/damp_state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_damp_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_damp_state() directly.

    YANG Description: Operational state of interface suppression information.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_damp_state_huawei_ifm__ifm_interfaces_interface_damp_state, is_container='container', yang_name="damp-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """damp_state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_damp_state_huawei_ifm__ifm_interfaces_interface_damp_state, is_container='container', yang_name="damp-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)""",
        })

    self.__damp_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_damp_state(self):
    self.__damp_state = YANGDynClass(base=yc_damp_state_huawei_ifm__ifm_interfaces_interface_damp_state, is_container='container', yang_name="damp-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)


  def _get_dynamic(self):
    """
    Getter method for dynamic, mapped from YANG variable /ifm/interfaces/interface/dynamic (container)

    YANG Description: Operational state of interfaces.
    """
    return self.__dynamic
      
  def _set_dynamic(self, v, load=False):
    """
    Setter method for dynamic, mapped from YANG variable /ifm/interfaces/interface/dynamic (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dynamic is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dynamic() directly.

    YANG Description: Operational state of interfaces.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_dynamic_huawei_ifm__ifm_interfaces_interface_dynamic, is_container='container', yang_name="dynamic", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dynamic must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_dynamic_huawei_ifm__ifm_interfaces_interface_dynamic, is_container='container', yang_name="dynamic", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)""",
        })

    self.__dynamic = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dynamic(self):
    self.__dynamic = YANGDynClass(base=yc_dynamic_huawei_ifm__ifm_interfaces_interface_dynamic, is_container='container', yang_name="dynamic", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)


  def _get_mib_statistics(self):
    """
    Getter method for mib_statistics, mapped from YANG variable /ifm/interfaces/interface/mib_statistics (container)

    YANG Description: Interface statistics.
    """
    return self.__mib_statistics
      
  def _set_mib_statistics(self, v, load=False):
    """
    Setter method for mib_statistics, mapped from YANG variable /ifm/interfaces/interface/mib_statistics (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mib_statistics is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mib_statistics() directly.

    YANG Description: Interface statistics.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_mib_statistics_huawei_ifm__ifm_interfaces_interface_mib_statistics, is_container='container', yang_name="mib-statistics", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mib_statistics must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_mib_statistics_huawei_ifm__ifm_interfaces_interface_mib_statistics, is_container='container', yang_name="mib-statistics", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)""",
        })

    self.__mib_statistics = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mib_statistics(self):
    self.__mib_statistics = YANGDynClass(base=yc_mib_statistics_huawei_ifm__ifm_interfaces_interface_mib_statistics, is_container='container', yang_name="mib-statistics", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)


  def _get_common_statistics(self):
    """
    Getter method for common_statistics, mapped from YANG variable /ifm/interfaces/interface/common_statistics (container)

    YANG Description: Interface statistics.
    """
    return self.__common_statistics
      
  def _set_common_statistics(self, v, load=False):
    """
    Setter method for common_statistics, mapped from YANG variable /ifm/interfaces/interface/common_statistics (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_common_statistics is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_common_statistics() directly.

    YANG Description: Interface statistics.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_common_statistics_huawei_ifm__ifm_interfaces_interface_common_statistics, is_container='container', yang_name="common-statistics", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """common_statistics must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_common_statistics_huawei_ifm__ifm_interfaces_interface_common_statistics, is_container='container', yang_name="common-statistics", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)""",
        })

    self.__common_statistics = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_common_statistics(self):
    self.__common_statistics = YANGDynClass(base=yc_common_statistics_huawei_ifm__ifm_interfaces_interface_common_statistics, is_container='container', yang_name="common-statistics", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)


  def _get_error_down(self):
    """
    Getter method for error_down, mapped from YANG variable /ifm/interfaces/interface/error_down (container)

    YANG Description: Information about the interface in the error-down state, including the interface name, cause of the error-down event, delay for the transition from down to up, and remaining time for the up state.
    """
    return self.__error_down
      
  def _set_error_down(self, v, load=False):
    """
    Setter method for error_down, mapped from YANG variable /ifm/interfaces/interface/error_down (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_error_down is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_error_down() directly.

    YANG Description: Information about the interface in the error-down state, including the interface name, cause of the error-down event, delay for the transition from down to up, and remaining time for the up state.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_error_down_huawei_ifm__ifm_interfaces_interface_error_down, is_container='container', yang_name="error-down", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """error_down must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_error_down_huawei_ifm__ifm_interfaces_interface_error_down, is_container='container', yang_name="error-down", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)""",
        })

    self.__error_down = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_error_down(self):
    self.__error_down = YANGDynClass(base=yc_error_down_huawei_ifm__ifm_interfaces_interface_error_down, is_container='container', yang_name="error-down", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  class_ = __builtin__.property(_get_class_, _set_class_)
  type = __builtin__.property(_get_type, _set_type)
  parent_name = __builtin__.property(_get_parent_name, _set_parent_name)
  number = __builtin__.property(_get_number, _set_number)
  description = __builtin__.property(_get_description, _set_description)
  admin_status = __builtin__.property(_get_admin_status, _set_admin_status)
  link_protocol = __builtin__.property(_get_link_protocol, _set_link_protocol)
  router_type = __builtin__.property(_get_router_type, _set_router_type)
  clear_ip_df = __builtin__.property(_get_clear_ip_df, _set_clear_ip_df)
  link_up_down_trap_enable = __builtin__.property(_get_link_up_down_trap_enable, _set_link_up_down_trap_enable)
  statistic_enable = __builtin__.property(_get_statistic_enable, _set_statistic_enable)
  statistic_mode = __builtin__.property(_get_statistic_mode, _set_statistic_mode)
  bandwidth = __builtin__.property(_get_bandwidth, _set_bandwidth)
  bandwidth_kbps = __builtin__.property(_get_bandwidth_kbps, _set_bandwidth_kbps)
  mtu = __builtin__.property(_get_mtu, _set_mtu)
  spread_mtu_flag = __builtin__.property(_get_spread_mtu_flag, _set_spread_mtu_flag)
  statistic_interval = __builtin__.property(_get_statistic_interval, _set_statistic_interval)
  vrf_name = __builtin__.property(_get_vrf_name, _set_vrf_name)
  l2_mode_enable = __builtin__.property(_get_l2_mode_enable, _set_l2_mode_enable)
  down_delay_time = __builtin__.property(_get_down_delay_time, _set_down_delay_time)
  mac_address = __builtin__.property(_get_mac_address, _set_mac_address)
  index = __builtin__.property(_get_index)
  position = __builtin__.property(_get_position)
  aggregation_name = __builtin__.property(_get_aggregation_name)
  is_l2_switch = __builtin__.property(_get_is_l2_switch)
  vs_name = __builtin__.property(_get_vs_name)
  l2_switch_port_index = __builtin__.property(_get_l2_switch_port_index)
  service_type = __builtin__.property(_get_service_type)
  encapsulation_type = __builtin__.property(_get_encapsulation_type)
  network_layer_status = __builtin__.property(_get_network_layer_status, _set_network_layer_status)
  protocol_up_delay_time = __builtin__.property(_get_protocol_up_delay_time, _set_protocol_up_delay_time)
  control_flap = __builtin__.property(_get_control_flap, _set_control_flap) # type: yc_control_flap_huawei_ifm__ifm_interfaces_interface_control_flap
  trap_threshold = __builtin__.property(_get_trap_threshold, _set_trap_threshold) # type: yc_trap_threshold_huawei_ifm__ifm_interfaces_interface_trap_threshold
  ignore_damp = __builtin__.property(_get_ignore_damp, _set_ignore_damp) # type: yc_ignore_damp_huawei_ifm__ifm_interfaces_interface_ignore_damp
  damp = __builtin__.property(_get_damp, _set_damp) # type: yc_damp_huawei_ifm__ifm_interfaces_interface_damp
  damp_state = __builtin__.property(_get_damp_state, _set_damp_state) # type: yc_damp_state_huawei_ifm__ifm_interfaces_interface_damp_state
  dynamic = __builtin__.property(_get_dynamic, _set_dynamic) # type: yc_dynamic_huawei_ifm__ifm_interfaces_interface_dynamic
  mib_statistics = __builtin__.property(_get_mib_statistics, _set_mib_statistics) # type: yc_mib_statistics_huawei_ifm__ifm_interfaces_interface_mib_statistics
  common_statistics = __builtin__.property(_get_common_statistics, _set_common_statistics) # type: yc_common_statistics_huawei_ifm__ifm_interfaces_interface_common_statistics
  error_down = __builtin__.property(_get_error_down, _set_error_down) # type: yc_error_down_huawei_ifm__ifm_interfaces_interface_error_down

  __choices__ = {'bandwidth-type': {'bandwidth-mbps': ['bandwidth'], 'bandwidth-kbps': ['bandwidth_kbps']}, 'damping': {'ignore-damp': ['ignore_damp'], 'damp': ['damp']}}
  _pyangbind_elements = OrderedDict([('name', name), ('class_', class_), ('type', type), ('parent_name', parent_name), ('number', number), ('description', description), ('admin_status', admin_status), ('link_protocol', link_protocol), ('router_type', router_type), ('clear_ip_df', clear_ip_df), ('link_up_down_trap_enable', link_up_down_trap_enable), ('statistic_enable', statistic_enable), ('statistic_mode', statistic_mode), ('bandwidth', bandwidth), ('bandwidth_kbps', bandwidth_kbps), ('mtu', mtu), ('spread_mtu_flag', spread_mtu_flag), ('statistic_interval', statistic_interval), ('vrf_name', vrf_name), ('l2_mode_enable', l2_mode_enable), ('down_delay_time', down_delay_time), ('mac_address', mac_address), ('index', index), ('position', position), ('aggregation_name', aggregation_name), ('is_l2_switch', is_l2_switch), ('vs_name', vs_name), ('l2_switch_port_index', l2_switch_port_index), ('service_type', service_type), ('encapsulation_type', encapsulation_type), ('network_layer_status', network_layer_status), ('protocol_up_delay_time', protocol_up_delay_time), ('control_flap', control_flap), ('trap_threshold', trap_threshold), ('ignore_damp', ignore_damp), ('damp', damp), ('damp_state', damp_state), ('dynamic', dynamic), ('mib_statistics', mib_statistics), ('common_statistics', common_statistics), ('error_down', error_down), ])


class yc_interfaces_huawei_ifm__ifm_interfaces(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-ifm - based on the path /ifm/interfaces. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of configuring information on an interface.
  """
  __slots__ = ('_path_helper', '_extmethods', '__interface',)

  _yang_name = 'interfaces'
  _yang_namespace = 'urn:huawei:yang:huawei-ifm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__interface = YANGDynClass(base=YANGListType("name",yc_interface_huawei_ifm__ifm_interfaces_interface, yang_name="interface", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ifm', 'interfaces']

  def _get_interface(self):
    """
    Getter method for interface, mapped from YANG variable /ifm/interfaces/interface (list)

    YANG Description: Configure information on an interface. Physical, NULL, Virtual-if, and Virtual-Template0 interfaces cannot be created or deleted.
    """
    return self.__interface
      
  def _set_interface(self, v, load=False):
    """
    Setter method for interface, mapped from YANG variable /ifm/interfaces/interface (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface() directly.

    YANG Description: Configure information on an interface. Physical, NULL, Virtual-if, and Virtual-Template0 interfaces cannot be created or deleted.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_interface_huawei_ifm__ifm_interfaces_interface, yang_name="interface", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_interface_huawei_ifm__ifm_interfaces_interface, yang_name="interface", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='list', is_config=True)""",
        })

    self.__interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface(self):
    self.__interface = YANGDynClass(base=YANGListType("name",yc_interface_huawei_ifm__ifm_interfaces_interface, yang_name="interface", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='list', is_config=True)

  interface = __builtin__.property(_get_interface, _set_interface) # type: yc_interface_huawei_ifm__ifm_interfaces_interface


  _pyangbind_elements = OrderedDict([('interface', interface), ])


class yc_static_dimension_range_huawei_ifm__ifm_static_dimension_ranges_static_dimension_range(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-ifm - based on the path /ifm/static-dimension-ranges/static-dimension-range. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Statistics of Interface dimensionality.
  """
  __slots__ = ('_path_helper', '_extmethods', '__type','__chassis_range','__slot_range','__card_range','__port_range',)

  _yang_name = 'static-dimension-range'
  _yang_namespace = 'urn:huawei:yang:huawei-ifm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'Ethernet': {'value': 0}, 'GigabitEthernet': {'value': 2}, 'Eth-Trunk': {'value': 4}, 'Ip-Trunk': {'value': 5}, 'Pos': {'value': 9}, 'Tunnel': {'value': 14}, 'NULL': {'value': 18}, 'LoopBack': {'value': 19}, 'Vlanif': {'value': 15}, '100GE': {'value': 20}, '200GE': {'value': 92}, '40GE': {'value': 23}, 'MTunnel': {'value': 22}, '10GE': {'value': 24}, 'GEBrief': {'value': 25}, 'MEth': {'value': 26}, 'IMEth': {'value': 79}, 'Stack-Port': {'value': 27}, 'Sip': {'value': 28}, 'Cpos': {'value': 10}, 'E1': {'value': 30}, 'Serial': {'value': 8}, 'Mp-group': {'value': 31}, 'Virtual-Ethernet': {'value': 6}, 'VMEth': {'value': 33}, 'Ima-group': {'value': 32}, 'Remote-Ap': {'value': 35}, 'VBridge': {'value': 36}, 'Atm-Bundle': {'value': 37}, 'Fiber-Channel': {'value': 38}, 'Infiniband': {'value': 39}, 'Lmpif': {'value': 21}, 'T1': {'value': 41}, 'T3': {'value': 42}, 'Global-VE': {'value': 45}, 'VC4': {'value': 43}, 'VC12': {'value': 44}, 'Vbdif': {'value': 40}, 'Fabric-Port': {'value': 46}, 'E3': {'value': 48}, 'Otn': {'value': 55}, 'Vp': {'value': 49}, 'DcnInterface': {'value': 50}, 'Cpos-Trunk': {'value': 51}, 'Pos-Trunk': {'value': 59}, 'Trunk-Serial': {'value': 52}, 'Global-Ima-Group': {'value': 57}, 'Global-Mp-Group': {'value': 53}, 'Gmpls-Uni': {'value': 63}, 'Wdm': {'value': 64}, 'Nve': {'value': 65}, 'FCoE-Port': {'value': 67}, 'Virtual-Template': {'value': 68}, 'FC': {'value': 70}, '4x10GE': {'value': 71}, '10x10GE': {'value': 72}, '3x40GE': {'value': 73}, '4x25GE': {'value': 74}, '25GE': {'value': 75}, 'ATM': {'value': 11}, 'XGigabitEthernet': {'value': 91}, 'ServiceIf': {'value': 90}, 'Virtual-ODUk': {'value': 94}, 'FlexE': {'value': 95}, 'FlexE-200GE': {'value': 96}, '50|100GE': {'value': 101}, '50GE': {'value': 102}, 'FlexE-50G': {'value': 103}, 'FlexE-100G': {'value': 104}, 'FlexE-50|100G': {'value': 105}, 'PW-VE': {'value': 88}, 'Virtual-Serial': {'value': 107}, '400GE': {'value': 108}, 'VX-Tunnel': {'value': 89}, 'HPGE': {'value': 114}, 'Virtual-if': {'value': 116}, 'Cellular': {'value': 117}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='port-type', is_config=False)
    self.__chassis_range = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..63']}), is_leaf=True, yang_name="chassis-range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='string', is_config=False)
    self.__slot_range = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..63']}), is_leaf=True, yang_name="slot-range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='string', is_config=False)
    self.__card_range = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..63']}), is_leaf=True, yang_name="card-range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='string', is_config=False)
    self.__port_range = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..63']}), is_leaf=True, yang_name="port-range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='string', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ifm', 'static-dimension-ranges', 'static-dimension-range']

  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /ifm/static_dimension_ranges/static_dimension_range/type (port-type)

    YANG Description: Interface type.
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /ifm/static_dimension_ranges/static_dimension_range/type (port-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: Interface type.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'Ethernet': {'value': 0}, 'GigabitEthernet': {'value': 2}, 'Eth-Trunk': {'value': 4}, 'Ip-Trunk': {'value': 5}, 'Pos': {'value': 9}, 'Tunnel': {'value': 14}, 'NULL': {'value': 18}, 'LoopBack': {'value': 19}, 'Vlanif': {'value': 15}, '100GE': {'value': 20}, '200GE': {'value': 92}, '40GE': {'value': 23}, 'MTunnel': {'value': 22}, '10GE': {'value': 24}, 'GEBrief': {'value': 25}, 'MEth': {'value': 26}, 'IMEth': {'value': 79}, 'Stack-Port': {'value': 27}, 'Sip': {'value': 28}, 'Cpos': {'value': 10}, 'E1': {'value': 30}, 'Serial': {'value': 8}, 'Mp-group': {'value': 31}, 'Virtual-Ethernet': {'value': 6}, 'VMEth': {'value': 33}, 'Ima-group': {'value': 32}, 'Remote-Ap': {'value': 35}, 'VBridge': {'value': 36}, 'Atm-Bundle': {'value': 37}, 'Fiber-Channel': {'value': 38}, 'Infiniband': {'value': 39}, 'Lmpif': {'value': 21}, 'T1': {'value': 41}, 'T3': {'value': 42}, 'Global-VE': {'value': 45}, 'VC4': {'value': 43}, 'VC12': {'value': 44}, 'Vbdif': {'value': 40}, 'Fabric-Port': {'value': 46}, 'E3': {'value': 48}, 'Otn': {'value': 55}, 'Vp': {'value': 49}, 'DcnInterface': {'value': 50}, 'Cpos-Trunk': {'value': 51}, 'Pos-Trunk': {'value': 59}, 'Trunk-Serial': {'value': 52}, 'Global-Ima-Group': {'value': 57}, 'Global-Mp-Group': {'value': 53}, 'Gmpls-Uni': {'value': 63}, 'Wdm': {'value': 64}, 'Nve': {'value': 65}, 'FCoE-Port': {'value': 67}, 'Virtual-Template': {'value': 68}, 'FC': {'value': 70}, '4x10GE': {'value': 71}, '10x10GE': {'value': 72}, '3x40GE': {'value': 73}, '4x25GE': {'value': 74}, '25GE': {'value': 75}, 'ATM': {'value': 11}, 'XGigabitEthernet': {'value': 91}, 'ServiceIf': {'value': 90}, 'Virtual-ODUk': {'value': 94}, 'FlexE': {'value': 95}, 'FlexE-200GE': {'value': 96}, '50|100GE': {'value': 101}, '50GE': {'value': 102}, 'FlexE-50G': {'value': 103}, 'FlexE-100G': {'value': 104}, 'FlexE-50|100G': {'value': 105}, 'PW-VE': {'value': 88}, 'Virtual-Serial': {'value': 107}, '400GE': {'value': 108}, 'VX-Tunnel': {'value': 89}, 'HPGE': {'value': 114}, 'Virtual-if': {'value': 116}, 'Cellular': {'value': 117}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='port-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with port-type""",
          'defined-type': "huawei-ifm:port-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'Ethernet': {'value': 0}, 'GigabitEthernet': {'value': 2}, 'Eth-Trunk': {'value': 4}, 'Ip-Trunk': {'value': 5}, 'Pos': {'value': 9}, 'Tunnel': {'value': 14}, 'NULL': {'value': 18}, 'LoopBack': {'value': 19}, 'Vlanif': {'value': 15}, '100GE': {'value': 20}, '200GE': {'value': 92}, '40GE': {'value': 23}, 'MTunnel': {'value': 22}, '10GE': {'value': 24}, 'GEBrief': {'value': 25}, 'MEth': {'value': 26}, 'IMEth': {'value': 79}, 'Stack-Port': {'value': 27}, 'Sip': {'value': 28}, 'Cpos': {'value': 10}, 'E1': {'value': 30}, 'Serial': {'value': 8}, 'Mp-group': {'value': 31}, 'Virtual-Ethernet': {'value': 6}, 'VMEth': {'value': 33}, 'Ima-group': {'value': 32}, 'Remote-Ap': {'value': 35}, 'VBridge': {'value': 36}, 'Atm-Bundle': {'value': 37}, 'Fiber-Channel': {'value': 38}, 'Infiniband': {'value': 39}, 'Lmpif': {'value': 21}, 'T1': {'value': 41}, 'T3': {'value': 42}, 'Global-VE': {'value': 45}, 'VC4': {'value': 43}, 'VC12': {'value': 44}, 'Vbdif': {'value': 40}, 'Fabric-Port': {'value': 46}, 'E3': {'value': 48}, 'Otn': {'value': 55}, 'Vp': {'value': 49}, 'DcnInterface': {'value': 50}, 'Cpos-Trunk': {'value': 51}, 'Pos-Trunk': {'value': 59}, 'Trunk-Serial': {'value': 52}, 'Global-Ima-Group': {'value': 57}, 'Global-Mp-Group': {'value': 53}, 'Gmpls-Uni': {'value': 63}, 'Wdm': {'value': 64}, 'Nve': {'value': 65}, 'FCoE-Port': {'value': 67}, 'Virtual-Template': {'value': 68}, 'FC': {'value': 70}, '4x10GE': {'value': 71}, '10x10GE': {'value': 72}, '3x40GE': {'value': 73}, '4x25GE': {'value': 74}, '25GE': {'value': 75}, 'ATM': {'value': 11}, 'XGigabitEthernet': {'value': 91}, 'ServiceIf': {'value': 90}, 'Virtual-ODUk': {'value': 94}, 'FlexE': {'value': 95}, 'FlexE-200GE': {'value': 96}, '50|100GE': {'value': 101}, '50GE': {'value': 102}, 'FlexE-50G': {'value': 103}, 'FlexE-100G': {'value': 104}, 'FlexE-50|100G': {'value': 105}, 'PW-VE': {'value': 88}, 'Virtual-Serial': {'value': 107}, '400GE': {'value': 108}, 'VX-Tunnel': {'value': 89}, 'HPGE': {'value': 114}, 'Virtual-if': {'value': 116}, 'Cellular': {'value': 117}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='port-type', is_config=False)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'Ethernet': {'value': 0}, 'GigabitEthernet': {'value': 2}, 'Eth-Trunk': {'value': 4}, 'Ip-Trunk': {'value': 5}, 'Pos': {'value': 9}, 'Tunnel': {'value': 14}, 'NULL': {'value': 18}, 'LoopBack': {'value': 19}, 'Vlanif': {'value': 15}, '100GE': {'value': 20}, '200GE': {'value': 92}, '40GE': {'value': 23}, 'MTunnel': {'value': 22}, '10GE': {'value': 24}, 'GEBrief': {'value': 25}, 'MEth': {'value': 26}, 'IMEth': {'value': 79}, 'Stack-Port': {'value': 27}, 'Sip': {'value': 28}, 'Cpos': {'value': 10}, 'E1': {'value': 30}, 'Serial': {'value': 8}, 'Mp-group': {'value': 31}, 'Virtual-Ethernet': {'value': 6}, 'VMEth': {'value': 33}, 'Ima-group': {'value': 32}, 'Remote-Ap': {'value': 35}, 'VBridge': {'value': 36}, 'Atm-Bundle': {'value': 37}, 'Fiber-Channel': {'value': 38}, 'Infiniband': {'value': 39}, 'Lmpif': {'value': 21}, 'T1': {'value': 41}, 'T3': {'value': 42}, 'Global-VE': {'value': 45}, 'VC4': {'value': 43}, 'VC12': {'value': 44}, 'Vbdif': {'value': 40}, 'Fabric-Port': {'value': 46}, 'E3': {'value': 48}, 'Otn': {'value': 55}, 'Vp': {'value': 49}, 'DcnInterface': {'value': 50}, 'Cpos-Trunk': {'value': 51}, 'Pos-Trunk': {'value': 59}, 'Trunk-Serial': {'value': 52}, 'Global-Ima-Group': {'value': 57}, 'Global-Mp-Group': {'value': 53}, 'Gmpls-Uni': {'value': 63}, 'Wdm': {'value': 64}, 'Nve': {'value': 65}, 'FCoE-Port': {'value': 67}, 'Virtual-Template': {'value': 68}, 'FC': {'value': 70}, '4x10GE': {'value': 71}, '10x10GE': {'value': 72}, '3x40GE': {'value': 73}, '4x25GE': {'value': 74}, '25GE': {'value': 75}, 'ATM': {'value': 11}, 'XGigabitEthernet': {'value': 91}, 'ServiceIf': {'value': 90}, 'Virtual-ODUk': {'value': 94}, 'FlexE': {'value': 95}, 'FlexE-200GE': {'value': 96}, '50|100GE': {'value': 101}, '50GE': {'value': 102}, 'FlexE-50G': {'value': 103}, 'FlexE-100G': {'value': 104}, 'FlexE-50|100G': {'value': 105}, 'PW-VE': {'value': 88}, 'Virtual-Serial': {'value': 107}, '400GE': {'value': 108}, 'VX-Tunnel': {'value': 89}, 'HPGE': {'value': 114}, 'Virtual-if': {'value': 116}, 'Cellular': {'value': 117}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='port-type', is_config=False)


  def _get_chassis_range(self):
    """
    Getter method for chassis_range, mapped from YANG variable /ifm/static_dimension_ranges/static_dimension_range/chassis_range (string)

    YANG Description: The range of chassis.
    """
    return self.__chassis_range
      
  def _set_chassis_range(self, v, load=False):
    """
    Setter method for chassis_range, mapped from YANG variable /ifm/static_dimension_ranges/static_dimension_range/chassis_range (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_chassis_range is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_chassis_range() directly.

    YANG Description: The range of chassis.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..63']}), is_leaf=True, yang_name="chassis-range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """chassis_range must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..63']}), is_leaf=True, yang_name="chassis-range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='string', is_config=False)""",
        })

    self.__chassis_range = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_chassis_range(self):
    self.__chassis_range = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..63']}), is_leaf=True, yang_name="chassis-range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='string', is_config=False)


  def _get_slot_range(self):
    """
    Getter method for slot_range, mapped from YANG variable /ifm/static_dimension_ranges/static_dimension_range/slot_range (string)

    YANG Description: The range of slot.
    """
    return self.__slot_range
      
  def _set_slot_range(self, v, load=False):
    """
    Setter method for slot_range, mapped from YANG variable /ifm/static_dimension_ranges/static_dimension_range/slot_range (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_slot_range is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_slot_range() directly.

    YANG Description: The range of slot.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..63']}), is_leaf=True, yang_name="slot-range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """slot_range must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..63']}), is_leaf=True, yang_name="slot-range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='string', is_config=False)""",
        })

    self.__slot_range = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_slot_range(self):
    self.__slot_range = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..63']}), is_leaf=True, yang_name="slot-range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='string', is_config=False)


  def _get_card_range(self):
    """
    Getter method for card_range, mapped from YANG variable /ifm/static_dimension_ranges/static_dimension_range/card_range (string)

    YANG Description: The range of card.
    """
    return self.__card_range
      
  def _set_card_range(self, v, load=False):
    """
    Setter method for card_range, mapped from YANG variable /ifm/static_dimension_ranges/static_dimension_range/card_range (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_card_range is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_card_range() directly.

    YANG Description: The range of card.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..63']}), is_leaf=True, yang_name="card-range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """card_range must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..63']}), is_leaf=True, yang_name="card-range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='string', is_config=False)""",
        })

    self.__card_range = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_card_range(self):
    self.__card_range = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..63']}), is_leaf=True, yang_name="card-range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='string', is_config=False)


  def _get_port_range(self):
    """
    Getter method for port_range, mapped from YANG variable /ifm/static_dimension_ranges/static_dimension_range/port_range (string)

    YANG Description: The range of port.
    """
    return self.__port_range
      
  def _set_port_range(self, v, load=False):
    """
    Setter method for port_range, mapped from YANG variable /ifm/static_dimension_ranges/static_dimension_range/port_range (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_port_range is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_port_range() directly.

    YANG Description: The range of port.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..63']}), is_leaf=True, yang_name="port-range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """port_range must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..63']}), is_leaf=True, yang_name="port-range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='string', is_config=False)""",
        })

    self.__port_range = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_port_range(self):
    self.__port_range = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..63']}), is_leaf=True, yang_name="port-range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='string', is_config=False)

  type = __builtin__.property(_get_type)
  chassis_range = __builtin__.property(_get_chassis_range)
  slot_range = __builtin__.property(_get_slot_range)
  card_range = __builtin__.property(_get_card_range)
  port_range = __builtin__.property(_get_port_range)


  _pyangbind_elements = OrderedDict([('type', type), ('chassis_range', chassis_range), ('slot_range', slot_range), ('card_range', card_range), ('port_range', port_range), ])


class yc_static_dimension_ranges_huawei_ifm__ifm_static_dimension_ranges(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-ifm - based on the path /ifm/static-dimension-ranges. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of interface dimensionality.
  """
  __slots__ = ('_path_helper', '_extmethods', '__static_dimension_range',)

  _yang_name = 'static-dimension-ranges'
  _yang_namespace = 'urn:huawei:yang:huawei-ifm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__static_dimension_range = YANGDynClass(base=YANGListType("type",yc_static_dimension_range_huawei_ifm__ifm_static_dimension_ranges_static_dimension_range, yang_name="static-dimension-range", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='type', extensions=None), is_container='list', yang_name="static-dimension-range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ifm', 'static-dimension-ranges']

  def _get_static_dimension_range(self):
    """
    Getter method for static_dimension_range, mapped from YANG variable /ifm/static_dimension_ranges/static_dimension_range (list)

    YANG Description: Statistics of Interface dimensionality.
    """
    return self.__static_dimension_range
      
  def _set_static_dimension_range(self, v, load=False):
    """
    Setter method for static_dimension_range, mapped from YANG variable /ifm/static_dimension_ranges/static_dimension_range (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_static_dimension_range is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_static_dimension_range() directly.

    YANG Description: Statistics of Interface dimensionality.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("type",yc_static_dimension_range_huawei_ifm__ifm_static_dimension_ranges_static_dimension_range, yang_name="static-dimension-range", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='type', extensions=None), is_container='list', yang_name="static-dimension-range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """static_dimension_range must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("type",yc_static_dimension_range_huawei_ifm__ifm_static_dimension_ranges_static_dimension_range, yang_name="static-dimension-range", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='type', extensions=None), is_container='list', yang_name="static-dimension-range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='list', is_config=False)""",
        })

    self.__static_dimension_range = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_static_dimension_range(self):
    self.__static_dimension_range = YANGDynClass(base=YANGListType("type",yc_static_dimension_range_huawei_ifm__ifm_static_dimension_ranges_static_dimension_range, yang_name="static-dimension-range", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='type', extensions=None), is_container='list', yang_name="static-dimension-range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='list', is_config=False)

  static_dimension_range = __builtin__.property(_get_static_dimension_range) # type: yc_static_dimension_range_huawei_ifm__ifm_static_dimension_ranges_static_dimension_range


  _pyangbind_elements = OrderedDict([('static_dimension_range', static_dimension_range), ])


class yc_ipv4_interface_count_huawei_ifm__ifm_ipv4_interface_count(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-ifm - based on the path /ifm/ipv4-interface-count. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Statistics of interfaces supporting IPv4 address configuration.
  """
  __slots__ = ('_path_helper', '_extmethods', '__physical_up_count','__physical_down_count','__protocol_up_count','__protocol_down_count',)

  _yang_name = 'ipv4-interface-count'
  _yang_namespace = 'urn:huawei:yang:huawei-ifm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__physical_up_count = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="physical-up-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)
    self.__physical_down_count = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="physical-down-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)
    self.__protocol_up_count = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="protocol-up-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)
    self.__protocol_down_count = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="protocol-down-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ifm', 'ipv4-interface-count']

  def _get_physical_up_count(self):
    """
    Getter method for physical_up_count, mapped from YANG variable /ifm/ipv4_interface_count/physical_up_count (uint32)

    YANG Description: Number of IPv4 interfaces that are in the physical up state.
    """
    return self.__physical_up_count
      
  def _set_physical_up_count(self, v, load=False):
    """
    Setter method for physical_up_count, mapped from YANG variable /ifm/ipv4_interface_count/physical_up_count (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_physical_up_count is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_physical_up_count() directly.

    YANG Description: Number of IPv4 interfaces that are in the physical up state.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="physical-up-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """physical_up_count must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="physical-up-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)""",
        })

    self.__physical_up_count = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_physical_up_count(self):
    self.__physical_up_count = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="physical-up-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)


  def _get_physical_down_count(self):
    """
    Getter method for physical_down_count, mapped from YANG variable /ifm/ipv4_interface_count/physical_down_count (uint32)

    YANG Description: Number of IPv4 interfaces that are in the physical down state.
    """
    return self.__physical_down_count
      
  def _set_physical_down_count(self, v, load=False):
    """
    Setter method for physical_down_count, mapped from YANG variable /ifm/ipv4_interface_count/physical_down_count (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_physical_down_count is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_physical_down_count() directly.

    YANG Description: Number of IPv4 interfaces that are in the physical down state.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="physical-down-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """physical_down_count must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="physical-down-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)""",
        })

    self.__physical_down_count = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_physical_down_count(self):
    self.__physical_down_count = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="physical-down-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)


  def _get_protocol_up_count(self):
    """
    Getter method for protocol_up_count, mapped from YANG variable /ifm/ipv4_interface_count/protocol_up_count (uint32)

    YANG Description: Number of IPv4 interfaces that are in the protocol up state.
    """
    return self.__protocol_up_count
      
  def _set_protocol_up_count(self, v, load=False):
    """
    Setter method for protocol_up_count, mapped from YANG variable /ifm/ipv4_interface_count/protocol_up_count (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_protocol_up_count is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_protocol_up_count() directly.

    YANG Description: Number of IPv4 interfaces that are in the protocol up state.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="protocol-up-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """protocol_up_count must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="protocol-up-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)""",
        })

    self.__protocol_up_count = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_protocol_up_count(self):
    self.__protocol_up_count = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="protocol-up-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)


  def _get_protocol_down_count(self):
    """
    Getter method for protocol_down_count, mapped from YANG variable /ifm/ipv4_interface_count/protocol_down_count (uint32)

    YANG Description: Number of IPv4 interfaces that are in the protocol down state.
    """
    return self.__protocol_down_count
      
  def _set_protocol_down_count(self, v, load=False):
    """
    Setter method for protocol_down_count, mapped from YANG variable /ifm/ipv4_interface_count/protocol_down_count (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_protocol_down_count is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_protocol_down_count() directly.

    YANG Description: Number of IPv4 interfaces that are in the protocol down state.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="protocol-down-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """protocol_down_count must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="protocol-down-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)""",
        })

    self.__protocol_down_count = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_protocol_down_count(self):
    self.__protocol_down_count = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="protocol-down-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)

  physical_up_count = __builtin__.property(_get_physical_up_count)
  physical_down_count = __builtin__.property(_get_physical_down_count)
  protocol_up_count = __builtin__.property(_get_protocol_up_count)
  protocol_down_count = __builtin__.property(_get_protocol_down_count)


  _pyangbind_elements = OrderedDict([('physical_up_count', physical_up_count), ('physical_down_count', physical_down_count), ('protocol_up_count', protocol_up_count), ('protocol_down_count', protocol_down_count), ])


class yc_remote_statistics_state_huawei_ifm__ifm_remote_interfaces_remote_interface_remote_statistics_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-ifm - based on the path /ifm/remote-interfaces/remote-interface/remote-statistics-state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Statistics of remote interfaces.
  """
  __slots__ = ('_path_helper', '_extmethods', '__last_cleared_time','__in_bit_rate','__in_packet_rate','__in_peak_bit_rate','__in_peak_bit_rate_record_time','__out_bit_rate','__out_packet_rate','__out_peak_bit_rate','__out_peak_bit_rate_record_time','__in_use_rate','__out_use_rate',)

  _yang_name = 'remote-statistics-state'
  _yang_namespace = 'urn:huawei:yang:huawei-ifm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__last_cleared_time = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{1,2}:\\d{1,2}:\\d{1,2}'}), is_leaf=True, yang_name="last-cleared-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='pub-type:time', is_config=False)
    self.__in_bit_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-bit-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    self.__in_packet_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-packet-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    self.__in_peak_bit_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-peak-bit-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    self.__in_peak_bit_rate_record_time = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{1,2}:\\d{1,2}:\\d{1,2}'}), is_leaf=True, yang_name="in-peak-bit-rate-record-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='pub-type:time', is_config=False)
    self.__out_bit_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-bit-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    self.__out_packet_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-packet-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    self.__out_peak_bit_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-peak-bit-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    self.__out_peak_bit_rate_record_time = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{1,2}:\\d{1,2}:\\d{1,2}'}), is_leaf=True, yang_name="out-peak-bit-rate-record-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='pub-type:time', is_config=False)
    self.__in_use_rate = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..50']}), is_leaf=True, yang_name="in-use-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='string', is_config=False)
    self.__out_use_rate = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..50']}), is_leaf=True, yang_name="out-use-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='string', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ifm', 'remote-interfaces', 'remote-interface', 'remote-statistics-state']

  def _get_last_cleared_time(self):
    """
    Getter method for last_cleared_time, mapped from YANG variable /ifm/remote_interfaces/remote_interface/remote_statistics_state/last_cleared_time (pub-type:time)

    YANG Description: Last time when statistics about remote interfaces were cleared.
    """
    return self.__last_cleared_time
      
  def _set_last_cleared_time(self, v, load=False):
    """
    Setter method for last_cleared_time, mapped from YANG variable /ifm/remote_interfaces/remote_interface/remote_statistics_state/last_cleared_time (pub-type:time)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_last_cleared_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_last_cleared_time() directly.

    YANG Description: Last time when statistics about remote interfaces were cleared.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{1,2}:\\d{1,2}:\\d{1,2}'}), is_leaf=True, yang_name="last-cleared-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='pub-type:time', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """last_cleared_time must be of a type compatible with pub-type:time""",
          'defined-type': "pub-type:time",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{1,2}:\\d{1,2}:\\d{1,2}'}), is_leaf=True, yang_name="last-cleared-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='pub-type:time', is_config=False)""",
        })

    self.__last_cleared_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_last_cleared_time(self):
    self.__last_cleared_time = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{1,2}:\\d{1,2}:\\d{1,2}'}), is_leaf=True, yang_name="last-cleared-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='pub-type:time', is_config=False)


  def _get_in_bit_rate(self):
    """
    Getter method for in_bit_rate, mapped from YANG variable /ifm/remote_interfaces/remote_interface/remote_statistics_state/in_bit_rate (uint64)

    YANG Description: Rate at which bits are received.
    """
    return self.__in_bit_rate
      
  def _set_in_bit_rate(self, v, load=False):
    """
    Setter method for in_bit_rate, mapped from YANG variable /ifm/remote_interfaces/remote_interface/remote_statistics_state/in_bit_rate (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_bit_rate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_bit_rate() directly.

    YANG Description: Rate at which bits are received.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-bit-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_bit_rate must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-bit-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__in_bit_rate = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_bit_rate(self):
    self.__in_bit_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-bit-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)


  def _get_in_packet_rate(self):
    """
    Getter method for in_packet_rate, mapped from YANG variable /ifm/remote_interfaces/remote_interface/remote_statistics_state/in_packet_rate (uint64)

    YANG Description: Rate at which packets are received.
    """
    return self.__in_packet_rate
      
  def _set_in_packet_rate(self, v, load=False):
    """
    Setter method for in_packet_rate, mapped from YANG variable /ifm/remote_interfaces/remote_interface/remote_statistics_state/in_packet_rate (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_packet_rate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_packet_rate() directly.

    YANG Description: Rate at which packets are received.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-packet-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_packet_rate must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-packet-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__in_packet_rate = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_packet_rate(self):
    self.__in_packet_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-packet-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)


  def _get_in_peak_bit_rate(self):
    """
    Getter method for in_peak_bit_rate, mapped from YANG variable /ifm/remote_interfaces/remote_interface/remote_statistics_state/in_peak_bit_rate (uint64)

    YANG Description: Peak rate at which bits are received.
    """
    return self.__in_peak_bit_rate
      
  def _set_in_peak_bit_rate(self, v, load=False):
    """
    Setter method for in_peak_bit_rate, mapped from YANG variable /ifm/remote_interfaces/remote_interface/remote_statistics_state/in_peak_bit_rate (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_peak_bit_rate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_peak_bit_rate() directly.

    YANG Description: Peak rate at which bits are received.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-peak-bit-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_peak_bit_rate must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-peak-bit-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__in_peak_bit_rate = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_peak_bit_rate(self):
    self.__in_peak_bit_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-peak-bit-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)


  def _get_in_peak_bit_rate_record_time(self):
    """
    Getter method for in_peak_bit_rate_record_time, mapped from YANG variable /ifm/remote_interfaces/remote_interface/remote_statistics_state/in_peak_bit_rate_record_time (pub-type:time)

    YANG Description: Time when the peak bit receive rate is reached.
    """
    return self.__in_peak_bit_rate_record_time
      
  def _set_in_peak_bit_rate_record_time(self, v, load=False):
    """
    Setter method for in_peak_bit_rate_record_time, mapped from YANG variable /ifm/remote_interfaces/remote_interface/remote_statistics_state/in_peak_bit_rate_record_time (pub-type:time)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_peak_bit_rate_record_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_peak_bit_rate_record_time() directly.

    YANG Description: Time when the peak bit receive rate is reached.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{1,2}:\\d{1,2}:\\d{1,2}'}), is_leaf=True, yang_name="in-peak-bit-rate-record-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='pub-type:time', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_peak_bit_rate_record_time must be of a type compatible with pub-type:time""",
          'defined-type': "pub-type:time",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{1,2}:\\d{1,2}:\\d{1,2}'}), is_leaf=True, yang_name="in-peak-bit-rate-record-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='pub-type:time', is_config=False)""",
        })

    self.__in_peak_bit_rate_record_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_peak_bit_rate_record_time(self):
    self.__in_peak_bit_rate_record_time = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{1,2}:\\d{1,2}:\\d{1,2}'}), is_leaf=True, yang_name="in-peak-bit-rate-record-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='pub-type:time', is_config=False)


  def _get_out_bit_rate(self):
    """
    Getter method for out_bit_rate, mapped from YANG variable /ifm/remote_interfaces/remote_interface/remote_statistics_state/out_bit_rate (uint64)

    YANG Description: Rate at which bits are sent.
    """
    return self.__out_bit_rate
      
  def _set_out_bit_rate(self, v, load=False):
    """
    Setter method for out_bit_rate, mapped from YANG variable /ifm/remote_interfaces/remote_interface/remote_statistics_state/out_bit_rate (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_bit_rate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_bit_rate() directly.

    YANG Description: Rate at which bits are sent.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-bit-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_bit_rate must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-bit-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__out_bit_rate = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_bit_rate(self):
    self.__out_bit_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-bit-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)


  def _get_out_packet_rate(self):
    """
    Getter method for out_packet_rate, mapped from YANG variable /ifm/remote_interfaces/remote_interface/remote_statistics_state/out_packet_rate (uint64)

    YANG Description: Rate at which packets are sent.
    """
    return self.__out_packet_rate
      
  def _set_out_packet_rate(self, v, load=False):
    """
    Setter method for out_packet_rate, mapped from YANG variable /ifm/remote_interfaces/remote_interface/remote_statistics_state/out_packet_rate (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_packet_rate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_packet_rate() directly.

    YANG Description: Rate at which packets are sent.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-packet-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_packet_rate must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-packet-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__out_packet_rate = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_packet_rate(self):
    self.__out_packet_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-packet-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)


  def _get_out_peak_bit_rate(self):
    """
    Getter method for out_peak_bit_rate, mapped from YANG variable /ifm/remote_interfaces/remote_interface/remote_statistics_state/out_peak_bit_rate (uint64)

    YANG Description: Peak rate at which bits are sent.
    """
    return self.__out_peak_bit_rate
      
  def _set_out_peak_bit_rate(self, v, load=False):
    """
    Setter method for out_peak_bit_rate, mapped from YANG variable /ifm/remote_interfaces/remote_interface/remote_statistics_state/out_peak_bit_rate (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_peak_bit_rate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_peak_bit_rate() directly.

    YANG Description: Peak rate at which bits are sent.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-peak-bit-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_peak_bit_rate must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-peak-bit-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__out_peak_bit_rate = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_peak_bit_rate(self):
    self.__out_peak_bit_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-peak-bit-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)


  def _get_out_peak_bit_rate_record_time(self):
    """
    Getter method for out_peak_bit_rate_record_time, mapped from YANG variable /ifm/remote_interfaces/remote_interface/remote_statistics_state/out_peak_bit_rate_record_time (pub-type:time)

    YANG Description: Time when the peak bit send rate is reached.
    """
    return self.__out_peak_bit_rate_record_time
      
  def _set_out_peak_bit_rate_record_time(self, v, load=False):
    """
    Setter method for out_peak_bit_rate_record_time, mapped from YANG variable /ifm/remote_interfaces/remote_interface/remote_statistics_state/out_peak_bit_rate_record_time (pub-type:time)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_peak_bit_rate_record_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_peak_bit_rate_record_time() directly.

    YANG Description: Time when the peak bit send rate is reached.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{1,2}:\\d{1,2}:\\d{1,2}'}), is_leaf=True, yang_name="out-peak-bit-rate-record-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='pub-type:time', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_peak_bit_rate_record_time must be of a type compatible with pub-type:time""",
          'defined-type': "pub-type:time",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{1,2}:\\d{1,2}:\\d{1,2}'}), is_leaf=True, yang_name="out-peak-bit-rate-record-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='pub-type:time', is_config=False)""",
        })

    self.__out_peak_bit_rate_record_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_peak_bit_rate_record_time(self):
    self.__out_peak_bit_rate_record_time = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{1,2}:\\d{1,2}:\\d{1,2}'}), is_leaf=True, yang_name="out-peak-bit-rate-record-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='pub-type:time', is_config=False)


  def _get_in_use_rate(self):
    """
    Getter method for in_use_rate, mapped from YANG variable /ifm/remote_interfaces/remote_interface/remote_statistics_state/in_use_rate (string)

    YANG Description: Received bandwidth usage.
    """
    return self.__in_use_rate
      
  def _set_in_use_rate(self, v, load=False):
    """
    Setter method for in_use_rate, mapped from YANG variable /ifm/remote_interfaces/remote_interface/remote_statistics_state/in_use_rate (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_use_rate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_use_rate() directly.

    YANG Description: Received bandwidth usage.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..50']}), is_leaf=True, yang_name="in-use-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_use_rate must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..50']}), is_leaf=True, yang_name="in-use-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='string', is_config=False)""",
        })

    self.__in_use_rate = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_use_rate(self):
    self.__in_use_rate = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..50']}), is_leaf=True, yang_name="in-use-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='string', is_config=False)


  def _get_out_use_rate(self):
    """
    Getter method for out_use_rate, mapped from YANG variable /ifm/remote_interfaces/remote_interface/remote_statistics_state/out_use_rate (string)

    YANG Description: Sent bandwidth usage.
    """
    return self.__out_use_rate
      
  def _set_out_use_rate(self, v, load=False):
    """
    Setter method for out_use_rate, mapped from YANG variable /ifm/remote_interfaces/remote_interface/remote_statistics_state/out_use_rate (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_use_rate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_use_rate() directly.

    YANG Description: Sent bandwidth usage.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..50']}), is_leaf=True, yang_name="out-use-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_use_rate must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..50']}), is_leaf=True, yang_name="out-use-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='string', is_config=False)""",
        })

    self.__out_use_rate = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_use_rate(self):
    self.__out_use_rate = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..50']}), is_leaf=True, yang_name="out-use-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='string', is_config=False)

  last_cleared_time = __builtin__.property(_get_last_cleared_time)
  in_bit_rate = __builtin__.property(_get_in_bit_rate)
  in_packet_rate = __builtin__.property(_get_in_packet_rate)
  in_peak_bit_rate = __builtin__.property(_get_in_peak_bit_rate)
  in_peak_bit_rate_record_time = __builtin__.property(_get_in_peak_bit_rate_record_time)
  out_bit_rate = __builtin__.property(_get_out_bit_rate)
  out_packet_rate = __builtin__.property(_get_out_packet_rate)
  out_peak_bit_rate = __builtin__.property(_get_out_peak_bit_rate)
  out_peak_bit_rate_record_time = __builtin__.property(_get_out_peak_bit_rate_record_time)
  in_use_rate = __builtin__.property(_get_in_use_rate)
  out_use_rate = __builtin__.property(_get_out_use_rate)


  _pyangbind_elements = OrderedDict([('last_cleared_time', last_cleared_time), ('in_bit_rate', in_bit_rate), ('in_packet_rate', in_packet_rate), ('in_peak_bit_rate', in_peak_bit_rate), ('in_peak_bit_rate_record_time', in_peak_bit_rate_record_time), ('out_bit_rate', out_bit_rate), ('out_packet_rate', out_packet_rate), ('out_peak_bit_rate', out_peak_bit_rate), ('out_peak_bit_rate_record_time', out_peak_bit_rate_record_time), ('in_use_rate', in_use_rate), ('out_use_rate', out_use_rate), ])


class yc_remote_interface_huawei_ifm__ifm_remote_interfaces_remote_interface(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-ifm - based on the path /ifm/remote-interfaces/remote-interface. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Statistics of remote interfaces.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__index','__remote_statistics_state',)

  _yang_name = 'remote-interface'
  _yang_namespace = 'urn:huawei:yang:huawei-ifm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..63']}), is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='pub-type:if-name', is_config=False)
    self.__index = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)
    self.__remote_statistics_state = YANGDynClass(base=yc_remote_statistics_state_huawei_ifm__ifm_remote_interfaces_remote_interface_remote_statistics_state, is_container='container', yang_name="remote-statistics-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ifm', 'remote-interfaces', 'remote-interface']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /ifm/remote_interfaces/remote_interface/name (pub-type:if-name)

    YANG Description: Name of a remote interface.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /ifm/remote_interfaces/remote_interface/name (pub-type:if-name)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of a remote interface.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..63']}), is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='pub-type:if-name', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with pub-type:if-name""",
          'defined-type': "pub-type:if-name",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..63']}), is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='pub-type:if-name', is_config=False)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..63']}), is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='pub-type:if-name', is_config=False)


  def _get_index(self):
    """
    Getter method for index, mapped from YANG variable /ifm/remote_interfaces/remote_interface/index (uint32)

    YANG Description: Index of a remote interface.
    """
    return self.__index
      
  def _set_index(self, v, load=False):
    """
    Setter method for index, mapped from YANG variable /ifm/remote_interfaces/remote_interface/index (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_index is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_index() directly.

    YANG Description: Index of a remote interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """index must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)""",
        })

    self.__index = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_index(self):
    self.__index = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)


  def _get_remote_statistics_state(self):
    """
    Getter method for remote_statistics_state, mapped from YANG variable /ifm/remote_interfaces/remote_interface/remote_statistics_state (container)

    YANG Description: Statistics of remote interfaces.
    """
    return self.__remote_statistics_state
      
  def _set_remote_statistics_state(self, v, load=False):
    """
    Setter method for remote_statistics_state, mapped from YANG variable /ifm/remote_interfaces/remote_interface/remote_statistics_state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_remote_statistics_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_remote_statistics_state() directly.

    YANG Description: Statistics of remote interfaces.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_remote_statistics_state_huawei_ifm__ifm_remote_interfaces_remote_interface_remote_statistics_state, is_container='container', yang_name="remote-statistics-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """remote_statistics_state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_remote_statistics_state_huawei_ifm__ifm_remote_interfaces_remote_interface_remote_statistics_state, is_container='container', yang_name="remote-statistics-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=False)""",
        })

    self.__remote_statistics_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_remote_statistics_state(self):
    self.__remote_statistics_state = YANGDynClass(base=yc_remote_statistics_state_huawei_ifm__ifm_remote_interfaces_remote_interface_remote_statistics_state, is_container='container', yang_name="remote-statistics-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=False)

  name = __builtin__.property(_get_name)
  index = __builtin__.property(_get_index)
  remote_statistics_state = __builtin__.property(_get_remote_statistics_state) # type: yc_remote_statistics_state_huawei_ifm__ifm_remote_interfaces_remote_interface_remote_statistics_state


  _pyangbind_elements = OrderedDict([('name', name), ('index', index), ('remote_statistics_state', remote_statistics_state), ])


class yc_remote_interfaces_huawei_ifm__ifm_remote_interfaces(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-ifm - based on the path /ifm/remote-interfaces. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of statistics of remote interfaces.
  """
  __slots__ = ('_path_helper', '_extmethods', '__remote_interface',)

  _yang_name = 'remote-interfaces'
  _yang_namespace = 'urn:huawei:yang:huawei-ifm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__remote_interface = YANGDynClass(base=YANGListType("name",yc_remote_interface_huawei_ifm__ifm_remote_interfaces_remote_interface, yang_name="remote-interface", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="remote-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ifm', 'remote-interfaces']

  def _get_remote_interface(self):
    """
    Getter method for remote_interface, mapped from YANG variable /ifm/remote_interfaces/remote_interface (list)

    YANG Description: Statistics of remote interfaces.
    """
    return self.__remote_interface
      
  def _set_remote_interface(self, v, load=False):
    """
    Setter method for remote_interface, mapped from YANG variable /ifm/remote_interfaces/remote_interface (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_remote_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_remote_interface() directly.

    YANG Description: Statistics of remote interfaces.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_remote_interface_huawei_ifm__ifm_remote_interfaces_remote_interface, yang_name="remote-interface", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="remote-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """remote_interface must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_remote_interface_huawei_ifm__ifm_remote_interfaces_remote_interface, yang_name="remote-interface", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="remote-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='list', is_config=False)""",
        })

    self.__remote_interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_remote_interface(self):
    self.__remote_interface = YANGDynClass(base=YANGListType("name",yc_remote_interface_huawei_ifm__ifm_remote_interfaces_remote_interface, yang_name="remote-interface", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="remote-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='list', is_config=False)

  remote_interface = __builtin__.property(_get_remote_interface) # type: yc_remote_interface_huawei_ifm__ifm_remote_interfaces_remote_interface


  _pyangbind_elements = OrderedDict([('remote_interface', remote_interface), ])


class yc_ifm_huawei_ifm__ifm(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-ifm - based on the path /ifm. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Common interface management. It includes the public configuration of interfaces.
  """
  __slots__ = ('_path_helper', '_extmethods', '__global_','__damp','__auto_recovery_times','__interfaces','__static_dimension_ranges','__ipv4_interface_count','__remote_interfaces',)

  _yang_name = 'ifm'
  _yang_namespace = 'urn:huawei:yang:huawei-ifm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__global_ = YANGDynClass(base=yc_global__huawei_ifm__ifm_global, is_container='container', yang_name="global", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)
    self.__damp = YANGDynClass(base=yc_damp_huawei_ifm__ifm_damp, is_container='container', yang_name="damp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)
    self.__auto_recovery_times = YANGDynClass(base=yc_auto_recovery_times_huawei_ifm__ifm_auto_recovery_times, is_container='container', yang_name="auto-recovery-times", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)
    self.__interfaces = YANGDynClass(base=yc_interfaces_huawei_ifm__ifm_interfaces, is_container='container', yang_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)
    self.__static_dimension_ranges = YANGDynClass(base=yc_static_dimension_ranges_huawei_ifm__ifm_static_dimension_ranges, is_container='container', yang_name="static-dimension-ranges", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)
    self.__ipv4_interface_count = YANGDynClass(base=yc_ipv4_interface_count_huawei_ifm__ifm_ipv4_interface_count, is_container='container', yang_name="ipv4-interface-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)
    self.__remote_interfaces = YANGDynClass(base=yc_remote_interfaces_huawei_ifm__ifm_remote_interfaces, is_container='container', yang_name="remote-interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ifm']

  def _get_global_(self):
    """
    Getter method for global_, mapped from YANG variable /ifm/global (container)

    YANG Description: Configure globally configured attributes.
    """
    return self.__global_
      
  def _set_global_(self, v, load=False):
    """
    Setter method for global_, mapped from YANG variable /ifm/global (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_global_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_global_() directly.

    YANG Description: Configure globally configured attributes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_global__huawei_ifm__ifm_global, is_container='container', yang_name="global", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """global_ must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_global__huawei_ifm__ifm_global, is_container='container', yang_name="global", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)""",
        })

    self.__global_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_global_(self):
    self.__global_ = YANGDynClass(base=yc_global__huawei_ifm__ifm_global, is_container='container', yang_name="global", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)


  def _get_damp(self):
    """
    Getter method for damp, mapped from YANG variable /ifm/damp (container)

    YANG Description: Enable/disable suppression on interfaces' physical status flappings.
    """
    return self.__damp
      
  def _set_damp(self, v, load=False):
    """
    Setter method for damp, mapped from YANG variable /ifm/damp (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_damp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_damp() directly.

    YANG Description: Enable/disable suppression on interfaces' physical status flappings.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_damp_huawei_ifm__ifm_damp, is_container='container', yang_name="damp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """damp must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_damp_huawei_ifm__ifm_damp, is_container='container', yang_name="damp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)""",
        })

    self.__damp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_damp(self):
    self.__damp = YANGDynClass(base=yc_damp_huawei_ifm__ifm_damp, is_container='container', yang_name="damp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)


  def _get_auto_recovery_times(self):
    """
    Getter method for auto_recovery_times, mapped from YANG variable /ifm/auto_recovery_times (container)

    YANG Description: List of automatic recovery time configuration.
    """
    return self.__auto_recovery_times
      
  def _set_auto_recovery_times(self, v, load=False):
    """
    Setter method for auto_recovery_times, mapped from YANG variable /ifm/auto_recovery_times (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_auto_recovery_times is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_auto_recovery_times() directly.

    YANG Description: List of automatic recovery time configuration.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_auto_recovery_times_huawei_ifm__ifm_auto_recovery_times, is_container='container', yang_name="auto-recovery-times", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """auto_recovery_times must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_auto_recovery_times_huawei_ifm__ifm_auto_recovery_times, is_container='container', yang_name="auto-recovery-times", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)""",
        })

    self.__auto_recovery_times = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_auto_recovery_times(self):
    self.__auto_recovery_times = YANGDynClass(base=yc_auto_recovery_times_huawei_ifm__ifm_auto_recovery_times, is_container='container', yang_name="auto-recovery-times", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)


  def _get_interfaces(self):
    """
    Getter method for interfaces, mapped from YANG variable /ifm/interfaces (container)

    YANG Description: List of configuring information on an interface.
    """
    return self.__interfaces
      
  def _set_interfaces(self, v, load=False):
    """
    Setter method for interfaces, mapped from YANG variable /ifm/interfaces (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interfaces is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interfaces() directly.

    YANG Description: List of configuring information on an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_interfaces_huawei_ifm__ifm_interfaces, is_container='container', yang_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interfaces must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_interfaces_huawei_ifm__ifm_interfaces, is_container='container', yang_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)""",
        })

    self.__interfaces = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interfaces(self):
    self.__interfaces = YANGDynClass(base=yc_interfaces_huawei_ifm__ifm_interfaces, is_container='container', yang_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)


  def _get_static_dimension_ranges(self):
    """
    Getter method for static_dimension_ranges, mapped from YANG variable /ifm/static_dimension_ranges (container)

    YANG Description: List of interface dimensionality.
    """
    return self.__static_dimension_ranges
      
  def _set_static_dimension_ranges(self, v, load=False):
    """
    Setter method for static_dimension_ranges, mapped from YANG variable /ifm/static_dimension_ranges (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_static_dimension_ranges is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_static_dimension_ranges() directly.

    YANG Description: List of interface dimensionality.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_static_dimension_ranges_huawei_ifm__ifm_static_dimension_ranges, is_container='container', yang_name="static-dimension-ranges", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """static_dimension_ranges must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_static_dimension_ranges_huawei_ifm__ifm_static_dimension_ranges, is_container='container', yang_name="static-dimension-ranges", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)""",
        })

    self.__static_dimension_ranges = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_static_dimension_ranges(self):
    self.__static_dimension_ranges = YANGDynClass(base=yc_static_dimension_ranges_huawei_ifm__ifm_static_dimension_ranges, is_container='container', yang_name="static-dimension-ranges", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)


  def _get_ipv4_interface_count(self):
    """
    Getter method for ipv4_interface_count, mapped from YANG variable /ifm/ipv4_interface_count (container)

    YANG Description: Statistics of interfaces supporting IPv4 address configuration.
    """
    return self.__ipv4_interface_count
      
  def _set_ipv4_interface_count(self, v, load=False):
    """
    Setter method for ipv4_interface_count, mapped from YANG variable /ifm/ipv4_interface_count (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv4_interface_count is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv4_interface_count() directly.

    YANG Description: Statistics of interfaces supporting IPv4 address configuration.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ipv4_interface_count_huawei_ifm__ifm_ipv4_interface_count, is_container='container', yang_name="ipv4-interface-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv4_interface_count must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ipv4_interface_count_huawei_ifm__ifm_ipv4_interface_count, is_container='container', yang_name="ipv4-interface-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)""",
        })

    self.__ipv4_interface_count = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv4_interface_count(self):
    self.__ipv4_interface_count = YANGDynClass(base=yc_ipv4_interface_count_huawei_ifm__ifm_ipv4_interface_count, is_container='container', yang_name="ipv4-interface-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)


  def _get_remote_interfaces(self):
    """
    Getter method for remote_interfaces, mapped from YANG variable /ifm/remote_interfaces (container)

    YANG Description: List of statistics of remote interfaces.
    """
    return self.__remote_interfaces
      
  def _set_remote_interfaces(self, v, load=False):
    """
    Setter method for remote_interfaces, mapped from YANG variable /ifm/remote_interfaces (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_remote_interfaces is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_remote_interfaces() directly.

    YANG Description: List of statistics of remote interfaces.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_remote_interfaces_huawei_ifm__ifm_remote_interfaces, is_container='container', yang_name="remote-interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """remote_interfaces must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_remote_interfaces_huawei_ifm__ifm_remote_interfaces, is_container='container', yang_name="remote-interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)""",
        })

    self.__remote_interfaces = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_remote_interfaces(self):
    self.__remote_interfaces = YANGDynClass(base=yc_remote_interfaces_huawei_ifm__ifm_remote_interfaces, is_container='container', yang_name="remote-interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)

  global_ = __builtin__.property(_get_global_, _set_global_) # type: yc_global__huawei_ifm__ifm_global
  damp = __builtin__.property(_get_damp, _set_damp) # type: yc_damp_huawei_ifm__ifm_damp
  auto_recovery_times = __builtin__.property(_get_auto_recovery_times, _set_auto_recovery_times) # type: yc_auto_recovery_times_huawei_ifm__ifm_auto_recovery_times
  interfaces = __builtin__.property(_get_interfaces, _set_interfaces) # type: yc_interfaces_huawei_ifm__ifm_interfaces
  static_dimension_ranges = __builtin__.property(_get_static_dimension_ranges, _set_static_dimension_ranges) # type: yc_static_dimension_ranges_huawei_ifm__ifm_static_dimension_ranges
  ipv4_interface_count = __builtin__.property(_get_ipv4_interface_count, _set_ipv4_interface_count) # type: yc_ipv4_interface_count_huawei_ifm__ifm_ipv4_interface_count
  remote_interfaces = __builtin__.property(_get_remote_interfaces, _set_remote_interfaces) # type: yc_remote_interfaces_huawei_ifm__ifm_remote_interfaces


  _pyangbind_elements = OrderedDict([('global_', global_), ('damp', damp), ('auto_recovery_times', auto_recovery_times), ('interfaces', interfaces), ('static_dimension_ranges', static_dimension_ranges), ('ipv4_interface_count', ipv4_interface_count), ('remote_interfaces', remote_interfaces), ])


class huawei_ifm(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-ifm - based on the path /huawei-ifm. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Common interface management, which includes the public configuration of interfaces.
  """
  __slots__ = ('_path_helper', '_extmethods', '__ifm',)

  _yang_name = 'huawei-ifm'
  _yang_namespace = 'urn:huawei:yang:huawei-ifm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ifm = YANGDynClass(base=yc_ifm_huawei_ifm__ifm, is_container='container', yang_name="ifm", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_ifm(self):
    """
    Getter method for ifm, mapped from YANG variable /ifm (container)

    YANG Description: Common interface management. It includes the public configuration of interfaces.
    """
    return self.__ifm
      
  def _set_ifm(self, v, load=False):
    """
    Setter method for ifm, mapped from YANG variable /ifm (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ifm is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ifm() directly.

    YANG Description: Common interface management. It includes the public configuration of interfaces.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ifm_huawei_ifm__ifm, is_container='container', yang_name="ifm", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ifm must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ifm_huawei_ifm__ifm, is_container='container', yang_name="ifm", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)""",
        })

    self.__ifm = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ifm(self):
    self.__ifm = YANGDynClass(base=yc_ifm_huawei_ifm__ifm, is_container='container', yang_name="ifm", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)

  ifm = __builtin__.property(_get_ifm, _set_ifm) # type: yc_ifm_huawei_ifm__ifm


  _pyangbind_elements = OrderedDict([('ifm', ifm), ])


